# 二十种设计模式简要概括以及其UML图示例 

[2017-02-20][0]# 工厂模式Factory（创建型）

工厂（Factory）负责组装生产产品，客户只需要告知工厂需要生产的产品即可获得产品。

![工厂模式][1]

### 建造者模式（创建型）

建造者模式是在工厂模式之上建立更加复杂的对象，在各个工厂生产出产品后再将每个产品进行组合

![建造者模式][2]

### 单例模式Singleton（创建型）

单例模式比较简单，保证对象是单例即可，在类中添加一个类似于get_instance()的方法获取对象

![单例模式][3]

### 原型模式Prototype（创建型）

原型模式是通过clone的方式采用原型，减少加工所产生的资源消耗  
对原型进行clone操作，并在clone之后进一步对其进行加工生产

![原型模式][4]

### 适配器模式Adapter（结构型）

为了不更改adaptee但又想适配各种不同的类而采用的设计模式  
一个有趣的现实生活中的例子就是：到不同的国家去旅游需要购买不一样的充电适配器才可以对你的设备进行充电

![适配器模式][5]

### 桥连模式Bridge（结构型）

不同的一类对象中根据不同的另一类对象实现桥连

```php
$objRAbstraction = new SmallBrushPenRefinedAbstraction();  

$objRAbstraction->setImplementorColor(new oncreteImplementorRed());  

$objRAbstraction->operationDraw();
```
![桥连模式][6]

### 组合模式Composite（结构型）

组合模式就是将需要进行操作的各个类放到一个操作类中，操作类作为父节点，被操作的作为子节点形成树结构，最后通过循环等方式对子节点进行遍历执行操作

![组合模式][7]

### 装饰器Decorator模式（结构型）

客户操作装饰器，装饰器实例化组件并且对组件进行装饰，产生装饰器模式

![装饰器模式][8]

### 外观模式Facade（结构型）

由于系统的增长系统变得十分之复杂，多出许多小的类出来，客户需要组合进行使用。  
而这时可以创建一个facade具体对子类的组合操作在facade中进行，客户只需要认准facade即可

![外观模式][9]

### 享元模式Flyweight（结构型）

由于需要大量重复创建对象，为了节约资源我们使用享元池（即对象池）存放享元，提高对象利用率  
利用一个享元工厂来创建存放享元，客户端直接通过享元工厂获取享元对象并并且工厂将享元放入工厂的享元池中

![享元模式][10]

### 代理模式Proxy（结构型）

客户直接操作的是代理并非操作实现类，代理类与实现类继承同一个接口，但是代理类通过代理的方式调用实现类的方法

![代理模式][11]

### 命令模式Command（对象行为型）

一个系列操作对应一个命令类，并且设置一个接受者，通过命令类去操作接受者。各个命令类放在遥控器类当中进行存储和操作

![命令模式][12]

### 迭代器模式Iterator（对象行为型）

迭代器模式十分之容易理解，就是专门用于迭代数组或对象的  
在C++中有专门的Iterator，这里的迭代器模式也是类似的，可以通过循环便利出所有的元素

![迭代器模式][13]

### 中介者模式Mediator（对象行为型）

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。  
中介者保存各个对象之间需要相互联系的关系，而对象只需要调用中介者即可调用其他子对象，从而减少子类的生成。

![中介者模式][14]

### 观察者模式Observer（对象行为型）

在一个具体实现类中存放观察者，在具体实现类进行类似于“update”的操作的时候遍历通知所有的观察者，对观察者进行notify操作

![观察者模式][15]

### 状态模式State（对象行为型）

把不同状态的操作分散到不同的状态对象里去完成  
进行每一种操作时找到当前状态类并发起操作，在操作完成后需要转换当前的状态，并且下一次操作的是转换后的状态类  
在大量需要使用case if等条件判断语句时，状态模式可以大量减少case if等语句的使用

![状态模式][16]

### 策略模式Strategy（对象行为型）

有点类似于状态模式，每一个策略对应一个类，并通过Context类进行调用。但不同的是使用者需要知道所有的策略，并根据需要使用相应的策略

![策略模式][17]

### 模版方法模式Template method（类行为型）

一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。  
各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。  
控制子类扩展。模板方法只在特定点调用“ hook”操作 ，这样就只允许在这些点进行扩展。  
重用父类作为模板，遵从父类实现逻辑，通过重写方法实现细节控制

![模版方法模式][18]

### 访问者模式Visitor（对象行为型）

一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。  
需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。  
定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

![访问者模式][19]

### 参考

[Gof《设计模式》（作者：guisu）][20]

[0]: https://www.jwlchina.cn/2017/02/20/二十种设计模式简要概括以及其UML图示例/
[1]: ./img/工厂模式.jpg
[2]: ./img/建造者模式.jpg
[3]: ./img/单例模式.jpg
[4]: ./img/原型模式.jpg
[5]: ./img/适配器模式.jpg
[6]: ./img/桥连模式.jpg
[7]: ./img/组合模式.jpg
[8]: ./img/装饰器模式.jpg
[9]: ./img/外观模式.jpg
[10]: ./img/享元模式.jpg
[11]: ./img/代理模式.jpg
[12]: ./img/命令模式.jpg
[13]: ./img/迭代器模式.jpg
[14]: ./img/中介者模式.jpg
[15]: ./img/观察者模式.jpg
[16]: ./img/状态模式.jpg
[17]: ./img/策略模式.jpg
[18]: ./img/模版方法模式.jpg
[19]: ./img/访问者模式.jpg
[20]: http://blog.csdn.net/hguisu/article/category/1133340