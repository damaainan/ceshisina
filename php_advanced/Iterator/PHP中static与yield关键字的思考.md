## PHP中static与yield关键字的思考

来源：[https://blog.csdn.net/hel12he/article/details/77931984](https://blog.csdn.net/hel12he/article/details/77931984)

时间：

版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/hel12he/article/details/77931984				

你以为你知道了一切，只是你以为而已。知识的美妙就在于，一生的时光在它面前显得多么的短暂。

嗯嗯，扯远了，我今天只想说说： **`static`**  与 **`yield`** 。

先来说说`static`关键字。本篇只讲静态方法的使用与后期绑定的知识点。


## static 什么时候用来修饰方法

`static`关键字大家都知道是用来修饰方法与属性的。 那么大家在项目中会在哪些场景下使用它？

我遇到过几个项目，要求所有的方法全部`static`化，当然控制器方法不能这么干。原因之一就是：静态方法执行效率高？那么我们基于此来分析一下。

首先执行效率高我是没有意见的。哪么是不是因为它效率高，就该毫无节制的使用在项目中？讨论这个问题先来回顾下编程语言的历史。在早一点的时候，还没有面向对象，采用的都是结构化编程，当时基本上所有的方法都是 **`静态方法`** ，然后有了面向对象，产生了实例化的概念。

从上面简短的发展过程可以看出，如果仅仅为了性能，哪么面向对象好像没有存在的必要。那么这些大师为了要在`c++``java`这些语言中引入面向对象、引入实例化的感念呢？我觉得是因为伴随发展，项目越来越大，需要更好的组织代码方式与编程思维。

再回过头来看`static`，它定义的静态方法，效率确实高，但是会持续占用内存，只有在程序退出时才结束生命周期，期间无法进行销毁等副作用是其一；其二从设计模式上来说，它具有强耦合性，外部可修改 static 属性；其三static定义的方法没有办法override来重写，ioc di等概念无用武之地；其四在进行单元测试时，静态方法让人头痛。

那么通过上面所说，感觉以后还是别用 **`static`**  方法了，老老实实的实例化然后调用方法？咱们得理性，不能极端到什么地方都用，也不能一丁点都不用。一句话：学会面向对象的方式来思考。我们写代码的第一考虑点我觉得是：可扩展性（应对业务快速变化），可维护性（线上问题及时修复）。高效率应该是最后再来考虑（因为优化效率的手段非常之多，并不一定非要给每个方法加个: static）。如果从面向对象的角度出发，这个方法完全独立跟类属性无关，那么就用 **`static`**  吧。

总之是站在面向对象的角度，软件设计的层次来考虑语法的使用，而不是为了效率破坏掉代码的美。

## static 后期静态绑定

这一点php的文档做了详细的介绍，但是我以前一直很少关注这个地方，基本上都是使用`self::`的方式进行静态方法与属性的调用。

我觉得后期绑定某种程度上，像是静态方法的重载。这里贴出 php 文档中的例子来进行一下讲述

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
        static::who();// 后期静态绑定
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();

```

如果是`self::who()`调用，会输出： **`A`** 。如果是`static::who()`会输出 **`B`** 

这样来看，是不是相当于 class B重写了父类 A 的`who()`方法？那么如果灵活使用这个特性，可以让 static 具备更强的灵活性。充分发挥其性能优势，又能解决扩展性差的问题。当然还是一样，要从面向对象的角度出发，一切适可而止。

## PHP 中 yield 的使用场景

说实话，很长一段时间我并不知道`php`还有这么个语法。直到有一天我在 js 中遇到了这个关键字，感觉这么不明觉厉的东西，世界上最好的语言怎么没有？回头看文档，真有，不愧为世界上最好的语言。

那么 **`yield`**  的使用场景是什么？刚好最近有人 sg 上面问道我，借此整理一下。希望大家能够将它更多的结合自己的业务进行使用。这里不会进行`yield`与`Iterator`的比较。相信看完后，你能够明了二者的谁更简介。

先说它的使用场景，还是得先回顾历史，在没有 yield 之前，我们要生成一个数组，只能一次性把所有内容全部读入内存（当然也可以通过实现`Iterator`接口实现一个迭代）。有了`yield`之后，我们可以通过一个简单的`yield`关键字，完成一个数组的生成，并且是用到的时候才会产生值，相对而言内存占用肯定会下降。空口无凭，咱们下面通过代码实际检验一下上面的结论。
 **`先来看普通模式`** 

```php
<?php

function generateData($max)
{
    $arr = [];
    for ($i = 0; $i <= $max; $i++) {
        $arr[] = $i;
    }
}

echo '开始前内存占用：' . memory_get_usage() . PHP_EOL;
$data = generateData(100000);
echo '生成完数组后内存占用：' . memory_get_usage() . PHP_EOL;
unset($data);
echo '释放后的内存占用：' . memory_get_usage() . PHP_EOL;
```

运行得到结果：

``` 
开始前内存占用：231528
生成完数组后内存占用：231712
释放后的内存占用：231576
```

前后的差值是： **`184`** 

-----
 **`使用yield后的效果`** 

```php
function generateData($max)
{
  for ($i = 0; $i <= $max; $i++) {
      yield $i;
  }
}

echo '开始前内存占用：' . memory_get_usage() . PHP_EOL;
$data = generateData(100000);// 这里实际上得到的是一个迭代器
echo '生成完数组后内存占用：' . memory_get_usage() . PHP_EOL;
unset($data);
echo '释放后的内存占用：' . memory_get_usage() . PHP_EOL;
```

运行结果：

``` 
开始前内存占用：228968
生成完数组后内存占用：229824
释放后的内存占用：229016
```

前后的差值是： **`856`** 

奇怪，使用了 **`yield`**  后，内存占用反而上升了，这是什么鬼？别急。上面我们参数传入的是 **`100,000`** ，我现在将传入参数改成改成 **`1,000,000`** 试试。


第一个方法得到的结果是：

``` 
开始前内存占用：231528

Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 32 bytes) in /test/yield.php on line 6
```

看了吧，一百万次的循环时，一次性载入内存，超出了限制。那么再来看 yield 的执行结果:

``` 
开始前内存占用：228968
生成完数组后内存占用：229824
释放后的内存占用：229016
```

前后的差值依然是： **`856`** 

好了到这里，应该看出来了， **`yield`** 无论数组大小，占用均是 **`856`**  ，这是因为它自身，它在你进行迭代的时候才会产生真实数据。

所以如果你的数据来源非常大，那么用 yield 吧。如果数据来源很小，当然选择一次载入内存。

-----

GitHub：[https://github.com/helei112g][1]  
我在github开源了支付宝支付、微信支付、招商一网通支付的php sdk。希望能够帮助你提升项目开发的效率。[项目地址][2]

[1]: https://github.com/helei112g
[2]: https://github.com/helei112g/payment
