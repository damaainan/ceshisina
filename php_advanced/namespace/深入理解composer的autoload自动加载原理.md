# [深入理解composer的autoload自动加载原理][0]

 2016-07-28  

- - -

composer可谓有一统PHP界的趋势，从此PHP开发成了搭积木的游戏。其中composer的autoload功能可是一大亮点，今天看到一篇文章，能帮大家深入理解composer自动加载的原理，分享给大家，原文出处：[如何使用composer的autoload来自动加载自己编写的函数库与类库？][3]

composer的出现真是让人们眼前一亮，web开发从此变成了一件很『好玩』的事情，开发一个CMS就像在搭积木，从packagist中取出『积木』搭建在自己的代码中，一点一点搭建出一个属于自己的王国。  
从此以后我基本就抛弃了require和include函数，一个项目中，这两个函数只可能出现一次，那就是`require '../vendor/autoload.php'`。  
那么，既然抛弃了传统的文件包含方法，我们使用所有类库都将用namespace和composer自带的autoload。可是，我们自己编写的函数库与类库，怎么用composer的方法来自动加载呢？

这就要从composer.json说起，我们需要通过修改这个文件来达到目的。  
composer.json相当于是composer的配置文件，这个配置文件中有一个autoload段，比如我的一个项目：

![autoload][4]

其中又包含主要的两个选项: `files` 和 `psr-4`。  
files就是需要composer自动帮我们加载的函数库（不含类），只要在后面的数组中将函数库的文件路径写入即可。  
`psr-4`顾名思义，是一个基于`psr-4`（[http://www.php-fig.org/psr/psr-4/][5]）规则的类库自动加载对应关系，只要在其后的对象中，以 "命名空间": "路径" 的方式写入自己的类库信息即可。  
修改完成后，只要执行一下`composer update`，即可完成对应工作。

之后，我们在项目中，用如下方式即可加载自定义类库：

    new \Core\View();

composer的`autoload`将会自动包含`”./core/view.php”`，并找到其中的Core命名空间下的View类。

我们来深挖一下，探索一下autoload的原理。  
在我们修改完composer.json并执行`update`后，将会修改`./vender/composer/autoload_psr4.php`，比如我的某个项目，其中增加了这样一个对应关系：

![autoload][6]

这其实就是我刚刚在`.json`中添加的对应关系，他等于将`.josn`的配置文件，换成了php的形式。  
那么我看到vendor/autoload.php：

```php
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInitff1d77c91141523097b07ee2acc23326::getLoader();
    
```

其执行了一个自动生成的类`ComposerAutoloaderInitff1d77c91141523097b07ee2acc23326`中的`getLoader`方法。  
跟进：

```php
public static function getLoader()
{
    if ( !== self::$loader) {
        return self::$loader;
    }

    spl_autoload_register(array('ComposerAutoloaderInitff1d77c91141523097b07ee2acc23326', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    spl_autoload_unregister(array('ComposerAutoloaderInitff1d77c91141523097b07ee2acc23326', 'loadClassLoader'));

    $map = require __DIR__ . '/autoload_namespaces.php';
    foreach ($map as $namespace => $path) {
        $loader->set($namespace, $path);
    }

    $map = require __DIR__ . '/autoload_psr4.php';
    foreach ($map as $namespace => $path) {
        $loader->setPsr4($namespace, $path);
    }

    $classMap = require __DIR__ . '/autoload_classmap.php';
    if ($classMap) {
        $loader->addClassMap($classMap);
    }

    $loader->register(true);

    $includeFiles = require __DIR__ . '/autoload_files.php';
    foreach ($includeFiles as $file) {
        composerRequireff1d77c91141523097b07ee2acc23326($file);
    }

    return $loader;
}
```
可以明显看到，他将`autoload_namespaces.php`、`autoload_psr4.php`、`autoload_classmap.php`、`autoload_files.php`等几个配置文件包含了进来，并进行了相关处理（setPsr4），最后注册（register）。  
那么我们跟进register方法：

        public function register($prepend = false)
        {
            spl_autoload_register(array($this, 'loadClass'), true, $prepend);
        }

这函数就一行，但简单明了，直接调用php自带的`spl_autoload_register`函数，注册处理`__autoload`的方法，也就是loadClass方法。再跟进`loadClass`方法：

```php
public function loadClass($class)
{
    if ($file = $this->findFile($class)) {
        includeFile($file);

        return true;
    }
}
```

从函数名字就可以大概知道流程：如果存在`$class`对应的这个`$file`，则include进来。  
那么进findFile方法里看看吧：

```php
public function findFile($class)
{
    // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731
    if ('\\' == $class[0]) {
        $class = substr($class, 1);
    }

    // class map lookup
    if (isset($this->classMap[$class])) {
        return $this->classMap[$class];
    }
    if ($this->classMapAuthoritative) {
        return false;
    }

    $file = $this->findFileWithExtension($class, '.php');

    // Search for Hack files if we are running on HHVM
    if ($file ===  && defined('HHVM_VERSION')) {
        $file = $this->findFileWithExtension($class, '.hh');
    }

    if ($file === ) {
        // Remember that this class does not exist.
        return $this->classMap[$class] = false;
    }

    return $file;
}
```

通过类名找文件，最终锁定在`findFileWithExtension`方法中。  
不过发现了一个小宝藏：在php5.3.0~5.3.2版本下，类名的第一个字符是`\`的小bug，也许以后挖漏洞会用上。  
还是跟进findFileWithExtension方法：

```php
private function findFileWithExtension($class, $ext)
{
    // PSR-4 lookup
    $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

    $first = $class[0];
    if (isset($this->prefixLengthsPsr4[$first])) {
        foreach ($this->prefixLengthsPsr4[$first] as $prefix => $length) {
            if (0 === strpos($class, $prefix)) {
                foreach ($this->prefixDirsPsr4[$prefix] as $dir) {
                    if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
                        return $file;
                    }
                }
            }
        }
    }

    // PSR-4 fallback dirs
    foreach ($this->fallbackDirsPsr4 as $dir) {
        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
            return $file;
        }
    }

    // PSR-0 lookup
    if (false !== $pos = strrpos($class, '\\')) {
        // namespaced class name
        $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
            . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
    } else {
        // PEAR-like class name
        $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
    }

    if (isset($this->prefixesPsr0[$first])) {
        foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
            if (0 === strpos($class, $prefix)) {
                foreach ($dirs as $dir) {
                    if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                        return $file;
                    }
                }
            }
        }
    }

    // PSR-0 fallback dirs
    foreach ($this->fallbackDirsPsr0 as $dir) {
        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
            return $file;
        }
    }

    // PSR-0 include paths.
    if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
        return $file;
    }
}
```

最终实现将`命名空间\类`这样的类名，给转换成`目录名/类名.php`这样的路径，并返回完整路径。  
我发现composer的autoload与php自带的spl_autoload，在包含文件时有一点小区别。那就是，spl_autoload会查找`.inc`类型的文件名，但composer不会。  
另外也可以发现，虽然配置文件的名字是`autoload_psr4.php`，但实际上psr0格式的自动加载也是支持的。二者最大的不同就是psr0中用 `_` 来代替目录间的 `\` 。

[0]: https://www.toolmao.com/composer-autoload
[1]: https://www.toolmao.com/doc

[3]: http://drops.leavesongs.com/php/composer-autoload-class-and-function-written-myself.html
[4]: ../img/3439194190.png
[5]: http://www.php-fig.org/psr/psr-4/
[6]: ../img/713740618.png