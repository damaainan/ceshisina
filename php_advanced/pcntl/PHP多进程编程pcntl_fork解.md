# PHP多进程编程pcntl_fork解

 时间 2017-09-21 21:35:00  

原文[http://www.cnblogs.com/Summer7C/p/7571444.html][1]


其实PHP是支持并发的，只是平时很少使用而已。平时使用最多的应该是使用PHP-FMP调度php进程了吧。

但是，PHP的使用并不局限于做Web，我们完全也可以使用PHP来进行系统工具类的编程，做监控或者是运维。在使用这些方向的时候，我们可以使用到PHP的更多特性，例如并发（多进程）、socket编程等。

那么接下来就说说我遇到的PHP多进程的编程。这个多进程的使用是有一个背景的，下面模糊描述一下背景。

我需要一个监控系统，当然使用PHP语言，监控系统需要监控很多种系统指标，为了让每个监控指标之间尽量专心的去做自己的事情，就需要单独使用一个进程去监控一个指标，还有一个进程去读取配置，拿到配置之后，根据配置去启动每条进程。

那么，这就需要我所说的多进程了。

1. 首先启动一个主进程，主进程用来读取配置信息。例如，我读取到了我需要监控5个指标
1. 接下来主进程启动5个子进程，分别监控这5个指标。
1. 创建好5个指标监控进程之后之后，主进程进行监听配置。
1. 一旦配置发生改变，杀死之前的进程并重新创建进程。

相对来说比较清晰的逻辑。那么接下来我们就化简一下操作：简单的说就是一个主进程创建5个子进程。

首先，创建进程在需要使用php的一个函数pcntl_fork()，这个函数可能有的同学不太熟，不过接触过Linux C变成的人都知道Linux下有个叫fork()的函数，用来创建子进程。这个函数和Linux下这个函数是一个意思。需要注意的是，这个函数在Linux下才能使用，而且需要安装pcntl的扩展。

对于这个函数怎么使用，我们可以查阅官方文档：http://php.net/manual/zh/function.pcntl-fork.php

官方文档是这样说的:

pcntl_fork()函数创建一个子进程，这个子进程仅PID（进程号） 和PPID（父进程号）与其父进程不同。fork怎样在您的系统工作的详细信息请查阅您的系统 的fork（2）手册。

成功时，在父进程执行线程内返回产生的子进程的PID，在子进程执行线程内返回0。失败时，在 父进程上下文返回-1，不会创建子进程，并且会引发一个PHP错误。

这样就可以创建一个子进程了，子进程创建成功以后会执行pcntl_fork()之后的方法。那么对于这个函数的返回值我们如何理解呢？

是这样的，我们调用函数创建进程的时候，函数执行时有时间的，而新的进程刚好是在函数执行开始和结束之间创建出来的，这样，新的进程也执行了这个函数，所以函数也需要有返回值。那么对于该函数一次执行之后，父进程和子进程都会受到该函数的返回值，由于父进程创建了子进程，而子进程并没有创建新的进程，所以子进程对于这个函数的返回结果是没有的，所以就给他赋了一个0。而父进程创建了子进程，子进程是存在pid的，所以就得到了那个进程的pid。

我们可以写个程序了解一下：
```php
$pid = pcntl_fork();
var_dump($pid);
```

这个调用会输出两个值，但是我们如果直接print的只能看到一个值，也就是子进程的pid，但是使用var_dump我们就可以看到两个值，是0和子进程的pid。0这个值就是子进程返回过来的。

那么如何创建进程了解清楚之后，就可以开始创建进程了，我们需要创建5个进程，那么我就循环5次创建进程。得到如下代码：
```php
$i=0;
while($i!=5){
    $pid = pcntl_fork();
    echo $pid."---------hahah".$i++.PHP_EOL;
}
```

这样就写好了，那么运行一下吧。啊？发现不是5个进程啊，发现有好多个进程，而且最后一个hahah4这个输出有32个，为什么是32呢？我们算一算。2^5=32，为什么最后的线程数以指数增长了呢？

想发现这个并不难，因为我们之后的每一条都执行了while循环，到最后成了进程的指数增长——也就是说fork的时候把while循环也带了进去。但是我们只是要5个进程而已。怎么办呢？

通过之前对函数的研究可以看到，子进程中会返回一个为0的值，那么我们就可以知道，0为子进程的标记。我们可以通过对子进程标记来结束进程执行。所以我们可以将我们的代码修改为如下形式：
```php
$i=0;
while($i!=5){
    $pid = pcntl_fork();
    echo $pid."---------hahah".$i++.PHP_EOL;
    if ($pid == 0) {
        echo "子进程".PHP_EOL;
        return;
    }
}
```

因为0其实是对子进程的标记，那么pid这个变量在子进程里实际上是0的，所以当发现pid的值为0的时候，我们就可以断定我们当前进程为一个子进程，不需要在让他执行while并创建子进程的子进程了，所以在执行完我们的内容之后就return或者exit退出这个执行就好了。这样就能保证我们执行创建了5个进程而不是32个了。


[1]: http://www.cnblogs.com/Summer7C/p/7571444.html
