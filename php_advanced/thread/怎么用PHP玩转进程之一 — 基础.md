## 怎么用PHP玩转进程之一 — 基础

来源：[https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html](https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html)

时间 2018-08-29 15:08:11

 
可以说，我们工作中接触最多的就是 [进程][5] ，但是我们往往对它又比较陌生，是因为它是业务不需要关心的地方，既有的公有组件和操作系统已经对我们屏蔽了它的复杂性。然后跟它的接触时间一长，我们难免会对它产生好奇：How it work?
 
## 什么是进程 
 
进程是程序的实体  ，是系统进行资源分配和调度的基本单位  ，是操作系统结构的基础。每个进程都有自己唯一标识（PID），每个进程都有父进程，这些父进程也有父进程，所有进程都是`init`进程（PID 为 1）的子进程。
 
首先，我们来直观感受下它的存在，可以说是看不见又摸不着。

```
$ pstree -p
init(1)-+-init(3)---bash(4)
 |-nginx(771)-+-nginx(773)
 | |-nginx(774)
 | |-nginx(776)
 | `-nginx(777)
 |-php-fpm(702)-+-php-fpm(707)
 `-php-fpm(712)


```

 
## 进程分类 
 
### 前台进程 
 
前台进程具有控制终端，会堵塞控制终端。它的特点是：

 
* 可以同用户交互，但容易被意外终止； 
* 有较高的响应速度，优先级别稍高； 
 

```
$ php server.php start
PHPServer start [OK] 

# 堵塞了/_ \


```

 
通常，在控制终端使用`Ctrl+C`组合键，会导致前台进程终止退出。
 
### 守护进程 
 
守护进程是一种运行在后台的特殊进程，因为它不属于任何一个终端，所以不会收到任何终端发来的任何信号  。它与前台进程显著的区别是：

 
* 它没有控制终端，不能直接和用户交互，在后台运行； 
* 它不受用户登录和注销的影响，只受开机或关机的影响，可以长期运行； 
 
 
通常我们编写的程序，都需要在后台不终止的长期运行  ，此时就可以使用守护进程。当然，我们可以在代码中调用系统函数，或者直接在启动命令后追加`&`操作符，来实现一个守护进程。后者使用如下：

```
$ php server.php start &
# 进程脱离控制终端运行


```

 
通常`&`与 nohup 结合使用，忽略 SIGHUP 信号。该方式对业务代码侵入最小，方便且成本低，常用于临时执行任务脚本的场景。
 
## [进程间通信][6] （InterProcess Communication） 
 
进程的用户空间是相互独立的，一般而言是不能相互访问。但很多情况下，进程间需要互相通信来进行数据传输、共享数据、通知事件、进程控制等，这就必须通过内核实现进程间通信。
 
![][0]
 
进程间通信共有管道、消息队列、信号、共享内存、套接字等方式，本文只介绍后 3 种。
 
### [共享内存][7] （Shared Memory） 
 
共享内存是一段被映射到多个进程地址空间的内存，因此这段共享内存是由一个进程创建，但是多个进程都可以访问。如下图：
 
![][1]
 
共享内存是最快的进程间通信方式，但是可能会存在竞争，因此需要加锁。Linux 支持三种共享内存：mmap、Posix、以及 System V。
 
### [套接字][8] （Socket） 
 
套接字是一个通信链的句柄，可以用域、端口号、协议类型来表示一个套接字，其中域分为 Internet 网络（IP 地址）和 UNIX 文件（Sock 文件）两种。当域为 Internet 网络时，通信流程如下图：
 
![][2]
 
特别的是，当套接字域为 Internet 网络时，就可以实现跨主机的进程间通信  。因此，若要实现跨主机进程间通信，则选用套接字。
 
### [信号][9] （Signal） 
 
信号受事件驱动，是一种异步且最复杂的通信方式，用于通知接受进程有某个事件已经发生，因此常用于进行事件处理。信号的处理机制，如下图：
 
![][3]
 
#### 常用的信号值 
 
在 Linux 系统中，可使用`kill -l`命令查看 62 个信号值，其中部分常用值如下：
 
| 信号名称 | 值 | 说明 |
| - | - | - | 
| SIGHUP | 1 | 终端控制进程结束 | Terminate | 
| SIGINT | 2 | 键盘Ctrl+C被按下 | Terminate | 
| SIGQUIT | 3 | 键盘Ctrl+/被按下 | Dump | 
| SIGKILL | 9 | 无条件结束进程 | Terminate | 
| SIGUSR1 | 10 | 用户保留 | Terminate | 
| SIGUSR2 | 12 | 用户保留 | Terminate | 
| SIGALRM | 14 | 时钟定时信号 | Terminate | 
| SIGTERM | 15 | 程序结束 | Terminate | 
| SIGCHLD | 16 | 子进程结束 | Ignore | 
 
 
#### 产生信号的方式 
 
实际中，硬件或者软件中断都会触发信号，但是这里只列举两种常用的信号产生方式。

 
* 终端按键
 
| 按键/命令 | 信号名称 |
| - | - | 
| Ctrl+C | SIGINT | 
| Ctrl+\ | SIGQUIT | 
| EXIT | SIGHUP | 
 

 
* 系统调用 
 
 
通过`kill`系统调用发送信号。例如，在 Shell 中使用`kill -9`发送 SIGKILL 信号。对于`kill`调用，需要注意以下两种特殊情况：

 
* 特殊信号 
 
 
可以发送编号为`0`的信号来检测进程是否存活  。

```php
$pid = 577;
if (posix_kill($pid, 0)) {
 echo "进程存在\n";
} else {
 echo "进程不存在\n";
}


```

 
* 特殊 PID 
 
 
这里的参数`$pid`，根据取值范围不同，含义也不同。具体如下：

 
* $pid > 0：向 PID 为 $pid 的进程发送信号； 
* $pid = 0：向当前进程组所有进程发送信号，比较常用； 
* $pid = -1：向所有进程（除 PID 为 1）发送信号（权限）； 
 
 
### 进程的处理方式 
 
进程共有 3 种处理信号的方式：

 
* 默认行为； 
* 忽略； 
* 捕获并处理——先安装信号处理器，当捕获到信号时，执行对应的处理器； 
 
 
其中，默认行为进一步可以细分为几种：
 
| 默认处理类型 | 描述 |
| - | - | 
| Terminate | 进程被中止(杀死) | 
| Dump | 进程被中止(杀死)，并且输出 [dump][10] 文件 | 
| Ignore | 信号被忽略 | 
| Stop | 进程被停止 | 
 
 
信号的默认行为类型，见默认行为部分；
 
## 进程间关系 
 
首先，使用`ps -ajx`命令查看所有进程信息，如下：

```
#父PID  PID  组ID 会话ID 终端      时间   名称
PPID PID PGID SID TTY TIME COMMAND
 0 1 1 1 ? 0:00 /init ro
 1 43 43 43 ? 0:00 /usr/sbin/sshd
 43 11134 11134 11134 ? 0:00 sshd: root@pts/1
11134 11169 11169 11169 pts/1 0:00 -bash
11169 11251 11251 11169 pts/1 0:00 PHPServer: master 
11251 11252 11251 11169 pts/1 0:36 PHPServer: worker 
11251 11253 11251 11169 pts/1 0:42 PHPServer: worker


```

 
### 进程组（Process Group） 
 
进程组是一个或多个进程的集合。每个进程除了有一个 PID 之外还有一个进程组 ID（GID），每个进程都属于一个进程组，每个进程都有一个组长进程。
 
如上图中，1 个`PHPServer: master`主进程和 2 个`PHPServer: worker`子进程，属于同一个进程组`11251`，可以看出主进程是组长进程。
 
### 会话（Session） 
 
会话是一个或多个进程组的集合，一个会话有对应的控制终端。如上图中，4 个`PHPServer`进程和`-bash`进程同属于一个会话，因为他们在一个`pts/1`的控制终端。
 
需要说明的是  ，当用户退出（Logout）会话以后，系统默认对该会话下的进程进行如下操作：

 
* 系统向该会话发出 SIGHUP 信号； 
* 该会话将 SIGHUP 信号发给所有子进程； 
* 子进程收到 SIGHUP 信号后，自动退出； 
 
 
而对于后台进程，用户在退出时系统默认不会发送 SIGHUP 信号，这是由 Shell 的`huponexit`参数（默认`off`）控制。可通过`shopt -s huponexit`设置成`on`（当前会话有效），此时后台进程会收到 SIGHUP 信号。
 
## 进程模型 
 
从进程层面来说，程序可以分为单进程和多进程模型。

 
* 单进程 
 
 
单进程模型的程序，只有一个进程在运行。他是最基本的进程模型，实现起来比较简单，Redis 就是采用这种进程模型。

 
* 多进程 
 
 
![][4]
 
为了提高程序的并发处理能力，程序由单进程慢慢演变成了多进程，一 个 master 进程和多个 worker 进程是多进程常见的构成形态。可以说，现在大部分程序都是多进程模型，其中 Nginx 是典型的代表。
 
相关文章»

 
* [怎么用PHP玩转进程之二 — 多进程PHPServer][11]（2018-08-29）   
 


[5]: https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B
[6]: https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A
[7]: https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98
[8]: https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97
[9]: https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7
[10]: http://hutaow.com/blog/2013/10/25/linux-core-dump
[11]: https://www.fanhaobai.com/2018/08/process-php-multiprocess-server.html
[0]: ../img/fiiaMzu.jpg
[1]: ../img/36Nb22Z.jpg
[2]: ../img/FfEBj2q.jpg
[3]: ../img/ErmiEjb.jpg
[4]: ../img/NzAf6jI.png