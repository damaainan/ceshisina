## PHP浮点数的精度问题

来源：[https://fengyoulin.com/2018/03/31/php_floating_point_precision/](https://fengyoulin.com/2018/03/31/php_floating_point_precision/)

时间 2018-03-31 23:03:40


写这篇文章的主要目的，是为了弄清楚PHP官方手册上所举的`(int)((0.1+0.7)*10)`值为7的例子。想要讨论浮点数的精度问题，首先要看一下浮点数在计算机中的是如何存储的，或者说浮点数的编码方式。


### 一、IEEE754标准

二进制浮点数将最高位指定为符号位S，接下来的指数部份Exp是浮点数中经指数偏差处理过后的指数，剩下的小数部份Fraction，为有效位数减掉有效位数本身的最高效位。

32位单精度，1位符号，8位指数，23位尾数，指数偏正值+127：

```
+-+--------+-----------------------+
|S|   Exp  |        Fraction       |
+-+--------+-----------------------+
 1     8               23
```

64位双精度，1位符号，11位指数，52位尾数，指数偏正值+1023：

```
+-+--------+-----------------------+
|S|   Exp  |        Fraction       |
+-+--------+-----------------------+
 1    11               52
```

因为指数必须是有号数才能表达很大或很小的数值，但是有号数通常的表示法——补码，将会使比较变得困难。为了解决这个问题，指数在存储之前需要做偏差修正，将它的值调整到一个无符号数的范围内以便进行比较。指数采用这种方法表示的优点还在于使得浮点数的正规形式和非正规形式之间有了一个平滑的转变。

符号位S为0时表示正数，为1时表示负数；指数部分Exp为实际的指数经过偏差修正后所得到的值（加上偏正值）；尾数部分除了图中的Fraction部分外，还有一位隐含的最高位，其在规约浮点数中为1，在非规约浮点数中为0。图中Fraction部分最高位表示1/2，次高位表示1/4，依此类推。

如果浮点数中指数部分的编码值在0 < exponent < 2e-1之间，且尾数部分最高有效位（即整数位）是1，那么这个浮点数将被称为规约形式的浮点数。如果浮点数的指数部分的编码值是0，尾数为非零，那么这个浮点数将被称为非规约形式的浮点数。规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0。

如果指数是0并且小数部分是0，这个数是±0（和符号位相关）；如果指数=2e-1并且小数部分是0，这个数是±无穷大（同样和符号位相关）；如果指数=2e-1并且小数部分非0，这个数表示为不是一个数（NaN）。


#### 总结如下

| 形式 | 指数 | 小数部分 |
|-|-|-|
| 零 | 0 | 0 |
| 非正规形式 | 0 | 非0 |
| 正规形式 | 1到2e-2 | 任意 |
| 无穷 | 2e-1 | 0 |
| NaN | 2e-1 | 非零 |
  


### 二、PHP中的浮点数

使用安装了    [zendump][0]
扩展的PHP7.2.2 CLI运行如下脚本，`zendump_vars()`在打印浮点变量的时候，会同时打印出16进制原始数据：

```php
<?php
$a = 0.1; 
$b = 0.7; 
$c = 0.8;
$d = 0.1 + 0.7;

$e = 0.5;
$f = 0.25;
$g = 0.125;
$h = 0.0625;
$i = 0.03125;
$j = 0.015625;
$k = 0.0078125;
$l = 0.00390625;
$m = 0.001953125;
$n = 0.0009765625;

$o = 0.75;
$p = 1.75;
$q = 1.875;
$r = 1.9375;

$s = -0.5;
$t = -1.0;
$u = -1.5;

zendump_vars();
```

输出的结果如下：

``` 
vars(21): {
  $a ->
  zval(0x7f12b361e080) : double(0.1) hex(3fb999999999999a)
  $b ->
  zval(0x7f12b361e090) : double(0.7) hex(3fe6666666666666)
  $c ->
  zval(0x7f12b361e0a0) : double(0.8) hex(3fe999999999999a)
  $d ->
  zval(0x7f12b361e0b0) : double(0.8) hex(3fe9999999999999)
  $e ->
  zval(0x7f12b361e0c0) : double(0.5) hex(3fe0000000000000)
  $f ->
  zval(0x7f12b361e0d0) : double(0.25) hex(3fd0000000000000)
  $g ->
  zval(0x7f12b361e0e0) : double(0.125) hex(3fc0000000000000)
  $h ->
  zval(0x7f12b361e0f0) : double(0.0625) hex(3fb0000000000000)
  $i ->
  zval(0x7f12b361e100) : double(0.03125) hex(3fa0000000000000)
  $j ->
  zval(0x7f12b361e110) : double(0.015625) hex(3f90000000000000)
  $k ->
  zval(0x7f12b361e120) : double(0.0078125) hex(3f80000000000000)
  $l ->
  zval(0x7f12b361e130) : double(0.00390625) hex(3f70000000000000)
  $m ->
  zval(0x7f12b361e140) : double(0.001953125) hex(3f60000000000000)
  $n ->
  zval(0x7f12b361e150) : double(0.0009765625) hex(3f50000000000000)
  $o ->
  zval(0x7f12b361e160) : double(0.75) hex(3fe8000000000000)
  $p ->
  zval(0x7f12b361e170) : double(1.75) hex(3ffc000000000000)
  $q ->
  zval(0x7f12b361e180) : double(1.875) hex(3ffe000000000000)
  $r ->
  zval(0x7f12b361e190) : double(1.9375) hex(3fff000000000000)
  $s ->
  zval(0x7f12b361e1a0) : double(-0.5) hex(bfe0000000000000)
  $t ->
  zval(0x7f12b361e1b0) : double(-1) hex(bff0000000000000)
  $u ->
  zval(0x7f12b361e1c0) : double(-1.5) hex(bff8000000000000)
}
```

PHP中的浮点数实际上是double类型，也就是1位符号，11位指数，52位尾数。

首先我们看一下$e到$n：符号位均为0，指数取值1022~1013（减去偏正值后为-1~-10），尾数均为0。因为正规形式的浮点数尾数部分还有一个隐含的1，所以可以表示为1×2的-1次幂~1×2的-10次幂。

0.75表示为1.5×2的-1次幂；1.75表示为1.75×2的0次幂；1.875和1.9375同理。

负的浮点数符号位为1，其他位与正浮点数相同。

至于$a~$c，可以发现对于0.1、0.7和0.8，都是无法精确表示的。最后的尾数看起来就像小数无限循环，而且0.1和0.7的指数部分也不相同，相加时还需要进行换算，从而进一步造成精度损失。从$d可以看出，经0.1和0.7相加得到的结果，比字面量0.8尾数最低位相差1，也就是不足0.8，与10相乘的结果在转换为整型时会向下舍掉小数部分，所以才会得到7。



[0]: https://github.com/php7th/zendump