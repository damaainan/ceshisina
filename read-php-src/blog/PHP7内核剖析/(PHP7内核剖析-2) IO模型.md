## (PHP7内核剖析-2) I/O模型

来源：[https://segmentfault.com/a/1190000014156561](https://segmentfault.com/a/1190000014156561)

1.同步:我客户端（C端调用者）一个功能，该功能没有结束前，我死等结果。 
2.异步:我（c端调用者）调用一个功能，不知道该功能结果，该功能有结果后通知我，即回调通知
3.阻塞:就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有完全接受完数据或者没有得到结果之前，我不会返回。
4.非阻塞:就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，得出结果后通知调用者 **`五种I/O模型`** 

(1) 阻塞I/O (Blocking I/O)

![][0]

当用户进程进行系统调用时，内核就开始了I/O的第一个阶段，准备数据到缓冲区中，当数据都准备完成后，则将数据从内核缓冲区中拷贝到用户进程的内存中，这时用户进程才解除block的状态重新运行。

(2) 非阻塞I/O (Non-Blocking I/O)

![][1]

用户进程只有在第二个阶段被阻塞了，而第一个阶段没有阻塞，但是在第一个阶段中，用户进程不需要盲等，不停的去轮询内核，看数据是否准备好了，因此该模型是比较消耗CPU的。

(3) I/O复用（I/O Multiplexing)

![][2]

I/O执行的两个阶段都是用户进程都是阻塞的，但是两个阶段是独立的，在一次完整的I/O操作中，该用户进程是发起了两次系统调用。和阻塞I/O不同的是第一段可以等待多个描述符就绪

(4) 信号驱动的I/O (Signal Driven I/O)

![][3]

只有在I/O执行的第二阶段阻塞了用户进程，而在第一阶段是没有阻塞的。该模型在I/O执行的第一阶段，当数据准备完成之后，会主动的通知用户进程数据已经准备完成，即对用户进程做一个回调。该通知分为两种，一为水平触发，即如果用户进程不响应则会一直发送通知，二为边缘触发，即只通知一次。

(5) 异步I/O (Asynchrnous I/O)

![][4]

当用户进程发起系统调用后，立刻就可以开始去做其它的事情，然后直到I/O执行的两个阶段都完成之后，内核会给用户进程发送通知，告诉用户进程操作已经完成了。
 **`I/O多路复用技术`** 

select

(1).select()的机制中提供一fd_set的数据结构，每一个元素都能与一打开的文件句柄（不管是Socket句柄，还是其他 文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成， 当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读或可写。主要用于Socket通信当中。

(2).程序执行select后，如果没有数据输入，程序会一直等待(阻塞时)，直到有数据为止，也就是程序中无需循环和sleep。

(3).每次调用select，都需要把fd_set集合从用户态拷贝到内核态，这个开销在fd_set很多时会很大

(4).同时每次调用select都需要在内核遍历传递进来的所有fd_set，这个开销在fd_set很多时也很大

(5).select支持的文件描述符数量太小了，默认是1024

poll

(1).poll的实现和select非常相似，只是描述fd_set集合的方式不同，poll使用pollfd链表结构而不是select的fd_set结构，其他的都差不多。

(2).监视描述符个数无上限；

epoll/kqueue

(1).监视描述符个数无上限；
(2).效率提升，不是轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；即epoll/kqueue最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll/kqueue的效率就会远远高于select和poll。
(3).内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；

[0]: ./img/bV7x7f.png
[1]: ./img/bV7x9J.png
[2]: ./img/bV7yjg.png
[3]: ./img/bV7ykM.png
[4]: ./img/bV7yla.png