## Yaf环境配置

文档地址：http://www.laruence.com/manual/ 或 http://www.php.net/manual/zh/book.yaf.php  
下载地址：https://github.com/laruence/php-yaf 或 http://pecl.php.net/package/Yaf/  
你可以选择在安装PHP环境的时候直接添加yaf支持，也可以安装完后扩展安装

    cd yaf-src/
    phpize
    ./configure
    make
    sudo make install

也可以pecl安装

    pecl install yaf

这样就OK了...
> Apache 下不用配置

> nginx 需要配置下伪静态，不然会404错误  
其它的环境配置方法请参考官方教程

    if (!-e $request_filename) {
        rewrite ^/(.*)  /index.php/$1 last;
      }

实际环境配置

    server {
            listen       80;
            server_name  www.b.com;
            access_log  off;
            root           /var/www/www.b.com;
            index          index.html index.htm index.php;
            location / {
                try_files $uri    $uri/    /index.php$is_args$args;
            }
            location ~ \.php$ {
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi.conf;
            }
        }

Yaf全局配置选项 ext-yaf.ini中

![](https://www.lvtao.net/usr/uploads/2016/12/3169210387.png)




----



## Yaf之bootstrap

第一步：要使用它，则要修改入口文件

    <?php
    define("APPLICATION_PATH",  dirname(__FILE__));
    $app  = new Yaf_Application(APPLICATION_PATH . "/conf/application.ini");
    //$app->run();
    $app->bootstrap()->run();

第二步：在application目录下的Bootstrap.php文件如下

    <?php
    class Bootstrap extends Yaf_Bootstrap_Abstract {
    
    }



Yaf的框架流程图

![yaf_sequence.png](https://www.lvtao.net/usr/uploads/2016/12/3449020210.png)

  

这个文件里面我们做很多事
比如，加载个配置文件、自定义一些路径、初始化session等等  

这儿的写法要注意了

* 必须在文件中定义一个Bootstrap类, 而这个类也必须继承自Yaf_Bootstrap_Abstract.
* 所有在Bootstrap类中, 以_init开头的方法, 都会被Yaf调用,
* 这些方法, 都接受一个参数:Yaf_Dispatcher $dispatcher
* 调用的次序, 和申明的次序相同

举个粟子：

    <?php
    class Bootstrap extends Yaf_Bootstrap_Abstract {
        /*添加配置*/
        public function _initConfig() {
            $config = Yaf_Application::app()->getConfig();
            Yaf_Registry::set("config", $config);
        }
        public function _initDefaultName(Yaf_Dispatcher $dispatcher) {
            $dispatcher->setDefaultModule("Index")->setDefaultController("Index")->setDefaultAction("index");
        }
        /*自定义路由*/
        public function _initRoute(Yaf_Dispatcher $dispatcher) {
            
        }
        /*自定义模板引擎*/
        public function _initView(Yaf_Dispatcher $dispatcher) {
            
        }
        /*session*/
        public function _initSession() {
            session_id()  || session_start();
        }
        /*插件*/
        public function _initPlugin(Yaf_Dispatcher $dispatcher) {
            
        }
    }

总结：Bootstrap, 也叫做引导程序. 它是Yaf提供的一个全局配置的入口, 在Bootstrap中, 你可以做很多全局自定义的工作.


---

## Yaf之application.ini配置


遵循php.ini配置方法  
定义配置块

    [lvtao]
    application.directory = APPLICATION_PATH "/application"
    
    [memcache]
    memcache.host=127.0.0.1
    memcache.port=12211

使用这个块 这个product在全局配置中有写的
默认值

    [product : lvtao]

但上面的示例中还有一个memcache的参数没有调用到，如下使用

    [product : lvtao : memcache]

也可以自定义配置块中的相关参数，举个粟子

    application.lvtao = "i love you"
    hello = "lvtao"

在Yaf中调用方法

    $config = Yaf_Application::app()->getConfig();
    echo $config->application->lvtao;
    echo $config->hello;

注意：  
application.directory 为必须要有的配置项  
以下为可选配置项

![]（https://www.lvtao.net/usr/uploads/2016/12/916602565.png）


----

## Yaf类库的加载

分全局类库与本地类库,它会优先加载本地类库  
全局类库在php.ini或ext-yaf.ini中的yaf.library来指定  
本地类库为application/library中，配置见application.ini中的application.library来指定，当然是有默认值的啦

我在使用的时候貌似全局类会自动加载进来，但本地类需要手工指定规则，我的做法是在bootstrap中做加载

    Yaf_Loader::getInstance()->registerLocalNamespace("Tool","Foo");  所有Tool开头的及Foo开头的类自动加载

也可以在application.ini中指定(多个就用,号分隔啦)

    application.labrary.namepspac = "Tool"

也可以用loader加载

    Yaf_Loader::import("类的绝对路径");
    或者
    Yaf_Loader::import("Tool/Http.php");

例如：我在library下建了一个目录Tool,里面有个Http.php类，内容如下：

    <?php
    class Tool_Http {
        public static function getName(){
            return "MemorySite:lvtao.net";
        }
    }

在Controller中使用

    echo Tool_Http::getName();

这样就成功调用这个类方法啦...

注意：在php.ini或ext-yaf.ini中有一个参数yaf.lowcase_path,它会影响路径加载的大小写。  
例：Tool_Http::getName() 它会寻找路径 library/tool/Http.php 注意到了没有，是tool,不是Tool了~

----

## Yaf之请求与响应


### Yaf_Request_Abstract

Yaf_Request_Http  
Yaf_Request_Simple  
Yaf_Request_Abstract::getException 捕获异常  
Yaf_Request_Abstract::getModuleName 获取模型名称  
Yaf_Request_Abstract::getControllerName 获取控制器名称  
Yaf_Request_Abstract::getActionName 获取方法名  
Yaf_Request_Abstract::getParams 获取所有路由参数  
Yaf_Request_Abstract::getParam 获取指定的路径参数 例：$this->getRequest()->getParam("userid", 0) 这儿的0为没有值的时候的默认值  
Yaf_Request_Abstract::setParam 为当前的请求,设置路由参数.  
Yaf_Request_Abstract::getMethod 获取当前请求的类型, 可能的返回值为GET,POST,HEAD,PUT,CLI等.  
Yaf_Request_Abstract::isCli 请求是否为CLI请求  
Yaf_Request_Abstract::isGet 当前请求是否为GET请求

### Yaf_Response_Abstract

Yaf_Response_Http  
Yaf_Response_Cli  
Yaf_Response_Abstract::setBody 设置响应的Body  
Yaf_Response_Abstract::appendBody 往已有的响应body后附加新的内容  
Yaf_Response_Abstract::prependBody 往已有的响应body前插入新的内容  
Yaf_Response_Abstract::getBody 获取已经设置的响应body  
Yaf_Response_Abstract::clearBody 清除已经设置的响应body  
Yaf_Response_Abstract::response 发送响应给请求端  
Yaf_Response_Abstract::setRedirect 重定向请求到新的路径  
Yaf_Response_Abstract::__toString

----

## Yaf之模型


Yaf的模型你可以理解为操作数据库或对数据做操作一个类~~~  
在控制器中，调用数据，我们先将它实例化一个模型

    $db=new UserModel();
    echo $db->getUserInfo(11111);

当我们在控制器中实例化一个不存在的模型类的时候，yaf就会在application的models下寻找这个模型类  
**模型类文件名不需要带Model后缀**，类文件如下

    class UserModel {
        public function getUserInfo($id){
           return "hi.db".$id;
        }
    }

yaf并没有提供数据库的操作方法，所以我们需要自己折腾啦~~~  
可以写一个类，自动加载，然后继续啦，后期我们以实例项目来折腾关于数据库、缓存操作和封装。

---

## 命令行模式运行yaf框架应用之cli模式


为了更好的与web区分(配置文件,argc、argv判断等等).重新创建一个入口文件是比较好的做法。

    $app = new YafApplication(APP_PATH . "/conf/application.ini");
    $app->getDispatcher()->dispatch(new YafRequestSimple());

这样入口文件就完成了。接下来，你需要学会yaf命令行的调用方法。来一个示例：

    php cli.php request_uri="/daemon/start"

Yaf_Request_Simple的构造函数可以不接受任何参数, 在这种情况下, Yaf_Request_Simple会在命令行参数中, 寻找一个字符串参数, 如果找到, 则会把请求的request_uri置为这个字符串。  
request_uri=”/daemon/start” 中的路径便是Controller的路由路径。在例子里指向/Controller/Daemon.php 中的 startAction()。

还有一种方法，通过Yaf_Application::execute(..)去实现。先看一下这个函数的定义：

    public void Yaf_Application::execute ( callable $entry , string $... )
    This method is typically used to run Yaf_Application in a crontab work. Make the crontab work can also use the autoloader and Bootstrap mechanism.

第一参数需要定义一个回调函数,也可以是一个类中的某个函数。示例：

    $application->execute("main", $argc, $argv);
    或
    $application->execute(array("Class","Method"), $argc, $argv);

后面的参数为一个可变列表，值为你希望传入的参数。综上所述，我们的另外一种入口文件可以写成：

    $app = new YafApplication(APP_PATH . "/conf/application.ini");
    $app->execute('callback', $avg1, $avg2 , ...);

如果需要通过bootstrap去初始化。只需要和web一样改为：

    $app->bootstrap()->execute('callback', $avg1, $avg2 , ...);

最优美的解决办法

    // parse cli
    if ($request->isCli ()) {
        global $argc, $argv;
        if ($argc > 1) {
            $module = '';
            $uri = $argv [1];
            if (preg_match ( '/^[^?]*%/i', $uri )) {
                list ( $module, $uri ) = explode ( '%', $uri, 2 );
            }
            $module = strtolower ( $module );
            $modules = Yaf_Application::app ()->getModules ();
            if (in_array ( ucfirst ( $module ), $modules )) {
                $request->setModuleName ( $module );
            }
            if (false === strpos ( $uri, '?' )) {
                $args = array ();
            } else {
                list ( $uri, $args ) = explode ( '?', $uri, 2 );
                parse_str ( $args, $args );
            }
            foreach ( $args as $k => $v ) {
                $request->setParam ( $k, $v );
            }
            $request->setRequestUri ( $uri );
            if ($request->isRouted () && ! empty ( $uri )) {
                if (false !== strpos ( $uri, '/' )) {
                    list ( $controller, $action ) = explode ( '/', $uri );
                    $request->setActionName ( $action );
                } else {
                    $controller = $uri;
                }
                $request->setControllerName ( ucfirst ( strtolower ( $controller ) ) );
            }
        }
    }

如果在插件中实现，routerStartup只需要$request->setRequestUri ( $uri )，如果是dispatchLoopStartup需要单独setControllerName和setActionName。



----


## yaf框架之Nginx配置


    server {
        listen  www.lvtao.net;
        root    /home/wwwroot/;
    
        location / {
            index  index.php index.html index.htm;
            try_files $uri $uri/ /index.php?$query_string;
        }
        location ~ .php$ {
            fastcgi_split_path_info ^(.+.php)(/.+)$;
            fastcgi_pass unix:/var/run/php5-fpm.sock;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_index index.php;
            include fastcgi_params;
        }
        location /api { 
            try_files $uri $uri/ /api.php?$query_string; 
        }
        location /admin {
            try_files $uri $uri/ /admin.php?$query_string; 
        }
        location /upload {
            deny all;
            return 404;
        }
        location ~* \.html$ {
            expires -1;
        }
        location ~* \.(css|js|gif|jpe?g|png)$ {
            expires 1M;
            add_header Pragma public;
            add_header Cache-Control "public, must-revalidate, proxy-revalidate";
        }
    }

gzip配置

    gzip on;
    gzip_http_version 1.1;
    gzip_vary on;
    gzip_comp_level 6;
    gzip_proxied any;
    gzip_types application/atom+xml
               application/javascript
               application/json
               application/vnd.ms-fontobject
               application/x-font-ttf
               application/x-web-app-manifest+json
               application/xhtml+xml
               application/xml
               font/opentype
               image/svg+xml
               image/x-icon
               text/css
               text/plain
               text/xml;
    gzip_buffers 16 8k;
    gzip_disable "MSIE [1-6]\.(?!.*SV1)";

