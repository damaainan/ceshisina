## 百万并发下的Nginx优化，看这一篇就够了！

来源：[http://developer.51cto.com/art/201811/586741.htm](http://developer.51cto.com/art/201811/586741.htm)

时间 2018-11-12 08:07:04

 
本文作者主要分享在 Nginx 性能方面的实践经验，希望能给大家带来一些系统化思考，帮助大家更有效地去做 Nginx。
 
![][0]
 
#### 优化方法论
 
![][1]
 
我重点分享如下两个问题：

 
* 保持并发连接数，怎么样做到内存有效使用。 
* 在高并发的同时保持高吞吐量的重要要点。 
 
 
![][2]
 
实现层面主要是三方面优化，主要聚焦在应用、框架、内核。
 
硬件限制可能有的同学也都听过，把网卡调到万兆、10G 或者 40G 是最好的，磁盘会根据成本的预算和应用场景来选择固态硬盘或者机械式硬盘，关注 IOPS 或者 BPS。
 
![][3]
 
CPU 是我们重点看的一个指标。实际上它是把操作系统的切换代价换到了进程内部，所以它从一个连接器到另外一个连接器的切换成本非常低，它性能很好，协程 Openresty 其实是一样的。
 
资源的高效使用，降低内存是对我们增大并发性有帮助的，减少 RTT、提升容量。
 
Reuseport 都是围绕着提升 CPU 的机核性。还有 Fast Socket，因为我之前在阿里云的时候还做过阿里云的网络，所以它能够带来很大的性能提升，但是问题也很明显，就是把内核本身的那套东西绕过去了。
 
![][4]
 
#### 请求的“一生”
 
下面我首先会去聊一下怎么看“请求”，了解完这个以后再去看怎么优化就会很清楚了。
 
![][5]
 
说这个之前必须再说一下 Nginx 的模块结构，像 Nginx 以外，任何一个外部框架都有个特点，如果想形成整个生态必须允许第三方的代码接进来，构成一个序列，让一个请求挨个被模块共同处理。
 
那 Nginx 也一样，这些模块会串成一个序列，一个请求会被挨个的处理。在核心模块里有两个，分别是 Steam 和 NGX。
 
#### 请求到来
 
![][6]
 
一个连接开始刚刚建立请求到来的时候会发生什么事情？先是操作系统内核中有一个队列，等着我们的进程去系统调用，这时候因为有很多工作进程，谁会去调用呢，这有个负载均衡策略。
 
现在有一个事件模块，调用了 Epoll Wait 这样的接口，Accept 建立好一个新连接，这时会分配到连接内存池，这个内存池不同于所有的内存池，它在连接刚创建的时候会分配，什么时候会释放呢？
 
只有这个连接关闭的时候才会去释放。接下来就到了 NGX 模块，这时候会加一个 60 秒的定时器。
 
就是在建立好连接以后 60 秒之内没有接到客户端发来的请求就自动关闭，如果 60 秒过来之后会去分配内存，读缓冲区。什么意思呢？
 
现在操作系统内核已经收到这个请求了，但是我的应用程序处理不了，因为没有给它读到用户态的内存里去，所以这时候要分配内存。
 
从连接内存池这里分配，那要分配多大呢？会扩到 1K。
 
#### 收到请求
 
![][7]
 
当收到请求以后，接收 Url 和 Header，分配请求内存池，这时候 Request Pool Size 是 4K，大家发现是不是和刚才的有一个 8 倍的差距，这是因为利用态的内存是非常消耗资源的。
 
再看为什么会消耗资源，首先会用状态机解去形容，所谓状态机解就是把它当做一个序列，一个支节一个支节往下解，如果发现换行了那就是请求行解完了。
 
但如果这个请求特别长的时候，就会去再分配更大的，刚刚 1K 不够用了，为什么是 4 乘 8K 呢？
 
就是因为当 1K 不够了不会一次性分配 32K，而是一次性分配 8K。如果 8K 以后还没有解析到刚才的标识符，就会分配第二个 8K。
 
我之前收到的所有东西都不会释放，只是放一个指针，指到 Url 或者指到那个协议，标识它有多长就可以了。
 
接下来解决 Header，这个流程一模一样的没有什么区别，这时候还会有一个不够用的情况，当我接收完所有的 Header 以后，会把刚刚的定时器给移除，移除后接下来做 11 个阶段的处理。
 
也就是说刚刚所有的外部服务器都是通过很多的模块串成在一起处理一个请求的。
 
像刚刚两页 PPT 都在说蓝色的区域，那么请求接下来 11 个阶段是什么意思呢？这个黄色的、绿色的，还有右边这个都是在 11 阶段之中。
 
这 11 个阶段大家也不用记，非常简单，只要掌握三个关键词就可以。
 
刚刚读完 Header 要做处理，所以这时候第一阶段是 Post-Read。接下来会有 Rewrite，还有 Access 和 Preaccess。
 
![][8]
 
先看左手边，当我们下载完 Nginx 源码编以后会有一个 Referer，所有的第三方数据都会在这里呈现有序排列。
 
这些序列中并不是简单的一个请求给它再给它，先是分为 11 个阶段，每个阶段之内大家是有序一个个往后来的，但在 11 个阶段中是按阶段来的。
 
我把它分解一下，第一个 Referer 这阶段有很多模块，后面这是有序的。
 
![][9]
 
这个图比刚刚的图多了两个关键点：

 
* 第一到了某一个模块可以决定继续向这序列后的模块执行，也可以说直接跳到下个阶段，但不能说跳多个阶段。 
* 第二是生成了向客户端反映的响应，这时候要对响应做些处理，这里是有序的，先做缩略图再做压缩，所以它是有严格顺序的。 
 
 
![][10]
 
#### 请求的反向代理
 
![][11]
 
请求的反向代理，反向代理这块是我们 Nginx 的重点应用场景，因为 Nginx 会考虑一种场景，客户端走的是公网，所以网络环境非常差，网速非常慢。
 
如果简单用一个缓冲区从客户端收一点发给上游服务器，那上游服务器的压力会很大，因为上游服务器往往它的效率高，所以都是一个请求被处理完之前不会再处理下一个请求。
 
Nginx 考虑到这个场景，它会先把整个请求全部收完以后，再向上游服务器建立连接，所以是默认第一个配置，就是 Proxy Request Buffering On，存放包体至文件，默认 Size 是 8K。
 
那建立上游连接的时候会放 Time Out，60 秒，添加超时定时器，也是 60 秒的。
 
发出请求（读取文体包件），如果向上游传一个很大的包体的话，那 Sizk 就是 8K。
 
默认 Proxy Limit Rate 是打开的，我们会先把这个请求全部缓存到端来，所以这时候有个 8×8K，如果关掉的话，也就是从上游发一点就往下游发一点。
 
知道这个流程以后，再说这里的话大家可以感觉到这里的内存消耗还是蛮大的。
 
#### 返回响应
 
![][12]
 
返回响应，这里面其实内容蛮多的，我给大家简化一下，还是刚刚官方的那个包，这也是有顺序的从下往上看，如果有大量第三方模块进来的话，数量会非常高。
 
第一个关键点是上面的 Header Filter，上面是 Write Filter，下面是 Postpone Filter，这里还有一个 Copy Filter，它又分为两类，一类是需要处理，一类是不需要处理的。
 
![][13]
 
OpenResty 的指令，第一代码是在哪里执行的，第二个是 SDK。
 
#### 应用层优化
 
#### 协议
 
![][14]
 
做应用层的优化我们会先看协议层有没有什么优化，比如说编码方式、Header 每次都去传用 Nginx 的架构，以至于浪费了很多的流量。我们可以改善 Http2，有很多这样的协议会大幅度提升它的性能。
 
当然如果你改善 Http2 了，会带来其他的问题，比如说 Http2 必须走这条路线。
 
这条路线又是一个很大的话题，它涉及到安全性和性能，是互相冲突的东西。
 
#### 压缩
 
我们希望“商”越大越好，压缩这里会有一个重点提出来的动态和静态，比如说我们用了拷贝，比如说可以从磁盘中直接由内核来发网卡，但一旦做压缩的话就不得不先把这个文件读到 Nginx，交给后面的极内核去做一下处理。
 
Keepalive 长连接也是一样的，它也涉及到很多东西，简单来看这也就是附用连接。
 
因为连接有一个慢启动的过程，一开始它的窗口是比较小，一次可能只传送很小的 1K 的，但后面可能会传送几十K，所以你每次新建连接它都会重新开始，这是很慢的。
 
当然这里还涉及到一个问题，因为 Nginx 内核它默认打开了一个连接空闲的时候，长连接产生的作用也会下降。
 
#### 提高内存使用率
 
![][15]
 
刚刚在说具体的请求处理过程中已经比较详细的把这问题说清楚了，这里再总结一下，在我看来有一个角度，Nginx 对下游只是必须要有的这些模块，Client Header、Buffer Size：1K，上游网络 Http 包头和包体。
 
![][16]
 
CPU 通过缓存去取储存上东西的时候，它是一批一批取的，每一批目前是 64 字节，所以默认的是 8K。
 
如果你配了 32 它会给你上升到 64；如果你配了 65 会升到 128，因为它是一个一个序列化重组的。
 
所以了解这个东西以后自己再配的时候就不会再犯问题。红黑树这里用的非常多，因为是和具体的模块相关。
 
#### 限速
 
![][17]
 
大部分我们在做分公司流控的时候，主要在限什么呢？主要限 Nginx 向客户端发送响应的速度。
 
这东西非常好用，因为可以和 Nginx 定量连接在一起。这不是限上游发请求的速度，而是在限从上游接响应的速度。
 
#### Worker 间负载均衡
 
![][18]
 
当时我在用 0.6 版本的时候那时候都在默认用这个，这个“锁”它是在用进程间同步方式去实现负载均衡，这个负载均衡怎么实现呢？
 
就是保证所有的 Worker 进程，同一时刻只有一个 Worker 进程在处理距离，这里就会有好几个问题，绿色的框代表它的吞吐量，吞吐量不高，所以会导致第二个问题 Requests，也是比较长的，这个方差就非常的大。
 
如果把这个“锁”关掉以后，可以看到吞吐量是上升的，方差也在下降，但是它的时间在上升，为什么会出现这样的情况？
 
因为会导致一个 Worker 可能会非常忙，它的连接数已经非常高了，但是还有其他的 Worker 进程是很闲的。
 
如果用了 Requests，它会在内核层面上做负载均衡。这是一个专用场景，如果在复杂应用场景下开 Requests 和不开是能看到明显变化的。
 
#### 超时
 
![][19]
 
这里我刚刚说了好多，它是一个红黑树在实现的。唯一要说的也就是这里，Nginx 现在做四层的反向代理也很成熟了。
 
像 UTP 协议是可以做反向代理的，但要把有问题的连接迅速踢掉的话，要遵循这个原则，一个请求对一个响应。
 
#### 缓存
 
![][20]
 
只要想提升性能必须要在缓存上下工夫。比如说我以前在阿里云做云盘，云盘缓存的时候就会有个概念叫空间维度缓存，在读一块内容的时候可能会把这内容周边的其他内容也读到缓存中。
 
大家如果熟悉优化的话也会知道有分支预测先把代码读到那空间中，这个用的比较少，基于时间维度用的比较多了。
 
#### 减少磁盘 IO
 
![][21]
 
其实要做的事也非常多，优化读取，Sendfile 零拷贝、内存盘、SSD 盘。减少写入，AIO，磁盘是远大于内存的，当它把你内存消化完的时候还会退化成一个调用。
 
像 Thread Pool 只用读文件，当退化成这种模式变多线程可以防止它的主进程被阻塞住，这时候官方的博客上说是有 9 倍的性能提升。
 
#### 系统优化
 
#### 提升容量配置
 
![][22]
 
我们建连接的时候也有，还有些向客户端发起连接的时候会有一个端口范围，还有一些像对于网卡设备的。
 
#### CPU缓存的亲和性
 
CPU缓存的亲和性，这看情况了，现在用 L3 缓存差不多也 20 兆的规模，CPU 缓存的亲和性是一个非常大的话题，这里就不再展开了。
 
#### NUMA 架构的 CPU 亲和性
 
![][23]
 
把内存分成两部分，一部分是靠近这个核，一部分靠近那个核，如果访问本核的话就会很快，靠近另一边大概会耗费三倍的损耗。对于多核 CPU 的使用对性能提升很大的话就不要在意这个事情。
 
#### 网络快速容错
 
![][24]
 
因为 TCP 的连接最麻烦的是在建立连接和关闭连接，这里有很多参数都是在调，每个地方重发，多长时间重发，重发多少次。
 
这里给大家展示的是快启动，有好几个概念在里面，第一个概念在快速启动的时候是以两倍的速度。
 
因为网的带宽是有限的，当你超出网络带宽的时候其中的网络设备是会被丢包的，也就是控制量在往下降，那再恢复就会比较慢。
 
#### TCP 协议优化
 
![][25]
 
TCP 协议优化，本来可能差不多要四个来回才能达到每次的传输在网络中有几十 K，那么提前配好的话用增大初始窗口让它一开始就达到最大流量。
 
#### 提高资源效率
 
![][26]
 
提高资源效率，这一页东西就挺多了，比如说先从 CPU 看，TCP Defer Accept，如果有这个的话，实际上会牺牲一些即时性，但带来的好处是第一次建立好连接没有内容过来的时候是不会激活 Nginx 做切换的。
 
内存在说的时候是系统态的内存，在内存大和小的时候操作系统做了一次优化，在压力模式和非压力模式下为每一个连接分配的系统内存可以动态调整。
 
网络设备的核心只解决一个问题，变单个处理为批量处理，批量处理后吞吐量一定是会上升的。
 
因为消耗的资源变少了，切换次数变少了，它们的逻辑是一样的，就这些逻辑和我一直在说的逻辑都是同一个逻辑，只是应用在不同层面会产生不同的效果。
 
端口复用，像 Reals 是很好用的，因为它可以把端口用在上游服务连接的层面上，没有带来隐患。
 
#### 提升多 CPU 使用效率
 
![][27]
 
提升多 CPU 使用效率，上面很多东西都说到了，重点就两个，一是 CPU 绑定，绑定以后缓存更有效。多队列网卡，从硬件层面上已经能够做到了。
 
![][28]
 
BDP，带宽肯定是知道的，带宽和时延就决定了带宽时延积，那吞吐量等于窗口或者时延。
 
![][29]
 
内存分配速度也是我们关注的重点，当并发量很大的时候内存的分配是比较糟糕的，大家可以看到有很多它的竞品。
 
![][30]
 
PCRE 的优化，这用最新的版本就好。
 
作者：陶辉
 
介绍：曾在华为、腾讯公司做底层数据相关的工作，写过一本书叫《深入理解 Nginx：模块开发与架构解析》，目前在杭州智链达作为联合创始人担任技术总监一职，目前专注于使用互联网技术助力建筑行业实现转型升级。
 


[0]: ../img/V3E3iuF.jpg 
[1]: ../img/ZnMVfyQ.jpg 
[2]: ../img/muqi6rm.jpg 
[3]: ../img/JzuuEvz.jpg 
[4]: ../img/YZZZJnI.jpg 
[5]: ../img/3yEzaqr.jpg 
[6]: ../img/7BJZjyA.jpg 
[7]: ../img/meiEzaZ.jpg 
[8]: ../img/VzmmUvb.jpg 
[9]: ../img/rqeAFr6.jpg 
[10]: ../img/7BBn6ba.jpg 
[11]: ../img/aAjMZjB.jpg 
[12]: ../img/nYZNvmF.jpg 
[13]: ../img/Rzme2eM.jpg 
[14]: ../img/amEJNzF.jpg 
[15]: ../img/aQrAfy2.jpg 
[16]: ../img/uqyqAbb.jpg 
[17]: ../img/r2u2eyA.jpg 
[18]: ../img/raaI7zY.jpg 
[19]: ../img/VNvie2M.jpg 
[20]: ../img/AJJrAnY.jpg 
[21]: ../img/bI7zAzv.jpg 
[22]: ../img/zENfEne.jpg 
[23]: ../img/3ayaIba.jpg 
[24]: ../img/qaMjqaq.jpg 
[25]: ../img/miE7zu3.jpg 
[26]: ../img/Fruayab.jpg 
[27]: ../img/FjYNZjb.jpg 
[28]: ../img/riEbEbj.jpg 
[29]: ../img/fAZjAfQ.jpg 
[30]: ../img/byUJVfU.jpg 
