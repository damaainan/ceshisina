## Vim按键映射高级技巧

来源：[https://zhuanlan.zhihu.com/p/38150203](https://zhuanlan.zhihu.com/p/38150203)

时间 2018-06-16 13:51:09


Vim的按键映射方法繁多，涉及的东西也比较多，很难全面介绍。本文尽量从简至深的解释Vim的按键映射方法，后面的内容可能需要一定的Vim脚本基础才能看懂。

从Vim的处理模型上来看，按键映射并不复杂。用户通过按键输入，产生一个按键队列，经过Vim对映射的处理后，产生一个字符队列，Vim会不断从这个字符队列里取出字符并处理，处理之后的结果再通过界面显示出来。

这里面我提出了两个概念：       **按键字符队列** 
和       **字符队列** 
，两者都是由字符组成的队列，便于表达我将前者称为按键队列

  

* 按键队列：用户输入的字符队列
* 字符队列：Vim最终要处理的字符队列        

Vim在某个模式下，对字符队列中的每个字符都有固定的处理规则，比如在Normal模式下，`<c-f>`表示向下翻页(         **尖括号的内容可以看成一个字符** 
，下同)，`j`表示下移一行。      
    

按键映射会让用户的按键队列和Vim最终要处理的字符队列产生不同。比如用户的按键队列是`<c-j>jjkk`，没有任何映射的情况下，Vim最终处理的字符队列也是这个`<c-j>jjkk`。假如在Vim的配置文件里定义了`nnoremap <c-j> <c-f>`，那么前面用户按键队列将会产生`<c-f>jjkk`这样的字符队列

  
##  **Vim常用模式简介** 
    

``` 
:
```

  
##  **map系列命令** 
    

Map系列命令，常见的语法如下

``` 
[nore]map [<args>] {lhs} {rhs}
```

  

* 第一个单词是具体的映射命令，表示在哪个         **模式** 
下定义按键映射        

常用的有`nmap`(Normal模式)、`imap`(Insert模式)、`vmap`(Visual+Select模式)、`map`(Normal+Visual模式)、`map!`(Insert+Command模式)        

详细的映射命令以及和模式的对应关系可以在Vim用`:h map-modes`查阅      
* {lhs}(left-hand-side) 表示         **映射前** 
的按键序列，对应上文提到的         **按键队列** 
      
* {rhs}(right-hand-side) 表示         **映射后** 
的按键序列，但这里并不一定对应上面的         **字符队列** 
      
* map前面加了`nore`表示         **非递归映射** 
，递归映射是指rhs会当做lhs再解释一次，非递归映射则不会，即         **rhs会被放入到Vim最终要处理的字符队列里去** 
        

比如先后定义了`nnoremap x iaa`,`nmap <F2> x`，那么按F2键相当于执行了按iaa键的功能，如果第二个命令用的是`nnoremap <F2> x`，那么按下F2键相当于执行了按下x键的功能      
* `<args>`表示map命令的一些参数，其中常用的有      
    

* `<buffer>`表示这个映射只是在当前的buffer中定义，而不是定义全局的映射        
* `<expr>`表示{rhs}是一个`Vim表达式`，而不是按键序列，见下文        
* `<silent>`表示静默映射，不会显示Vim在处理rhs过程中对界面产生的变化。          

比如在Normal模式下定义了`nmap <c-s> :write<cr>`，按下`<c-s>`后可以看到界面底部显示有`write`的字样，但如果在`<c-s>`前面加了`<silent>`，则不会显示        
      

    

  
##  **map命令强大的expr参数** 
    

在map命令里，尽管rhs可以组合出很多很强大的功能，但都是固定的序列，不能根据某个条件给出不同的序列。

使用map命令的expr参数可以在rhs的位置指定一个表达式，vim会eval这个表达式，并将表达式的值作为真正的rhs序列

看下面这个简单的例子：

``` 
noremap  <expr>0     col('.') == 1 ? '^': '0'
```

在Normal或者Visual模式下，按0键可以实现让光标在首列和首个非空白字符之间的切换。

这里就是用了一个条件表达式，当前列是第一列时，0键被映射成`^`键；当不在第一列时，还是0键

表达式可以是一个简单的函数调用，看下面这个例子

``` 
fun! Redraw()
  let l = winline()
  let cmd = l * 2 <= winheight(0) + 1 ? l <= (&so + 1) ? 'zb' : 'zt' : 'zz'
  return cmd
endf

nnoremap <expr><c-l> Redraw()
```

这个实现的是像emacs那样智能切换光标在窗口中的位置(上/中/下)，其实就是根据光标在窗口中的当前位置，就近的选择上中下，执行对应的命令zt/zz/zb

  
##  **map-expr命令的限制** 
    

map-expr命令简洁、优美且灵活，可以直接把一个按键序列的功能和一个函数绑定起来。

不过，这么完美的东西是不存在的，Vim在处理`map <expr>`命令的过程中，对rhs的表达式所使用的功能有一定的限制：

  

* 不能改变buffer的文本内容
* 不能编辑另一个buffer
* 不能使用:normal命令
* 可以移动光标，但是之后光标会被移到原来的位置        

通过`:h :map-<expr>`可以查看这些限制      
    

由于这些限制，有些时候我们在希望通过映射表达式，来完成某个改变光标位置或者改标文本内容的功能时，不得不放弃使用`<expr>`这个命令参数。

在Normal模式下，如果我们想将一个按键绑定一个函数，而且这个函数改变了光标位置或者文本内容，可以使用`:call 表达式<cr>`的映射来绕过限制；

那么在其他模式下怎么做呢?

  
##  **Insert和Command模式下的=** 
    
`<c-r>=`是Vim作者留给用户在Insert和Command模式下的另一个解决方案，尽管看起来不如`<expr>`优美，但是它没有限制，可以在表达式里调用任何移动光标和改标文本的命令和函数。

看下面这个例子：

我想实现在Insert模式下按`<m-f>`键实现向前移动一个单词，一般的做法是`inoremap <m-f> <c-o>e`，但是这样会涉及到模式切换，效率比较低，当连续按`<m-f>`时会明显感觉卡顿。所以，我的实现是直接在Insert模式里调用`norm`命令

``` 
fun! Exec(cmd)
    exe a:cmd
    return ''
endf
inoremap <expr><m-f> Exec('norm! e')
```

这是我最初想使用`<expr>`参数来实现这个功能，刚才提到了，Vim在处理expr的过程中，移动光标是无效的，所以有了下面的方案

``` 
inoremap <silent><m-f> <c-r>=Exec('norm! e')<cr>
```

Insert模式下的`<c-r>`键，本来是用于输入某个寄存器的内容，而`=`寄存器又是一个比较特殊的存在，它不像其他寄存器，在输入完寄存器名之后，直接返回寄存器的值，而是等待用户输入某个表达式，eval这个表达式并返回值。

  
##  **忽略递归映射的feedkeys函数** 
    

有些时候，我们想做一个函数，实现某个功能，然后直接提供给用户绑定按键。

但是我们又不确定用户使用的是`map`还是`noremap`，如果用户使用了`map`，我们返回的按键序列可能被重新映射

比如想实现`<tab>`键在插入模式下，有补全菜单时选择下一个，没有菜单时还是执行普通的`<tab>`键功能

``` 
fun! Tab()
    return pumvisible() ? "\<c-n>" : "\<tab>"
endf
imap <expr><tab> Tab()
```

看起来没什么毛病，但是如果用户前面定义了`imap <c-n> 333`，那我们按下`<tab>`键时就有可能输入333

正确的用法是这样的

``` 
inoremap <expr><tab> Tab()
```

除此之外，我们还可以改变Tab函数的实现来绕过不确定的用户行为

``` 
fun! Tab()
    call feedkeys(pumvisible() ? "\<c-n>" : "\<tab>", 'n')
    return ''
endf
```

feedkeys函数的详细解释参照`:h feedkeys()`。

上面这段代码中，调用了feedkeys函数将字符插入了队列中。

其中第一个参数就是要插入到队列的字符，第二个参数可以省略，默认情况下是'm'，为'm'时Vim会根据映射重新解释插入到队列里的字符，为'n'时则不会。

可以这样理解，第二个参数为'm'时，字符会插入到按键队列，为'n'时，插入到字符队列。

通过调用feedkeys函数，再返回一个空字符串，我们就可以绕过用户定义的按键行为，直接向Vim的字符处理队列发送字符。

  
