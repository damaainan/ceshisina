## MySQL 架构设计谈：从开发规范、选型、拆分到减压
<font face=微软雅黑>


 **作者介绍**

**李辉** ， 原 新浪爱彩票运维负责人，常用网名：门牙没了。曾主导新浪爱彩票的 MySQL 运维工作。培训合伙人、资深讲师，中国科学院大学在读研究生（大数据方向），擅长大型项目的关系型数据库运维和管理，现在在数据库运维自动化方向研究。

随着 MySQL 自身的发展与不断完善，不知不觉中整个互联网行业已离不开这个完善又小巧的关系型数据库，整个生态链也已经变得非常成熟，即便是初创企业和传统企业也可以放心大胆地把数据库迁移到 MySQL 上来。在大家和 MySQL 数据库愉快玩耍的同时，我来聊聊 MySQL 架构设计相关的一些话题。

**本文大纲：**

1. MySQL 数据库开发规范
1. MySQL 高可用架构选型
1. MySQL Sharding 拆分
1. 利用 NoSQL 为 MySQL 减压

### 一、MySQL 数据库开发规范

数据库规范到底有多重要？有过初创公司经历的朋友应该都深有体会。规范是数据库运维的一个基石，能有效地减少数据库出问题的概率，保障数据库 schema 的合理设计并方便后续自动化的管理。

曾经我们花了大半年时间来做数据库规范化的工作，例如制定数据库开发指南、给程序员做培训等，推进的时候也会遇到一些阻力。但规范之后运维质量会有一个质的提升，也增进了 DBA 的工作效率。

在开发规范方面，我们划分为开发规范和运维规范两部分。

 **1、开发规范**

**表设计的规范：**

* 字段数量建议不超过 20-50 个
* 做好数据评估，建议纯 INT 不超过 1500 万，含有 CHAR 的不要超过 1000 万。字段类型在满足需求条件下越小越好，尽量使用 UNSIGNED 存储非负整数，因为实际使用时候存储负数的场景不多。
* 将字符转换成数字存储。例如使用 UNSIGNED INT 存储 IPv4 地址而不是用 CHAR(15) ，但这种方式只能存储 IPv4，存储不了 IPv6。另外可以考虑将日期转化为数字，如：from_unixtime()、unix_timestamp()。
* 所有字段均定义为 NOT NULL，除非你真的想存储 null。

**索引设计的规范：**

1）所有表必须有显式主键

* InnoDB 表是以主键排序存储的 IOT 表
* 尽量使用短、自增的列做索引
* 复制结构使用 row 格式，如果表有主键可以加速复制
* UNSIGNED INT 自增列，也可以考虑 BIGINT
* TINYINT 做主键可能导致 MySQL Crash
* 类型转换会导致查询效率很低
* 可用 uuid_short() 代替 uuid()，转成 BIGINT 存储

2）合理地建立索引

* 选择区分度高的列作为索引
* 单个索引字段数不超过 5，单表索引数量不超过 5，避免冗余索引
* 建立的索引能覆盖 80% 主要的查询，不求全，解决问题的主要矛盾
* 复合索引排序问题，多用 explain 去确认

**SQL 编写规范：**

1）避免在数据库中进行大量计算任务

* 大事务拆成多个事务，分批多次操作
* 慎用 text、blob 大型字段，如要用考虑好拆分方案
* 频繁查询的字典表考虑用 Cache 抗

2）优化 join

* 避免大表与大表之间的 join，考虑让小表去驱动大表 join
* 最多允许三表 join，最好控制成两表
* 控制 join 后面 where 选择的行数

3）注重 where 条件，多用 EXPLAIN 确认

* where 条件的字段，尽量用区别度高的字段，这样走索引的性能更好
* 出现子查询的 SQL，先确认 MySQL 版本，利用 explain 确认执行计划
* 进行分页优化; DML 时候多个 value 合并

**Schema Review：**

1）字符集问题

表字符集选择 UTF8 ，如果需要存储 emoj 表情，就改成 UTF8mb4

2）Schema 设计原则

* 核心表字段数量尽可能地少，有大字段要考虑拆分
* 适当考虑一些反范式的表设计，增加冗余字段，减少 JOIN
* 资金字段考虑统一 * 100 处理成整型，避免使用 decimal 浮点类型存储
* 日志类型的表可以考虑按创建时间水平切割，定期归档历史数据

3）Schema 设计目标

* 快速实现功能为主，保证节省资源
* 平衡业务技术各个方面，做好取舍
* 不要在 DB 里进行大计算，减少复杂操作

整体来说，这部分规范还是很容易遵守的，实现起来也没有什么难度，就能取得很好的效果。

 **2、运维规范**

**（1）SQL 审核**

SQL 评审这部分工作相信让很多的 DBA 同学都叫苦不迭，人肉审核不仅效率低下，容易出错，对 DBA 的自身发展也非常不利，难道我们来上班就是为了审核 SQL 的吗？在经过了一段痛苦的人肉审核之后，我们接入了去哪儿网开源的 Inception，并根据自身的业务特点做了一些调整。当然现在开源的 SQL 评审软件已经很多了，大家可以自由选择，也可以自行开发。

在审核与执行上线 DDL 语句的时候，要注意 MySQL 官方原生 Online DDL 和 Percona 公司的 pt-osc 之间的一些差异，例如 pt-osc 在执行时每次都要 copy 全表，相对来说比较慢，好处是不锁表，并且有完善的条件检测和延时负载策略控制。官方 Online DDL 虽然官方也一直在改进，但生产环境使用还不是很完美，尤其要注意执行过程中容易导致 MDL 锁。官方 Online DDL 也有优于 pt-osc 的地方，比如增删索引，重命名列等，如下图所示。

![][1]

**（2）权限控制**

MySQL 从 5.6 开始，逐步完善了权限系统，比如 MySQL5.6 可以安装检查密码强度的插件，5.7 开始增加了密码过期机制、账户锁定等功能，对 SSL 这一块也做了一些优化，8.0 版本增加了角色的功能，权限系统已经逐步在向 Oracle 数据库靠拢了。在日常运维中，也可以使用 pt-show-grants 工具提高权限审查的力度。应用程序账号应只赋予 SELECT、INSERT、UPDATE 权限，DELETE 的逻辑改用 UPDATE 实现，并启用 sql_safe_updates 选项。

另一个有效控制权限的方法就是 SQL 堡垒机，早期我们通过改造 MyWebSQL 实现，在 Web 版客户端的基础上加入了一些资源控制策略、审计、语法校验等功能。后续又使用 Python 开发了功能更完备的 SQL 堡垒机，同时支持 MySQL、Oracle、Greenplum 等数据库。

![][2]

![][3]

SQL 堡垒机不仅可控制公司内部人员的数据库权限，追溯各类人员对数据库的操作，也能避免大查询或全表更新的情况发生，支持审计需求，整体运维质量提升了一个台阶。

**（3）MySQL 版本选择**

* MySQL 社区版，用户群体最大
* MySQL 企业版，收费
* Percona Server 版，新特性多，和 MySQL 社区版最接近
* MariaDB 版，国内用户暂时不多
* 选择优先级：MySQL 社区版 > Percona Server > MariaDB > MySQL 企业版

对于版本选择这件事，建议大家还是跟进官方社区版比较好，目前比较稳定的版本是 MySQL5.6，推荐大家使用。有特殊需求的话再选择 MySQL5.7、PXC、TiDB、TokuDB 等数据库。

### 二、MySQL 高可用架构选型

MySQL 高可用方面，目前业界主流依然是基于异步复制的技术，例如 Keepalived、MHA、ZooKeeper 等，要求数据强一致的场景逐步开始使用分布式协议，这方面的典型代表有 PXC、Group Replication、TiDB。下面我们就重点来说说 keepalived、MHA 和 PXC 这几种大家用得比较多的架构。

 **1、keepalived 高可用架构**

![][4]

业内使用非常普遍，它部署容易、方便维护，还节省服务器资源。这种架构的一个好处就是在发生切换后，原 Master 只需重新拉起来即可恢复高可用，不需要过多干预。扩展起来也方便，可以任意挂载只读库和灾备库。但它存在的问题也很明显，比如 Keepalived 的检测机制不完善、有脑裂隐患、数据一致性较弱等等。

还需要注意主从拓扑的设计。如下图，只读库挂到哪个 Master 比较合适？显然是 M2，其它两种拓扑在发生切换后都会影响到只读库的访问。

![][5]

 **2、MHA**

![][6]

MHA 自诞生以来，就得到了业内的广泛关注，并迅速流行开来。与 keepalived 相比，MHA 最大的优点就是在发生故障切换之后，能自动补齐 binlog，最大程度保证数据一致性。从服务器能自动切换，无需人工干预，能非常好的工作在读写分离的环境下。基于 Perl 语言的脚本也非常方便进行二次开发。MHA 非常适合读写压力比较大的应用。

但由于 MHA 在工作时需要配置 SSH 互信，因此选择这种架构时内网安全一定要做到位。另外也可以搭配 Binlog Server 使用。

 **3、PXC**

![][7]

PXC 全称是 Percona XtraDB Cluster，是 Percona 公司基于 Galera 协议开发的一个产品。PXC 牺牲了 CAP 里面的 P（Partition Tolerance），保留了 C(Consistency) 和 A(Availability )。这种结构非常适合电商、金融类业务，自 PXC 和 Group Replication 出现以后，MySQL 彻底扫清了进入金融行业的障碍。

**PXC 的优势：**

* 同步复制，解决了传统架构复制延迟和脑裂的问题
* 数据强一致
* 多主复制，每个节点都可以读写数据
* 并行复制，多个事务可以并行推送到其他节点
* 高可用，单点故障不影响集群可用性
* 新节点自动部署
* 与传统 MySQL 几乎完全兼容

**使用 PXC 要注意的问题：**

* 不要有大事务
* 木桶效应，集群性能取决于性能最差的那个节点
* 并发效率有损失
* 网络要求较高，建议万兆网络
* 多点并发写时锁冲突、死锁问题多
* 写无法扩展，无法解决热点更新问题

除此之外，还有一类采用 DNS/ZooKeeper 的高可用架构，这种架构通常都需要自行开发，无通用的方案，比较适合大规模集群的高可用，这里我们不过多赘述。

下面简单回顾一下上述几种高可用架构：

1. 双 Master 架构：非常成熟，使用很普遍，要注意延迟和数据的一致性。
1. PXC: 分布式协议，数据强一致性，并发效率略低，可用性好
1. MHA：各项指标介于 M-M 和 PXC 之间，性能无损失，适合读写分离架构。

总而言之，没有最完美的架构，只有最适合的架构。选择适合自己业务的即可。

### 三、MySQL sharding 拆分

接下来是第三个议题，MySQL 拆分原则和分库分表设计。

首先先提一个问题，为什么要拆，不拆不行吗？按照我们的经验来看，当数据和业务到了一定的规模，都不可避免的要面临分库分表的问题。这就好像汽车的发动机一样，要达到更高的性能，4 缸 6 缸明显是不够用的，V8、V12 才是王道。

**拆分能解决如下几个问题：**

* 单库并发较大
* 单库物理文件太大
* 单表过大，DDL 无法接受
* 防止出现性能瓶颈，提升性能
* 防止出现抖动不稳定现象

确定要进行数据库的拆分了，应该怎么拆呢？

 **垂直拆分**

优点：

* 拆分简单明了，拆分规则明确
* 应用程序模块清晰，整合容易
* 数据维护方便易行，容易定位

缺点：

* 表关联需要改到程序中完成
* 事务处理变的复杂
* 热点表还有可能存在性能瓶颈
* 过度拆分会造成管理复杂

**水平拆分**

优点：

* 不会影响表关联、事务操作
* 超大规模的表和高负载的表可以打散
* 应用程序端改动比较小
* 拆分能提升性能，也比较易扩展

缺点：

* 数据分散，影响聚集函数的使用
* 切分规则复杂，维护难度增加
* 后期迁移较复杂

**要先分库还是先分表？**

* 分库的优点：实现简单，库与库之间界限分明，便于维护，缺点是不利于频繁跨库操作，单表数据量大的问题解决不了。
* 分表的优点：能解决分库的不足点，但是缺点恰恰是分库的优点，分表实现起来比较复杂，特别是分表规则的划分，程序的编写，以及后期的数据库拆分移植维护。

一巴掌拍板直接选分库或分表都是不可取的，主要是看需要达到什么样的扩展方式，才能决定先分库还是先分表，根据具体的场景决定。分库分表的最终目的还是为了扩展，而且要看拆分的规划设计是针对哪一层。

上述问题都解决了，该考虑如何实现了，到底是在应用程序中实现，还是使用中间件？个人建议如果是小规模的拆分，直接在程序逻辑中实现即可，大规模的拆分再考虑使用各种中间件。

目前业内已经开源了很多的 MySQL 中间件产品，例如 Atlas、DBProxy、MyCAT、OneProxy、DRDS、Vitess 等等，每个中间件都有自己的特点，个别不太成熟的可能会存在一些 Bug，选用之前要做好相关的调研与测试工作，上线使用一定要保证自己能 hold 住。如果要完全贴合自身业务，并且掌控得较好的还是要自行开发。

下面说说我们的拆分经验。

首先我们先在压力比较大的数据库上做垂直拆分，剥离出活动、后台统计等业务。这一步也是最容易实现的。

接下来，如果是消息类的数据，就基于时间维度进行拆分，单表控制在 5-10G，行数控制到 500-1000w 这个样子。这个时候我们发现数据库的性能是比较好的，而且比较好维护。如果是用户类的数据，就按照 Hash 或 Range 进行拆分。这种情况下用这种方法拆分会拆的比较均匀一些。

并发仍然比较高怎么办？可以在时间维度拆分的基础上再按 Range 或 Hash 进行拆分。

最后要注意的就是不要过度的拆分，会造成复杂度的上升。Schema 设计合理的情况下，10 亿的数据量也能跑的好好的。个别不关键的应用，例如日志、监控数据等，使用分区表、TokuDB 也能抗。拆分对应用层总是有损的。

要做个 “懒”DBA。

![][8]

### 四、利用 NoSQL 为 MySQL 减压

最后一个议题，我们聊一聊 NoSQL。NoSQL 现在遍地开花，应用也很广泛了，业内用的比较多的主要集中在 Redis、MongoDB、Cassandra 等 NoSQL 数据库上。今天我们主要来说说和 MySQL 关联最为密切的 Redis。

**为什么要使用 Redis？**

* 数据存储在内存中，访问速度快
* 能支持大批量操作及爆发性负载
* 数据结构丰富，有效缓解 MySQL 压力
* 协议简单，支持各种语言的 API
* 存储大量数据无需担心性能

Redis 主要作用还是抗读的压力。读操作先到 Redis，Redis 中取不到再从 MySQL 数据库访问，从 MySQL 读取到数据后，还要回写到 Redis。

**使用 Redis 要注意的几点：**

性能方面，由于 Redis 完全是基于内存的访问，性能无需担心。

在使用 Redis 时，要注意 Cache 和 Storage 不要混合使用。不要依赖 Redis 的持久化，持久化这一块 Redis 要努力的还很多。另外如果你把 Redis 拿来做 Storage 的话，一旦 Redis 的内存跑满，那就惨了，所有的 Redis 连接都会卡着不响应。如果只是把 Redis 来做 cache 的话，那问题就不大。

还有诸如缓存穿透、缓存雪崩、热点 key 重建时缓存失效这些问题也是重点关注的对象。

**如何利用 Redis 给 MySQL 加速：**

1）利用 K/V 结构，缓存结果，例如存储用户信息、全局排行、统计信息等。

2）利用其丰富的数据结构为 MySQL 减压，例如计数器、排序、Hash（把表映射到 Redis 中）、消息队列等。

总结

系统架构设计是一个长期总结与进化的过程，讲究均衡与取舍。在进行大规模 MySQL 架构设计的过程中，除了要汲取别人的经验之外，还要关注各种架构背后的业务场景与架构思想，与自己的实际业务场景相结合，才能设计出一个好的系统架构来。

 -END-

</font>


[1]: ./img/URyc35z5ic3yzkpEOSTQJFw.png
[2]: ./img/fl8M87BrRcQqZPiaqOA.png
[3]: ./img/r13siccPqa67ic0vKKVxow.png
[4]: ./img/GfdGsHVy2TZTqIolMg.png
[5]: ./img/Azwk6TXic7pibkb01ExNQ.png
[6]: ./img/p0YBsYd8gSWeibZhpLEg.png
[7]: ./img/snz9EQMr3BqU7AhfueQg.png
[8]: ./img/Q4CTxwU4Pa0cFTgYug.png