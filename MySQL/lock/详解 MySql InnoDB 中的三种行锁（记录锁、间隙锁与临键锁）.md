## 详解 MySql InnoDB 中的三种行锁（记录锁、间隙锁与临键锁）

来源：<https://juejin.im/post/5b8577c26fb9a01a143fe04e>

时间：2018年08月29日


## 前言
`InnoDB`通过`MVCC`和`NEXT-KEY Locks`，解决了在`可重复读`的事务隔离级别下出现`幻读`的问题。`MVCC`我先挖个坑，日后再细讲，这篇文章我们主要来谈谈那些可爱的锁。
### 什么是幻读？

幻读是在`可重复读`的事务隔离级别下会出现的一种问题，简单来说，`可重复读`保证了当前事务不会读取到其他事务已提交的`UPDATE`操作。但同时，也会导致当前事务无法感知到来自其他事务中的`INSERT`或`DELETE`操作，这就是`幻读`。
### 关于行锁我们要知道的

行锁在 InnoDB 中是基于`索引`实现的，所以一旦某个加锁操作没有使用索引，那么该锁就会退化为`表锁`。
## 可爱的锁
### 记录锁（Record Locks）

顾名思义，记录锁就是为 **`某行`** 记录加锁，它`封锁该行的索引记录`：

```sql
-- id 列为主键列或唯一索引列
SELECT * FROM table WHERE id = 1 FOR UPDATE;
```

id 为 1 的记录行会被锁住。

需要注意的是：`id`列必须为`唯一索引列`或`主键列`，否则上述语句加的锁就会变成`临键锁`。
#### 其他实现

在通过`主键索引`与`唯一索引`对数据行进行 UPDATE 操作时，也会对该行数据加`记录锁`：

```sql
-- id 列为主键列或唯一索引列
UPDATE SET age = 50 WHERE id = 1;
```
### 间隙锁（Gap Locks）
 **`间隙锁`** 基于`非唯一索引`，它`锁定一段范围内的索引记录`。 **`间隙锁`** 基于下面将会提到的`Next-Key Locking`算法，请务必牢记： **`使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据`** 。

```sql
SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;
```

即所有在`（1，10）`区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。

除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加 **`间隙锁`** ，这个我们在下面会提到。
### 临键锁（Next-Key Locks）

Next-Key 可以理解为一种特殊的 **`间隙锁`** ，也可以理解为一种特殊的 **`算法`** 。通过 **`临建锁`** 可以解决`幻读`的问题。 每个数据行上的`非唯一索引列`上都会存在一把 **`临键锁`** ，当某个事务持有该数据行的 **`临键锁`** 时，会锁住一段 **`左开右闭区间`** 的数据。需要强调的一点是，`InnoDB`中`行级锁`是基于索引实现的， **`临键锁`** 只与`非唯一索引列`有关，在`唯一索引列`（包括`主键列`）上不存在 **`临键锁`** 。

假设有如下表：
 **`MySql`** ， **`InnoDB`** ， **`Repeatable-Read`** ：table(id PK, age KEY, name)

| id | age | name |
| - | - | - |
| 1 | 10 | Lee |
| 3 | 24 | Soraka |
| 5 | 32 | Zed |
| 7 | 45 | Talon |


该表中`age`列潜在的`临键锁`有：

(-∞, 10],

(10, 24],

(24, 32],

(32, 45],

(45, +∞],

在`事务 A`中执行如下命令：

```sql
-- 根据非唯一索引列 UPDATE 某条记录
UPDATE table SET name = Vladimir WHERE age = 24;
-- 或根据非唯一索引列 锁住某条记录
SELECT * FROM table WHERE age = 24 FOR UPDATE;
```

不管执行了上述 SQL 中的哪一句，之后如果在`事务 B`中执行以下命令，则该命令会被阻塞：

```sql
INSERT INTO table VALUES(100, 26, 'Ezreal');
```

很明显，`事务 A`在对`age`为 24 的列进行 UPDATE 操作的同时，也获取了`(24, 32]`这个区间内的临键锁。

不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：

```sql
INSERT INTO table VALUES(100, 30, 'Ezreal');
```

那最终我们就可以得知，在根据`非唯一索引`对记录行进行`UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE`操作时，InnoDB 会获取该记录行的`临键锁`，并同时获取该记录行下一个区间的`间隙锁`。

即`事务 A`在执行了上述的 SQL 后，最终被锁住的记录区间为`(10, 32)`。
## 总结


* **`InnoDB`**  中的`行锁`的实现依赖于`索引`，一旦某个加锁操作没有使用到索引，那么该锁就会退化为`表锁`。
* **`记录锁`** 存在于包括`主键索引`在内的`唯一索引`中，锁定单条索引记录。
* **`间隙锁`** 存在于`非唯一索引`中，锁定`开区间`范围内的一段间隔，它是基于 **`临键锁`** 实现的。
* **`临键锁`** 存在于`非唯一索引`中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的 **`间隙锁`** ，锁定一段`左开右闭`的索引区间。

