## InnoDB行锁，如何锁住一条不存在的记录？

来源：[http://zhuanlan.51cto.com/art/201808/582092.htm](http://zhuanlan.51cto.com/art/201808/582092.htm)

时间 2018-08-26 06:24:19

 
《 [InnoDB，5项最佳实践，知其所以然?][2] 》发布后，不少同学留言希望讲讲MySQL的InnoDB行锁机制。要细聊MySQL的行锁，难以避免的要从事务的四种隔离级别说起。
 
四种隔离级别，又脱不开聊读脏，不可重复读，读幻象等问题。
 
事务隔离级别，行锁机制等都比较垂直，应用开发中大部分同学都用不到，不确定是否大部分朋友都感兴趣。
 
今天，先抛出一个问题，如果大家确定对这类话题感兴趣的话，后续我花时间细聊这一系列问题。
 
![][0]
 
MySQL默认的事务隔离级别是 Repeated Read (RR)，假设使用的存储引擎是InnoDB，在这个隔离级别下：

 
* 读取到数据，都是其他事务已提交的数据; 
* 同一个事务中，相同的连续读，得到的结果应该是相同的; 
* 不会出现insert幻象读; 
 
 
假设有数据表：

```sql
t(id int PK, name) 
```
 
假设目前的记录是：

 
* 10, shenjian 
* 20, zhangsan 
* 30, lisi 
 
 
#### Case 1
 
事务A先执行，并且处于未提交状态：

```sql
update t set name=’a’ where id=10 
```
 
事务B后执行：

```sql
update t set name=’b’ where id=10 
```
 
因为事务A在PK id=10上加了行锁，因此事务B会阻塞。
 
#### Case 2
 
事务A先执行，并且处于未提交状态：

```sql
delete from t where id=40 
```
 
事务A想要删除一条不存在的记录。
 
事务B后执行：

```sql
insert into t values(40, ‘c’) 
```
 
事务B想要插入一条主键不冲突的记录。

 
* 问题1：事务B是否阻塞? 
* 问题2：如果事务B阻塞，锁如何加在一条不存在的记录上呢? 
* 问题3：事务的隔离级别，索引类型，是否对问题1和问题2有影响呢? 
 
 
如果大家对这些问题感兴趣，后续我花时间深入梳理逻辑，画图细聊。
 
如果不感兴趣，我换数据库应用层架构的话题。
 
是不是很有意思的一个问题?
 
猜猜InnoDB的行锁是怎么做到的?
 
【本文为51CTO专栏作者“58沈剑”原创稿件，转载请联系原作者】
 
![][1]
 
[戳这里，看该作者更多好文][3]


[2]: http://www.51cto.com/php/viewart.php?ID=582089
[3]: http://zhuanlan.51cto.com/columnlist/31/
[0]: ./img/BJfimae.jpg
[1]: ./img/mU3aa2E.jpg