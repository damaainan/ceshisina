## [数据库的脏读、幻读、不可重复读](http://dr-yanglong.github.io/2016/06/06/transaction-feature/)

## 数据库事务

在看elasticsearch时看到译者注释数据库事务，感觉不太准确，写这文章，复习下。

### 数据库事务的特征

数据库事务特征ACID

> A Atomicity 原子性

事务是一个原子性质的操作单元，事务里面的对数据库的操作要么都执行，要么都不执行，

> C Consistent 一致性

在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。

> I Isolation 隔离性

数据库允许多个并发事务同事对数据进行操作，隔离性保证各个事务相互独立，事务处理时的中间状态对其它事务是不可见的，以此防止出现数据不一致状态。可通过事务隔离级别设置：**`包括读未提交（Read uncommitted）`**、**`读提交（read committed）`**、**`可重复读（repeatable read）`**和**`串行化（Serializable）`**

> D Durable 持久性

一个事务处理结束后，其对数据库的修改就是永久性的，即使系统故障也不会丢失。

### 脏读、幻读、不可重复读

* 脏读：一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。
* 不可重复读：一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。
* 幻读：一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。

#### 解决方法

设置不同的事务隔离级别：

> 未授权读取

也称为读未提交（Read Uncommitted）：允许`脏读`取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

> 授权读取

也称为读提交（Read Committed）：`允许不可重复读取`，但`不允许脏读`取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

> 可重复读取（Repeatable Read）

可重复读取（Repeatable Read）：`禁止不可重复读取和脏读取`，但是有时`可能出现幻读`数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

> 序列化（Serializable）

序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

