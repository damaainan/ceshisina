# [PHP数据结构之八 树与二叉树基本概念][0]

 2016-08-08 16:23  304人阅读  

树的基本概念  
（一）树的定义  
树(Tree)是n(n≧0)个结点的有限集合T，若n=0时称为空树，否则：  
⑴ 有且只有一个特殊的称为树的根(Root)结点；  
⑵ 若n>1时，其余的结点被分为m(m>0)个互不相交的子集T1, T2, T3…Tm，其中每个子集本身又是一棵树，称其为根的子树(Subtree)。  
这是树的递归定义，即用树来定义树，而只有一个结点的树必定仅由根组成  
（二）树的基本术语  
⑴ 结点(node)：一个数据元素及其若干指向其子树的分支。  
⑵ 结点的度(degree) 、树的度：结点所拥有的子树的棵数称为结点的度。树中结点度的最大值称为树的度。   
⑶ 叶子(left)结点、非叶子结点：树中度为0的结点称为叶子结点(或终端结点)。相对应地，度不为0的结点称为非叶子结点(或非终端结点或分支结点)。除根结点外，分支结点又称为内部结点。  
如图6-1(b)中结点H、I、J、K、L、M、N是叶子结点，而所有其它结点都是分支结点。  
⑷ 孩子结点、双亲结点、兄弟结点  
一个结点的子树的根称为该结点的孩子结点(child)或子结点；相应地，该结点是其孩子结点的双亲结点(parent)或父结点。  
⑸ 层次、堂兄弟结点  
规定树中根结点的层次为1，其余结点的层次等于其双亲结点的层次加1。  
若某结点在第l(l≧1)层，则其子结点在第l+1层。  
双亲结点在同一层上的所有结点互称为堂兄弟结点。  
⑹ 结点的层次路径、祖先、子孙  
从根结点开始，到达某结点p所经过的所有结点成为结点p的层次路径(有且只有一条)。  
结点p的层次路径上的所有结点（p除外）称为p的祖先(ancester) 。  
以某一结点为根的子树中的任意结点称为该结点的子孙结点(descent)。  
⑺ 树的深度(depth)：树中结点的最大层次值，又称为树的高度  
⑻ 有序树和无序树：对于一棵树，若其中每一个结点的子树（若有）具有一定的次序，则该树称为有序树，否则称为无序树。  
⑼ 森林(forest)：是m(m≧0)棵互不相交的树的集合。显然，若将一棵树的根结点删除，剩余的子树就构成了森林。  
（三）二叉树  
1.二叉树的定义  
二叉树(Binary tree)是n(n≥0)个结点的有限集合。若n=0时称为空树，否则：  
⑴ 有且只有一个特殊的称为树的根(Root)结点；  
⑵ 若n>1时，其余的结点被分成为二个互不相交的子集T1,T2，分别称之为左、右子树，并且左、右子树又都是二叉树。  
由此可知，二叉树的定义是递归的。  
二叉树在树结构中起着非常重要的作用。因为二叉树结构简单，存储效率高，树的操作算法相对简单，且任何树都很容易转化成二叉树结构。上述中引入的有关树的术语也都适用于二叉树。  
性质1：在非空二叉树中，第i层上至多有2的i-1次方个结点(i≧1)。  
性质2：深度为k的二叉树至多有2的k次方减一个结点（k≧1) 。  
性质3：对任何一棵二叉树，若其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。  
2.满二叉树  
一棵深度为k且有2k-1个结点的二叉树称为满二叉树(Full Binary Tree)。  
满二叉树的特点：  
基本特点是每一层上的结点数总是最大结点数。  
满二叉树的所有的支结点都有左、右子树。  
可对满二叉树的结点进行连续编号，若规定从根结点开始，按“自上而下、自左至右”的原则进行。  
3.完全二叉树  
如果深度为k，由n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应，该二叉树称为完全二叉树。  
性质4：n个结点的完全二叉树深度为：└㏒2n┘ +1。  
其中符号： └x┘表示不大于x的最大整数。  
性质5：若对一棵有n个结点的完全二叉树(深度为└㏒2n┘+1)的结点按层（从第1层到第㏒2n +1层)序自左至右进行编号,则对于编号为i（1≦i≦n)的结点：  
⑴ 若i=1：则结点i是二叉树的根，无双亲结点；否则，若i>1，则其双亲结点编号是 i/2 。  
⑵ 如果2i>n：则结点i为叶子结点，无左孩子；否则，其左孩子结点编号是2i。  
⑶ 如果2i+1>n：则结点i无右孩子；否则，其右孩子结点编号是2i+1。  
4.遍历二叉树(Traversing Binary Tree)：是指按指定的规律对二叉树中的每个结点访问一次且仅访问一次。  
所谓访问是指对结点做某种处理。如：输出信息、修改结点的值等。  
二叉树是一种非线性结构，每个结点都可能有左、右两棵子树，因此，需要寻找一种规律，使二叉树上的结点能排列在一个线性队列上，从而便于遍历。  
二叉树的基本组成：根结点、左子树、右子树。若能依次遍历这三部分，就是遍历了二叉树。  
若以L、D、R分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、LDR、LRD、DRL、RDL、RLD。若规定先左后右，则只有前三种情况三种情况，分别是：  
DLR——先(根)序遍历。  
LDR——中(根)序遍历。  
LRD——后(根)序遍历。  
对于二叉树的遍历，分别讨论递归遍历算法和非递归遍历算法。递归遍历算法具有非常清晰的结构，但初学者往往难以接受或怀疑，不敢使用。实际上，递归算法是由系统通过使用堆栈来实现控制的。而非递归算法中的控制是由设计者定义和使用堆栈来实现的。  
1.先序遍历  
递归算法  
算法的递归定义是：  
若二叉树为空，则遍历结束；否则  
⑴ 访问根结点；  
⑵ 先序遍历左子树(递归调用本算法)；  
⑶ 先序遍历右子树(递归调用本算法)。  
非递归算法  
设T是指向二叉树根结点的指针变量，非递归算法是：  
若二叉树为空，则返回；否则，令p=T；  
⑴ 访问p所指向的结点；  
⑵ q=p->Rchild ，若q不为空，则q进栈；  
⑶ p=p->Lchild ，若p不为空，转(1)，否则转(4)；  
⑷ 退栈到p ，转(1)，直到栈空为止。  
2.中序遍历  
递归算法  
算法的递归定义是：  
若二叉树为空，则遍历结束；否则  
⑴ 中序遍历左子树(递归调用本算法)；  
⑵ 访问根结点；  
⑶ 中序遍历右子树(递归调用本算法)。  
非递归算法  
设T是指向二叉树根结点的指针变量，非递归算法是：  
若二叉树为空，则返回；否则，令p=T  
⑴ 若p不为空，p进栈， p=p->Lchild ；  
⑵ 否则(即p为空)，退栈到p，访问p所指向的结点；  
⑶ p=p->Rchild ，转(1)；  
直到栈空为止。  
3.后序遍历  
递归算法  
算法的递归定义是：  
若二叉树为空，则遍历结束；否则  
⑴ 后序遍历左子树(递归调用本算法)；  
⑵ 后序遍历右子树(递归调用本算法) ；  
⑶ 访问根结点 。  
非递归算法  
在后序遍历中，根结点是最后被访问的。因此，在遍历过程中，当搜索指针指向某一根结点时，不能立即访问，而要先遍历其左子树，此时根结点进栈。当其左子树遍历完后再搜索到该根结点时，还是不能访问，还需遍历其右子树。所以，此根结点还需再次进栈，当其右子树遍历完后再退栈到到该根结点时，才能被访问。  
因此，设立一个状态标志变量tag，tag=1，暂时不访问结点的值，tag=2,访问结点的值

[0]:http://blog.csdn.net/nuli888/article/details/52153041
