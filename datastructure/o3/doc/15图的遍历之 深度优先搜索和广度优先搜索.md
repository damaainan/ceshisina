## 图的遍历之 深度优先搜索和广度优先搜索

来源：[http://www.cnblogs.com/skywang12345/p/3711483.html](http://www.cnblogs.com/skywang12345/p/3711483.html)

2014-05-13 09:36



本章会先对图的深度优先搜索和广度优先搜索进行介绍，然后再给出C/C++/Java的实现。


**`目录`**  
**`1`** . [深度优先搜索的图文介绍][100] 
**`1.1`**  [深度优先搜索介绍][101] 
**`1.2`**  [深度优先搜索图解][102] 
**`2`** . [广度优先搜索的图文介绍][103] 
**`2.1`**  [广度优先搜索介绍][104] 
**`2.2`**  [广度优先搜索图解][105] 
**`3`** . [搜索算法的源码][106]


转载请注明出处：[http://www.cnblogs.com/skywang12345/][107]


更多内容：[数据结构与算法系列 目录][108]


 


<a name="anchor1"></a>

### **`深度优先搜索的图文介绍 `** 


<a name="anchor11"></a>


**`1. 深度优先搜索介绍 `** 


图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。


它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。  若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。


显然，深度优先搜索是一个递归的过程。


<a name="anchor12"></a>


**`2. 深度优先搜索图解 `** 


**`2.1 无向图的深度优先搜索 `** 


下面以"无向图"为例，来对深度优先搜索进行演示。


![][0]


对上面的图G1进行深度优先遍历，从顶点A开始。


![][1]


**`第1步`** ：访问A。 
**`第2步`** ：访问(A的邻接点)C。 

      在第1步访问A之后，接下来应该访问的是A的邻接点，即"C,D,F"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在"D和F"的前面，因此，先访问C。 
**`第3步`** ：访问(C的邻接点)B。 

      在第2步访问C之后，接下来应该访问C的邻接点，即"B和D"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 
**`第4步`** ：访问(C的邻接点)D。 

      在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 
**`第5步`** ：访问(A的邻接点)F。 

      前面已经访问了A，并且访问完了"A的邻接点B的所有邻接点(包括递归的邻接点在内)"；因此，此时返回到访问A的另一个邻接点F。 
**`第6步`** ：访问(F的邻接点)G。 
**`第7步`** ：访问(G的邻接点)E。


因此访问顺序是： **`A -> C -> B -> D -> F -> G -> E`** 


 


**`2.2 有向图的深度优先搜索 `** 


下面以"有向图"为例，来对深度优先搜索进行演示。


![][2]


对上面的图G2进行深度优先遍历，从顶点A开始。


![][3]


**`第1步`** ：访问A。 
**`第2步`** ：访问B。 

      在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 
**`第3步`** ：访问C。 

      在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 
**`第4步`** ：访问E。 

      接下来访问C的出边的另一个顶点，即顶点E。 
**`第5步`** ：访问D。 

      接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 
**`第6步`** ：访问F。 

      接下应该回溯"访问A的出边的另一个顶点F"。 
**`第7步`** ：访问G。


因此访问顺序是： **`A -> B -> C -> E -> D -> F -> G`** 


<a name="anchor2"></a>

### **`广度优先搜索的图文介绍 `** 


<a name="anchor21"></a>


**`1. 广度优先搜索介绍 `** 


广度优先搜索算法(Breadth First Search)，又称为"宽度优先搜索"或"横向优先搜索"，简称BFS。


它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。


换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。


<a name="anchor22"></a>


**`2. 广度优先搜索图解 `** 


**`2.1 无向图的广度优先搜索 `** 


下面以"无向图"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。


![][4]


**`第1步`** ：访问A。 
**`第2步`** ：依次访问C,D,F。 

     在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在"D和F"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 
**`第3步`** ：依次访问B,G。 

     在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 
**`第4步`** ：访问E。 

     在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。


因此访问顺序是： **`A -> C -> D -> F -> B -> G -> E`** 


**`2.2 有向图的广度优先搜索 `** 


下面以"有向图"为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。


![][5]


**`第1步`** ：访问A。 
**`第2步`** ：访问B。 
**`第3步`** ：依次访问C,E,F。 

     在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 
**`第4步`** ：依次访问D,G。 

     在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。


因此访问顺序是： **`A -> B -> C -> E -> F -> D -> G`** 


<a name="anchor3"></a>

### **`搜索算法的源码 `** 


这里分别给出"邻接矩阵无向图"、"邻接表无向图"、"邻接矩阵有向图"、"邻接表有向图"的C/C++/Java搜索算法源码。这里就不再对源码进行说明，please RTFSC；参考源码中的注释进行了解。


**`1. C语言源码`**  
**`1.1`**  [邻接矩阵实现的无向图(matrixudg.c)][109] 
**`1.2`**  [邻接表实现的无向图(listudg.c)][110] 
**`1.3`**  [邻接矩阵实现的有向图(matrixdg.c)][111] 
**`1.4`**  [邻接表实现的有向图(listdg.c)][112]


**`2. C++源码`**  
**`2.1`**  [邻接矩阵实现的无向图(MatrixUDG.cpp)][113] 
**`2.2`**  [邻接表实现的无向图(ListUDG.cpp)][114] 
**`2.3`**  [邻接矩阵实现的有向图(MatrixDG.cpp)][115] 
**`2.4`**  [邻接表实现的有向图(ListDG.cpp)][116]


**`3. Java源码`**  
**`3.1`**  [邻接矩阵实现的无向图(MatrixUDG.java)][117] 
**`3.2`**  [邻接表实现的无向图(ListUDG.java)][118] 
**`3.3`**  [邻接矩阵实现的有向图(MatrixDG.java)][119] 
**`3.4`**  [邻接表实现的有向图(ListDG.java)][120]

[0]: ../img/iterator01.jpg
[1]: ../img/iterator02.jpg
[2]: ../img/iterator03.jpg
[3]: ../img/iterator04.jpg
[4]: ../img/iterator05.jpg
[5]: ../img/iterator06.jpg
[100]: #anchor1
[101]: #anchor11
[102]: #anchor12
[103]: #anchor2
[104]: #anchor21
[105]: #anchor22
[106]: #anchor3
[107]: http://www.cnblogs.com/skywang12345/
[108]: http://www.cnblogs.com/skywang12345/p/3603935.html
[109]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/c/matrix_udg.c
[110]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/c/list_udg.c
[111]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/c/matrix_dg.c
[112]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/c/list_dg.c
[113]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/cplus/MatrixUDG.cpp
[114]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/cplus/ListUDG.cpp
[115]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/cplus/MatrixDG.cpp
[116]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/cplus/ListDG.cpp
[117]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/java/MatrixUDG.java
[118]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/udg/java/ListUDG.java
[119]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/java/MatrixDG.java
[120]: https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/source/graph/iterator/dg/java/ListDG.java