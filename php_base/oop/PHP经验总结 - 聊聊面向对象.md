## PHP经验总结 - 聊聊面向对象

来源：[https://segmentfault.com/a/1190000004067581](https://segmentfault.com/a/1190000004067581)


## 简述

“现在大伙都在讲面向对象编程，但是我们也得先找着一个对象是不？不然怎么面向对象？怎么编程？” --- 笑话一则，但是理不亏，要搞P面向对象编程，我们起码要先搞懂对象（还有类）是什么？只有了解它，理解它，你才能驾驭它。做编程的不能瞎搞，逻辑严谨清晰最重要，要明白我们在做什么？我需要做什么？我该怎么做？接下来，我来谈谈PHP类和对象的认知，然后说一下我们应该怎么用它们。
## 走进 PHP 类和对象
### 简述PHP类和对象


* 初学者的角度，可以认为类就是属性+函数。

* 类是面向对象程序设计的基本概念，通俗的理解“类”就是对现实中某一个种类的东西的抽象。

* 比如：汽车可以抽象为一个类，汽车拥有名字、轮胎、速度、重量等属性，可以有换挡、前进、后退等操作方法。

* 通常定义一个汽车类的方法为：

```php
<?php
// 定义一个叫Car的类
class Car {
    $name = '汽车';// 这个类有个变量$name，它的值为“汽车”
    // 这个类同时还有一个函数方法叫getName()，它能实现返回这个Car的类里面的变量$name的值
    function getName() {
        return $this->name;
    }
}
```

* **`类是一类东西的结构描述，而对象则是一类东西的一个具体实例。`** 

* 例如：汽车这个名词可以理解为汽车的总类，但这辆宝马汽车则是一个具体的汽车对象。

* 对象可以通过`new`关键字进行实例化：


```php
<?php

$car = new Car(); // 实例化Car这个类
echo $car->getName();// 调用Car这个类里面的getName()方法并输出结果（因为类被实例化了，所以这个类里面的函数、方法、变量、常量等都可以调用使用）
```


* 类与对象看起来比较相似，但实际上有本质的区别：类是抽象的概念，对象是具体的实例。

* 类可以使程序具有可重用性。



### 如何创建一个类


* 类通过关键字`class`开头，然后是类名与花括号，在花括号中定义类的属性与方法。

* 类名必须是字母或下划线开头，后面紧跟若干个字母、数字或下划线，类名最好能够表意，可以采用名词或者英文单词。

* 定义一个类，你可以这么干：



```php
<?php
// 定义一个类Car
class Car {
    // 定义属性变量$name
    public $name = '汽车';

    // 定义方法getName（）
    public function getName() {
        // 方法内部可以使用$this伪变量调用对象的属性或者方法
        return $this->name;
    }
}
```

* 要创建一个类的实例，可以使用`new`关键字创建一个对象，下面介绍2种创建类的方法：


```php
<?php

// 实例化类Car
$car = new Car(); 
//也可以采用变量来创建类Car
$className = 'Car';
$car = new $className();
```

* 注意：类的定义和创建是有本质上的区别的，定义类只是相当于创造了一台汽车，而创建类则是你要去开这台汽车，但是你并不知道这台汽车是否存在（类是否已被定义），所以在使用类之前那你必须要确保你要用的类存在（已被定义）。


### 类的属性

```php
1.在类中定义的变量称之为属性，通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。
2.属性声明是由关键字`public`，`protected`或者`private`开头，后面跟一个普通的变量声明来组成。
3.属性的变量可以设置初始化的默认值，默认值必须是常量。
4.访问控制的关键字代表的意义为：
  public：公开的
  protected：受保护的
  private：私有的

```

下面有一个案例，可以参考一下：

```php
<?php

class Car {
    //定义公共属性
    public $name = '汽车';

    //定义受保护的属性
    protected $corlor = '白色';

    //定义私有属性
    private $price = '100000';
}
```


* 类的属性默认都为public，外部可以访问。

* 类的属性一般通过`->`对象操作符来访问对象的属性或者方法，对于静态属性则使用`: :`双冒号进行访问。

* 当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。



下面是类属性调用的案例，也有一些错误的属性调用：

```php
<?php

$car = new Car();
echo $car->name;   // 调用对象的属性
echo $car->color;  // 错误 受保护的属性不允许外部调用
echo $car->price;  // 错误 私有属性不允许外部调用
```

* 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。如下：


```php
<?php
class Car{
    private $price = '1000';
    public function getPrice() {
        return $this->price; // 内部访问私有属性
​    }
}
```
### 定义类的方法


* 方法就是在类中的function，很多时候我们分不清方法与函数有什么差别 :

1.在面向过程的程序设计中function叫做函数 。
   2.在面向对象中function则被称之为方法 。

注：同属性一样，类的方法也具有`public`，`protected`以及`private`的访问控制。
   *访问控制的关键字代表的意义为：

```php
   public：公开的
   protected：受保护的
   private：私有的

```


* 我们可以这样定义方法：



```php
<?php

class Car {
    // 显然我定义了一个公共方法，类的外部也可以调用 
    public function getName() {
        return '汽车';
    }
​}
$car = new Car();
echo $car->getName();
```

* 使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号`: :`。


```php
<?php

class Car {
    // 显然我定义了一个公共的静态方法
    public static function getName() {
        return '汽车';
    }
​}
echo Car::getName(); // 结果为“汽车”
```
### 构造函数和析构函数


* top：这个其实我自己把握也不是很大，可能自己使用的比较少，析构方法和构造方法这些用的妙常常出现在高级工程师之手，都是一些项目底层代码里面经常用到的，而我之所以很少接触，显然易见我还是菜鸟，所以我应该继续好好学习。

* 定义：PHP5可以在类中使用__construct()定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。（这个的意思大概就是说构造函数往往在对象创建之前就调用该函数创建一些系统必须的共用对象或者类方法，还有完成一些初始化工作，所以这些构造函数往往都是一些最最最底层的东西）。

* 下面有一个很很很简单构造函数案例：



```php
<?php

class Car {
   // 这个就是大名鼎鼎的构造函数，一般在系统执行一些初始化工作
   function __construct() {
       print "构造函数被调用\n";
   }
}
$car = new Car(); //实例化类Car的时候 会自动调用构造函数__construct，这里会输出一个字符串
```


* 如果在子类中定义了 **__construct()**，则不会调用父类的**__construct()**。

* 如果需要同时调用父类的构造函数，需要使用 parent : : __construct() 显式的调用。

* 案例（可能有点绕）：



```php
<?php
// 注意，这个类Car是父级类
class Car {
   function __construct() {
       print "父类构造函数被调用\n";
   }
}
// 这个类Truck是Car的子类，因为它继承(extexds)了父类Car
class Truck extends Car {
   function __construct() {
       print "子类构造函数被调用\n";
       parent::__construct();
   }
}
$car = new Truck();// 结果显示：子类构造函数被调用\n父类构造函数被调用\n
```

* 同样，PHP5支持析构函数，使用__destruct()进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。


案例：

```php
<?php

class Car {
   function __construct() {
       print "构造函数被调用 \n";
   }
   function __destruct() {
       print "析构函数被调用 \n";
   }
}
$car = new Car(); // 实例化时会调用构造函数
echo '使用后，准备销毁car对象 \n';
unset($car); // 销毁时会调用析构函数
```

* 当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。


### Static静态关键字


* 静态属性与方法可以在不实例化类的情况下调用，直接使用 类名`::`方法名 的方式进行调用。

* 静态属性不允许对象使用`->`操作符调用：



```php
<?php

class Car {
    private static $speed = 10;
    
    public static function getSpeed() {
        return self::$speed;
    }
}
echo Car::getSpeed();  //调用静态方法，获取对象Car里面的静态属性$speed的值，并输出
```

* 静态方法也可以通过变量来进行动态调用：


```php
<?php

$func = 'getSpeed';
$className = 'Car';
echo $className::$func();  //动态调用静态方法
```

```php
静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性：

```

```php
<?php

// 父类Car
class Car {
    // 静态属性
    private static $speed = 10;
    // 静态方法
    public static function getSpeed() {
        return self::$speed;
    }
    // 静态方法
    public static function speedUp() {
        return self::$speed+=10;
    }
}

// 子类BigCar继承父类Car
class BigCar extends Car {
    // 静态方法
    public static function start() {
        parent::speedUp();
    }
}
 
BigCar::start();// 实例化调用BigCar类的statr()方法获取父类中的静态方法speedUp，实现静态属性$speed的值加10
echo BigCar::getSpeed(); // 解释太长了，自己脑补吧
```
### 访问控制

```php
访问控制通过关键字public，protected和private来实现。

```


* 被定义为公有的类成员（public）可以在任何地方被访问。

* 被定义为受保护的类成员（protected）则可以被其自身以及其子类和父类访问。

* 被定义为私有的类成员（private）则只能被其定义所在的类访问。

* 类属性必须定义为公有、受保护、私有之一。

* 为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。

* 案例：



```php
<?php

class Car {
    $speed = 10; // 错误 属性必须定义访问控制
    public $name;   // 定义共有属性
}
```


* 类中的方法可以被定义为公有、私有或受保护。

* 如果没有设置这些关键字，则该方法默认为公有:



```php
<?php

class Car {
​    //默认为共有方法
    function turnLeft() {
    }
}
```

* 如果构造函数定义成了私有方法，则不允许直接实例化对象了，这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，比如单例模式只允许有一个全局唯一的对象：


```php
<?php

class Car {
    // 显然这是一个私有的构造函数
    private function __construct() {
        echo 'object create';
    }
    // 这是一个私有的属性
    private static $_object = null;
    // 这是一个公共方法
    public static function getInstance() {
        if (empty(self::$_object)) {
            self::$_object = new Car(); // 内部方法可以调用私有方法，因此这里可以创建对象
        }
        return self::$_object;
    }
}
// $car = new Car(); // 这里不允许直接实例化对象
$car = Car::getInstance(); // 通过静态方法来获得一个实例
```
### 对象继承


* 继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，可以采用继承汽车类来共享这些属性与方法，实现代码的复用。

* 在代码中，实际上就是类的继承，`ClassA extends ClassB`，就是这么简单，但是这为我们开发提供了一个对象的重用性的特质，使得我们在开发上得到更好便利。

* 对象（我的理解就是类）的继承，就是函数方法调用的通道和数据接口的使用，实际使用就是这么的一个体验。（这仅仅是我的观点，欢迎大家指正我的观点，同时欢迎大家发表你的观点。）



### 重载


* PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。

* 属性的重载通过`__set`，`__get`，`__isset`，`__unset`来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。

* 关于重载，有以下这个案例可以看一下：



```php
<?php

class Car {
    // 显然这是一个私有属性
    private $ary = array();
    // 魔法方法 __set
    public function __set($key, $val) {
        $this->ary[$key] = $val;
    }
    //  魔法方法__get
    public function __get($key) {
        if (isset($this->ary[$key])) {
            return $this->ary[$key];
        }
        return null;
    }
    //  魔法方法__isset
    public function __isset($key) {
        if (isset($this->ary[$key])) {
            return true;
        }
        return false;
    }
    //  魔法方法__unset
    public function __unset($key) {
        unset($this->ary[$key]);
    }
}
$car = new Car();
$car->name = '汽车';  //name属性动态创建并赋值
echo $car->name;
```

* 方法的重载通过`__call`来实现，当调用不存在的方法的时候，将会转为参数调用`__call`方法，当调用不存在的静态方法时会使用`__callStatic`重载。


```php
<?php

class Car {
    public $speed = 0;
    // 显然这是一个魔法方法__call()，实现方法的重载
    public function __call($name, $args) {
        if ($name == 'speedUp') {
            $this->speed += 10;
        }
    }
}
$car = new Car();
$car->speedUp(); // 调用不存在的方法会使用重载
echo $car->speed;
```
### 对象的高级特性

* 对象比较，当同一个类的两个实例的所有属性都相等时，可以使用比较运算符`==`进行判断，当需要判断两个变量是否为同一个对象的引用时，可以使用全等运算符`===`进行判断：


```php
<?php

    class Car {
        echo "===";
    }
    $a = new Car();
    $b = new Car();
    if ($a == $b) echo '==';   //true
    if ($a === $b) echo '==='; //false
```

* 对象复制，在一些特殊情况下，可以通过关键字`clone`来复制一个对象，这时`__clone()`方法会被调用，通过这个魔术方法来设置属性的值。


```php
<?php

class Car {
    public $name = 'car';
    // 这是一个魔法方法__clone()方法
    public function __clone() {
        $obj = new Car();
        $obj->name = $this->name;
    }
}
$a = new Car();
$a->name = 'new car';
// 通过关键字clone来复制一个对象
$b = clone $a;
var_dump($b);
```

* 对象序列化，可以通过`serialize()`方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过`unserialize()`将字符串反序列化成对象进行使用。


```php
<?php

class Car {
    public $name = 'car';
}
$a = new Car();
$str = serialize($a); //对象序列化成字符串
echo $str.'<br/>';
$b = unserialize($str); //反序列化为对象
var_dump($b);
```
### 小结


* 人人都在喊面向对象编程，但是却不是人人都懂面向对象编程，这是一个很模糊很模糊的概念，模糊到很多人都不知道怎么定义它们。

* 到现在为止还没有人能够正式定义它们，这一切都需要靠自己，怎么去形容它？我一般用形容来对待什么是面向对象，类就像一个汽车类，而他的对象就是那些跑车小轿车什么的。

* 类和对象要切记对象是类的具体表现形式（基本存在），比如宝马车之于汽车类的意义。



## 总结


* 面向对象编程（OOP）是一种设计范式，同时也是一种程序开发方法。它视对象为程序的基本单元，将程序和数据封装在其中，以提高程序的重用性、灵活性和可扩展性。

* 类是对象的抽象组织，对象是类的基本存在。

* 对象和类的概念及两者的关系：  
   1.类是定义一系列属性和操作的模版，而对象则是把属性进行具体化，然后交给类处理。  
   2.对象就是数据，对象本身不包含方法。但是对象有一个“指针”指向一个类而这个类里可以有方法。  
   3.方法描述不同属性会导致不同的表现。  
   4.类和对象是不可分割的，有对象就必定有一个类与其对应，否则这个对象也就没有意义了。（但是有一种特殊情况：由标量进行强制类型转换的object，没有一个类与他相对应，此时PHP中一个称为“孤儿”sidClass类就会收留这个对象）。  

* 关于类的继承和组合的总结：首先继承是一种“像”或“是”的关系。而组合则是一种“需要”的关系。比如：  
   1.如果两个或者多个类有相同的代码和方法时，大可把它们都抽象（离）出来形成一个父类，然后它们这些有相同代码或方法的类作为子类 去继承它（哪些共有的代码）。  
   2.组合相比继承简单，组合的类可以是有关系（体现为复用代码很少），甚至没关系（复用的方法或代码）。  

* 在编程中，耦合是一种软件结构内不同模块代码之间互连程度的度量，也就是不同模块之间的依赖关系。（这个代码开发时要考虑代码可扩展性和易维护性，不然很容易牵一发而动全身的问题）。

* 低耦合是指模块与模块之间尽可能地使模块间独立存在，模块与模块之间的接口尽量少而简单。（这个就是说我们写的代码要尽可能的实现靠自己就能实 现功能，不需要靠别人，因为别人不一定靠得住，谁知道哪一天它就被干掉了呢？）。

* 解耦是指要接触模块与模块之间的依赖。

* 底层代码多用组合，顶层/业务层代码多用继承：  
   1.底层用组合可以提高效率，避免臃肿。  
   2.顶层代码用继承可以提高灵活性，让业务使用更加方便。  

* 面对对象的多态？  
   1.多态是指同一类对象在运行时的具体化。  
   2.PHP语言是弱类型，实现多态更简单更灵活。  
   3.类型转换不是多态。  
   4.PHP中父类和子类看作“继父”和“继子”关系，他们存在继承关系，但是不存在血缘关系，因此子类无法向上转为父类，从而失去多态最典型的特征。  
   5.多态的本质就是一个if...else，只不过实现的层级不同。

* 面向对象的接口  
   1.接口是作为一种规范和契约的存在：作为规范，接口应该保证可用性；作为契约，接口应该保证可控性。  
   2.接口只是一个声明，一旦使用`interface`关键字，就应该实现它。可以由程序员实现（外部接口），也可以由系统实现（内部接口）。  
   3.接口本身什么都不做，但是它可以告诉我们它能做什么。   
   4.PHP接口存在两点不足：没有契约的限制；缺少足够多的内部接口。

* 面向对象设计五大原则：  
   1.单一职责原则（SRP）：避免同一职责分散到不同类中，避免一个类承担太多职责（我的建议就是每个类尽可能简单，单纯实现一个功能，而且代码量尽可能精短，数据加工的方法可以抽离出来）。  
   2.接口隔离原则（ISP）：使用多个接口比使用单个接口好（一个类对另外一个类的依赖性（影响）是建立在最小的接口上，避免接口污染，避免为接口添加不必要的职责）。  
   3.开放-封闭原则（OCP）：模块在扩展性方面应该是开放的，而模块的更改性应该是封闭的（模块的行为必须是开放的，支持扩展而不是僵化的；对模块的功能进行扩展时，不应该影响或大规模地影响已有程序模块）。  
   4.替换原则（LSP）：子类必须能够替换它们的父类，并代表其出现在任何地方（父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中声明的方法，不应该给出多余的方法定义或实现；在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期绑定（动态多态））。   
   5.依赖倒置原则（这个真不熟）：将依赖关系倒置为依赖接口（上层模块不应该依赖下层模块，它们共同依赖同一个抽象；抽象不能依赖于具体，具体应该要依赖抽象）。

* 面向对象优点：   
   1.新成员的加入和融入不在困难，高难度抽象有利于高度总结。  
   2.代码即文档，团队中任何人都可以轻松地获得产品的各个模块的基本信息，而不需要读大量代码。

* 注：建议大家看看《PHP核心技术与最佳实践》这本书，由列旭松和陈文著作，机械工业出版社2013出版的。


