## PHP面向对象编程：面向对象概念、基本实践、高级实战、PHP面向对象特殊实践

来源：[https://segmentfault.com/a/1190000014430417](https://segmentfault.com/a/1190000014430417)


## 一、面向对象的概念
## 1.1 什么是面向对象(`object oriented`)

     世间万物皆对象，抽象的也是对象，一切可见或不可见都是对象
## 1.2 对象的基本组成

     对象包含两个部分：


* 对象的组成元素

* 是对象的`数据模型`，用于描述对象的数据
又称为对象的`属性`，或者对象的`成员变量`


* 对象的行为

* 是对象的`行为模型`，用于描述对象能够做什么事情
又被称为对象的`方法`

## 1.3 对象特点


* 每一个对象都是独一无二的
* 对象是一个特定的事物，他的职能是完成特定功能
* 对象是 **`可以重复使用`** 


## 1.4 面向对象简介


* 面向对象编程
就是编程的时候数据结构（数据组织方式 ）都通过对象的结构进行存储，使用 **``属性``** 和 **``方法``** 组织起来
* 为什么要使用面向对象编程？
对象的描述方式更加贴合真实世界，有利于对大型业务的理解


## 1.5 面向对象的实质


* 面向对象就是把生活中要解决的问题都用对象的方式进行存储--把所有的数据用 **`属性`** 、 **`方法`** 表现出来。
* 对象之间的互动是 **`通过`方法`的调用完成`互动``** 


## 1.6 面向对象的基本思路


* 识别对象
任何实体都可以被识别为一个对象
* 识别对象的 **`属性`** 
对象里面存储的数据被识别为属性
对于不同的业务逻辑，关注的数据不同，对象里面存储的属性也不同
* 识别对象的 **`行为`** 
对象自己的属性数据的改变
对象外部的交互


## 1.7 面向对象的基本原则


* 对象 **`内部`** `高内聚`
对象只负责一项 **``特定的职能``** （职能可大可小）
所有对象相关的内容都封装到对象内部
* 对象 **`外部`** `低耦合`
外部世界可以看到对象的一些属性（并非全部）
外部世界可以看到对象可以做某些事情（并非全部）


     软件设计尽可能的做到：高内聚，低耦合，模块与模块间应该是独立的，没有依赖关系
## 二、面向对象的基本实践
## 2.1 类的概念


* 物以类聚，把具有相似特性的对象对垒到一个类中
* 类定义了这些相似对象拥有的相同的属性和方法
* 类是相似对象的描述，成为类的定义，是该类对象的蓝图或者原型
* 类的对象称为一个类的`实例`(Instance)
* **`类的属性和方法统称为`类成员``** 


## 2.2 类的实例化


* 类的实例化：通过类定义创建一个类的对象
* 类的定义属性值都是空或默认值，而对象的属性都有具体的值


## 2.3 类的定义


* 类的定义以关键字`class`开始，后面跟着这个类的名称。类的命名 **`通常每个单词的第一个字母大写`** ，以中括号开始和结束
* 类的实例化为对象时使用关键字`new`，`new`之后紧跟类的名称和一对括号
* 对象中得成员属性和方法可以通过`->`符号来访问


## 2.4 构造函数


* 默认构造函数在对象被实例化的时候自动调用
* `$this`是`Php`里面的 **``伪变量``** ，表示对象本身。可以通过`$this->`的方式访问对象的属性和方法
* 每一次用`new`实例化对象的时候，都会用类名后面的参数列表调用构造函数
* `php`类函数的构造函数`function __construct(){}`运行时自动调用


## 2.5 析构函数


* `function __destruct(){}`析构函数是根据后入先出的原则
* 有 **`两种方式`** 会被执行析构函数：对象被设置未`null`或者程序结束时会被自动调用析构函数，，所占用的资源被系统回收
* 析构函数通常被用于清理程序使用的资源，比如释放打开的文件等等
* 析构函数在该对象不会再被使用的情况下自动调用， **``如果被复制了，而不是`&`引用，就不会调用析构函数``** 


## 2.6 对象`&`引用的基本概念

```php
$james1 = $james; //相当于复制出来多一个引用，两者是独立的两个引用
$james2 = &$james; //相当于为james取一个别名，两者其实是一体的，只是有两个名字

```

![][0]

      **`特别注意：`** 


* **``PHP 永远会将对象按引用传递``** （`ArrayObject`是一个`SPL` **``对象``** ，它完全模仿数组的用法，但是却是以对象来工作）
* `$arr = array(); $arr2 = $arr;``$arr2`是`$arr` **``数组的一份拷贝``** ，它们之间互不影响，是独立的两个数组
* `&`对象（数组）都是相当于起 **``别名``** 


#### [深入理解PHP引用：常见错误 #3：关于通过引用返回与通过值返回的困惑][2]

## 三、面向对象的高级实战
## 3.1 对象的继承

    父类：拥有部分相同的属性和方法

    继承的好处

* 父类里面定义的类成员可以不用在子类中重复定义，节约了编程的时间和代价
* 同一个父类的子类拥有相同的父类定义的类成员，因此外部代码调用他们的时候可以一视同仁
* 子类可以修改和调用父类定义的类成员


* 我们称为 **``重写``** （`Overwrite`）
* 一旦子类修改了，就按照子类修改之后的功能执行

    子类：

* 子类可以通过`$this`访问父类的属性
* 子类的对象可以直接调用父类的方法和属性
* `PHP`的 **``单继承特性``** ：类不允许同时继承多个父类（`extends`后面只能跟一个父类名称）


## 3.2 访问控制

    面向对象的三种访问权限：


* `public`是公有的类成员，可以在任何地方被访问

* 可以被类以及子类或者对象都可以访问


* `protected`受保护的类成员，可以被其自身以及继承的子类访问

* 可以被子类继承，但是不能被对象访问，只能通过封装的方式让对象访问


* `private`私有的类成员，只能被自身访问

* 不能被子类继承，也不能被对象访问，只能在自身通过封装让外界访问（例如在类里面定义一个公开方法来调用私有属性）




## 3.3 Static(静态)关键字

    静态成员：定义时在访问控制关键字后添加`static`关键字即可（访问控制关键字：`public. protected. private`）


* 静态属性用于保存类的公有数据，可以在不同对象间共享
* 静态方法里面只能访问静态属性
* 静态成员不需要实例化对象就可以访问
* 类的内部可以通过`self::`或 **``static::``**  关键字访问自身静态成员， **`self::`** `$` **`属性 self::方法()`** 
* 通过`parent::`关键字访问 **`父类的静态成员`** ，也可以通过子类::父类静态成员
* 通过`类名::`的方式在类的外部访问静态成员


## 3.4 重写和Final关键字


* 子类中编写跟父类完全一致的方法可以完成对父类方法的重写，方法参数最好有默认参数
* 对于不想被任何类继承的类可以在`class`之前添加`final`关键字
* 对于不想被子类重写（`overwrite`, 修改）的方法，可以在方法定义前面添加`final`关键字


## 3.5 数据访问


* **``parent`关键字可以可用于调用父类中被子类重写了的方法`** 
* `self`关键字可以用于访问类自身的 **``成员方法``** ，静态成员和类常量； **`不能用于访问类自身的属性！！！`** 使用常量的时候不需要在常量`const`名称前面添加`$`符号
* `static::`关键字用于访问类自身定义的静态成员，访问静态属性时需要在属性前面添加`$`符号。
* 常量属性`const`不能使用对象访问，仅能使用类访问，在类本体内可以使用“`self::常量名`”，在类本体外可以使用“`类名::常量名`”


## 3.6 对象接口

     接口就是把不同类的`共同行为`进行定义，然后在不同的类里面实现不同的功能


* `interface`定义接口，`implements`用于表示类实现某个接口
* 接口里面的方法没有具体的实现，无`{}`
* 实现了某个接口的类必须提供接口中定义的方法的具体实现
* 不能实例化接口，但是能够判断某个对象是否实现了某个接口。`instanceof`关键字判断某个对象是否实现了某个接口`$object instanceof interface`
* 接口可以继承接口（`interface extends interface`）
* 接口中定义的所有 **`方法`** 都 **``必须是公有``** ，这是接口的特性


## 3.7 多态

     因为接口的方法实现可以有很多，所以对于接口里面定义的方法的具体实现是多种多样的，这种特性我们称为 **``多态``** 

     不需要知道对象属于哪个类，只要判断该对象的类是否实现接口，就能实现调用，相同代码实现不同结果

     形象点说就是同一个接口，不同的对象实现，得出的结果不一样就是多态，如传入的是人类对象，得到的是人类吃苹果，传入的是猴子对象，得到的就是猴子吃香蕉。相同的一行代码，对于传入不同的接口的实现的对象的时候，表现是不同的。

```php
/**
 * 多态
 * 1. 只要某个对象实现了接口（instanceof），就可以直接在对象上调用接口的方法
 */

interface ICanEat {
   public function eat($food);
}

// Human类实现了ICanEat接口
class Human implements ICanEat { 
  // 跟Animal类的实现是不同的
  public function eat($food){
    echo "Human eating " . $food . "\n";
  }
}

// Animal类实现了ICanEat接口
class Animal implements ICanEat {
  public function eat($food){
    echo "Animal eating " . $food . "\n";
  }
}

function eat($obj){
  if($obj instanceof ICanEat){ 
    $obj->eat("FOOD"); // 不需要知道到底是Human还是Animal，直接吃就行了
  }else{
    echo "Can't eat!\n";
  }
}

$man = new Human();
$monkey = new Animal();

// 同样的代码，传入接口的不同实现类的时候，表现不同。这就是为什么成为多态的原因。
eat($man);
eat($monkey);
```
## 3.8 抽象类

     接口里面的方法都是没有实现的，而类里面的方法都是有实现的。
     有没有一种形态，允许类里面一部分方法不实现呢？

* 当接口中的某些方法对于所有的实现类都是一样的实现方法，只有部分方法需要用到多态的特性

* 如人和动物吃东西是不同的，但是呼吸是相同的，不需要为人和动物分别实现呼吸的功能




* `abstract`关键字用于定义抽象类
* 在抽象方法前面添加`abstract`关键字可以标明这个方法是抽象方法不需要具体实现`{}`
* 抽象类中可以包含普通的方法，有方法的具体实现
* 继承抽象类的关键字是`extends`
* 继承抽象类的子类需要实现抽象类中定义的抽象方法
* 抽象类不能被实例化，当子类继承抽象类的时候，所有的抽象的方法都必须定义


```php
/**
 * 抽象类
 * 1. 抽象类允许类里面的部分方法暂时没有具体实现，这些方法我们成为抽象方法
 * 2. 一旦类里面有抽象方法，这个类就必须是抽象类
 * 3. 抽象类跟接口一样，不能直接实例化为对象
 */

// 抽象类前面以abstract关键字开始
abstract class ACanEat {
   // 没有实现的方法需要设定为抽象方法
   // 抽象方法需要在子类中实现 
   abstract public function eat($food);

   public function breath(){
      echo "Breath use the air.\n";
   }
}

// Human类实现了ICanEat接口
class Human extends ACanEat { 
  // 跟Animal类的实现是不同的
  public function eat($food){
    echo "Human eating " . $food . "\n";
  }
}

// Animal类实现了ICanEat接口
class Animal extends ACanEat {
  public function eat($food){
    echo "Animal eating " . $food . "\n";
  }
}

$man = new Human();
$man->eat("Apple");
$man->breath(); // 和Animal共用了抽象类ICanEat的breath方法
$monkey = new Animal();
$monkey->eat("Banana");
$monkey->breath();
```
## 四、PHP面向对象的特殊实践
## 4.1 魔术方法之_toString()和invoke()


* `__toString()`当对象被当作String使用时，这个方法会被自动调用（需要在类中定义`__tostring()`方法。调用 echo $object
* `__invoke()`当对象被当作方法调用时，这个方法会被自动调用（需要在类中定义`__invoke()`方法）。调用 $object($parameter)


```php
/**
 * 魔术方法1
 * 1. 当对象被当做String使用时，__toString()会被自动调用
 * 2. 当对象被当成方法调用时，__invoke()会被自动调用
 */
class MagicTest{
  public function __toString(){
    return "This is the Class MagicTest.\n";
  }
  public function __invoke($x){
    echo "__invoke called with parameter " . $x . "\n";
  }
}

$obj =  new MagicTest();
echo $obj;
$obj(5);

```
## 4.2 魔术方法之__call()和__callStatic()


* `__call()`方法：当对象访问不存在的方法名称时，此方法自动调用。


* 调用示例：`public function __call($name,$argument){}`
* 注意：访问控制关键字必须为`public`；必须有两个参数：对象访问的方法名称(`$name`)、方法包含的参数(`$argument`==> 自动转换成数组)。



* `__callStatic()`方法：当对象访问不存在的静态方法名称时，此方法自动调用。


* 调用示例：`public static function __callStatic($name,$argument){}`
* 注意：同`__call()`；此方法为静态方法(static)。

* 这两种方法也被称为 **`方法的重载`** （`overloading`）


* 注意区分重写（`overwrite`）
* 通过这两个方法，同一个方法的调用可以对应不同的方法的实现（同一个方法的静态调用、动态调用对应不同的方法实现）


```php
/**
 * 魔术方法之方法重载
 * 1. 当对象访问不存在的方法名称时，__call()方法会被自动调用
 * 2. 当对象访问不存在的静态方法名称时，__callStatic()方法会被自动调用
 */
class MagicTest{
    /**
     * 自动将参数转换成数组
     * array (size=2)
     *  0 => string 'para1' (length=5)
     *  1 => string 'para2' (length=5)
     * @param $name
     * @param $arguments
     */
  public function __call($name, $arguments){
      var_dump($arguments);
    echo "Calling " . $name . " with parameters: " . implode(', ', $arguments) . "\n";
  }

  public static function __callStatic($name, $arguments){
    echo "Static calling " . $name . " with parameters: " . implode(', ', $arguments) . "\n";
  }
}

$obj =  new MagicTest();
$obj->runTest("para1", "para2");
MagicTest::runTest("para3","para4");
```
## 4.3 魔术方法之__get()、__set()、__isset()和__unset()


* 在给不可访问`属性`赋值时， **`__set()`** 会被调用 定义 **`function __set($name,$value)`** 
* `读取`不可访问属性的值时， **`__get()`** 会被调用 定义 **`function __get($name)`** 
* 当对不可访问属性调用`isset()`或`empty()`时，`__isset()`会被调用
* 当对不可访问的属性调用`unset()`时，`__unset()`会被调用


     这几个方法也被成为`属性重载`的魔术方法
     所谓不可访问属性，实际上就是在调用某个属性时发现这个属性没有被定义，这时候不同的操作会触发不同的魔术方法
## 4.4 魔术方法之__clone()

![][1]

```php
$obj1 = $ojb; //不能实现对象复制，两个对象变量指向同一对象
$obj1 = clone $obj; //实现对象复制，变成值相同的两个对象
```

     调用`clone`时会自动调用`__clone()`方法

```php
$james = new NbaPlayer(); //$ja0 对应内存地址(假设为 address0 )中存储的是 james对象的标识符
$james2 = clone $james;    //当希望生成一个真正独立存储的 NbaPlayer() 对象,但新对象的所有数据都和 $james 对象中的相同时,使用关键字clone

```

     当在`class NbaPlayer()`中定义了`__clone()`方法 后,使用`clone`关键字时,系统将调用用户定义的`__clone()`方法 (此时可以对`clone`后生成的新对象的属性进行修改)
 **`完！`** 

[参考教程：PHP面向对象编程][3]

[2]: https://segmentfault.com/a/1190000014126990#articleHeader2
[3]: https://www.imooc.com/learn/184
[0]: ../img/bV8CNy.png
[1]: ../img/bV8HnZ.png