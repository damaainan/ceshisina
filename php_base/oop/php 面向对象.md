## [php 面向对象](http://www.cnblogs.com/xiong63/p/6057204.html)

面向对象是一种编程思想，对于小白来说，瞬间掌握，难度很大，需要体会和实践，慢慢领悟，为了防止陷入思想的无底洞，先不用管为什么  
这么写, 前期我们需要先熟悉语法和用法, 随着代码量的增多, 理解自然会深化. 前期一定要先做到以下几点：  
1. 类声明语法 试声明 student 类, 有 score 属性和 study 方法  
2. 权限封装 知道 public、 protected、 private 各自的可见范围  
3. 继承 写 A 类, 再写 B 类继承自 A 类, 且要重写 A 类中的某个方法  
4. 静态属性与静态方法，知道 static 静态方法需要用类名:: 方法名 () 调用  
5. 魔术方法 了解常用魔术方法分别在什么时间被调用  
6. 写一个抽象类, 并用 2 个子类分别继承实现 分析这 2 个子类有什么共同特点?  
7. 写一个接口, 并用 2 个类分别继承实现 分析这 2 个类有什么共同点

面向过程 ：每个小系统有着明确的开始和和结束 。开始和结束之间有着严谨的因果关系。

比如 ：上帝创造一个人，如果有 70 亿人那就很麻烦

随机函数先获取随机的数字 作为数组的下标，然后再从数组中获取对应下标的数字。

## 面向对象 

引入例子 ：女娲 人身蛇尾 ， 用女娲造人引出类和实例 ： 女娲造人前先 思考 人的形象 然后再造人

所以 ：人的形象是抽象的，用来说明人的特点；而每一个人都是具体的，且符合人的形象

类 ：所有对象共同点的一个抽象！（就是一个 制造说明书）

对象 ：就是根据说明书制造出来的具体对象

类中有什么？ 属性（比如人：身高，体重，姓名）

能干什么？功能（说活，吃饭）

用 变量 和 函数 分别模拟 属性 和 功能

面向对象中 ，方法即是函数 ； 属性即是变量 ，只是面相对象中一般说方法和属性

new 类名（）；// 直接产生一个对象并返回该对象

$a = new 类名（）； // 那么 a 对象就包含 类中声明的所有属性（类似关联数组）

![][0]

![][1]

要调用对应的属性值可以 $a -> name (name 不用 $)；要调用对应的方法 $a -> say()

面向对象 oo（object oriented）oop 加编程

声明类的时候 ：

内存分配给类一个空间，，里面存放着类定义的属性和函数

new 对象的时候 ：

1、 申请内存，生成对象（属性集合）

2、 如果有构造函执行

3、 返回对象的地址

![][2]

内存分配图

语法就是法律； 规范 就是 道德

(1) 属性的初始化 不能是表达式 如 ： $a = 1+3 ; java 中是允许的

（2）同一个域内 (比如一个类中)，函数不能重复定义（即是名字不能一样）

（3）在一个类里面，如果要调用系统同名的自定义函数，需要用 $this，否则调用系统函数 ； 此外一个类里面 一个函数调用 不是他内部的变量或者它调用其他函数也要加 $this

**构造函数 ：**`__construct()` , 注意前面是两个下划线 ； 当 new 对象（产生对象），调用 ； 构造函数不能被重载即是不能再有同名的

**析构函数 ：**`__destruct()` 在对象被销毁的时候调用的函数 。

如何销毁对象 ：

1、显式销毁，`unset（）`，直接赋值为 null 或者其他值

2、执行完最后一行代码时自动销毁（如果之前已经销毁，则不再销毁）

![][3]

**对变量指向销毁问题**


    $a = new People(); // 创建一个对象（new People()），并把使用权给变量 $a（$a 是一个变量名，指向这个对象）
    $a = $b = $c ; //3 个变量都指向内存中的同一个对象

![][4]

    unset（$a）;//unset，即是销毁对象 (object)，但有其他变量 $b 等仍然指向对象，那么该对象将不能被销毁，但是 $a 为 null 不再指向这个对象

**this 绑定**

当一个对象调用一个它对应类的方法时，该方法执行之前先完成一个绑定，即是用

$this 绑定到调用此方法的对象（这样才能在方法内对这个对象的属性进行操纵），因为方法内如果想访问调用者（即是对象）的属性必须用 $this；否则则理解为方法内部的一个局部变量

![][5]

Java 中不一样，函数不需要 this 也能访问方法外的变量

**封装**

封装的概念 ： 通过修饰符 改变属性或者函数的访问权限 ，达到保护的作用。

光是封装起来是没意义的，还要供外部交互才行；所以通过一个开放的接口（即是一个函数）供外部操纵；内部的操作，不需要外部知道，从而隐藏内部的一些细节 。

如： 洗衣机，你只要点击启动程序的按钮就能洗衣服，不需要知道洗衣机内部怎么运行

权限修饰符 ：private protected public

private 修饰的属性只能在其 类里面 才能被访问到。

protected 本类和子类能访问

private 访问权限的 bug ： 对象之间能够相互操作同一个类中的属性，导致一个对象能够修改另一个对象的属性。

![][6]

fatal error（致命错误）

**封装 操作数据库的 类**

类似把某个功能的一段代码放在一个类中 ； 类里面的方法相互调用

用面向对象的思想 对数据库操作 （mysql 封装类）

比如把连接数据的操作封装到一个连接函数中

连接数据库

发送 查询

对于 select 语句 返回查询数据数据

关闭 mysql 连接

**继承**

子类继承父类的属性和方法，再进一步拓展自己的属性和方法；父类的属性 和方法一般是一个归纳（所有对象都有的），提高代码的重新性

**拥有问题 ：**子类继承父类，子类有父类所有的属性和方法，在子类里面能够操作父类中非 private 修饰的属性或者方法，但是父类中对于 private 修饰的属性或者方法子类无法操作（类外的范围限制）

![][7]

![][8]

**调用与覆盖问题**： 子类里面调用对应的属性时，子类没有覆盖父类中的属性或者方法，则调用父类中的属性或方法，否则只调用子类中的，无论传参数是否对。private 的调用除外

**注意**继承父类之后，子类再声明与父类一样的属性，权限符只能越来越宽松或者一样 。 如果父类的属性有 static，子类也必须有才能声明

★类内一般声明只属性和方法，实例化或者输出等语句要写在方法里或者类外，否则报错

如果子类有和父类一样的方法，能使用 parent：：方法名 () 指定调用父类的

![][9]

**构造函数**是可以被继承的；如果子类中没有写构造函数，在实例化子类的时候就会调用父类的构造方法。如果子类重新写则覆盖且只调用子类的。

因此如果父类的构造函数是必须要调用，最好使用 parent::__construct() 调用一下（java 不同，它会先调用父构造再调用子构造；php 调用子构造）

比如 ：数据库类中 父类构造函数有连接数据库，如果子类写了其他的话构造函数，则连接失败 （Java 不同，父子都调用）

在类外对象名只能调用类中 public 修饰的属性，其他的属性可以通过方法来调用。一般不写则默认为 public

![][10]

![][11]

**多态**

只抽象声明父类，具体的工作由子类对象完成

java 出现多态是因为它是强类型语言（即是定义了类型不能随便改变），声明的类型 后 传送参数必须是该类型 。 声明参数时，声明为父类型，传参时，能够传子类型。以达到多态的效果。比如：

多颜色手电筒问题 ：声明手电筒，并接受玻璃的参数。然后玻璃有多种颜色，以达到不同效果。则为多态

php 是弱类型语言，本身没有对类型没有检测，因此简直变态，后来 5.3 以后，引入了对于对象类型的参数检测。限制了灵活性达到多态

![][12]

![][13]

## static 静态属性 

一般当 某个属性或者方法 是所有对象固有的（即是不改变），则声明为静态属性，节省内存，随时类名调用；无论函数调用多少次, 只初始化第一次.，如 static $a = 1;

静态属性存在于类内存中，而不是对象的内存中。只要有类就能访问到，因此一个静态属性只有一个，改 1 全变；只能 类名：：属性名 访问

![][14]

**静态方法**

普通方法和静态方法都存在 类内存 中 且只有一个

但是静态方法用类名调用，不用 this 绑定；普通方法需要有对象才能用 this 绑定调用

安装 ecshop 的时候出现 strict standard 错误提示，原因是版本高，代码书写语法有误，静态方法调用非静态方法时出现问题。

非静态方法, 是不能由类名静态调用的. 但是 PHP 中的面向对象检测的并不严格,

只要该方法没有 $this, 就会转化静态方法来调用.

但是, 在 PHP5.3 的 strict 级别下, 或者 PHP5.4 的默认级别

都已经对类名:: 非静态方法做了提示

则会提示: Strict Standards: Non-static method Human::eat() should not be called statically

不能静态的去调用非静态方法 ； 有 static 修饰的变量和函数不能出现 $this

isset（$this） 这个时候判断有没对象进行绑定；

代码分析

![][15]

![][16]

this 就是指向当前对象实例的指针，不指向任何其他对象或类

self, parent 的用法 （::(域运算符号)）

self: 指向类本身，也就是 self 是不指向任何已经实例化的对象 ，self 使用来指向类中的静态属性或者方法

self::$staticProperty

self::staticMothed;

parent: 指向父类的指针，一般我们使用 parent 来调用父类的构造函数。

在引入自身的静态属性 / 静态方法，以及父类的方法时, 可以用到.

parent::$staticProperty

parent::Mothed;

![][17]

★应该选择 this 还是 parent

![][18]

![][19]

**总结使用**

1: 修饰类的属性与方法为静态属性, 静态方法

2: `static::method()`, 延迟绑定

3: 在函数 / 方法中, 声明静态变量用

## 单例模式

避免多人开发过程，实例化过多导致资源浪费， 限制只实例化一次的模式

构造方法不能执行则实例化失败

思路 ：

1、 保护或私有构造函数，房子外部实例化

2、 内部开发一个公共的静态方法，负责实例化

3、 类有一个静态属性存放对象

```php
<?php
class Single {
    //设置私有，保存实例状态
    static protected $ins = NULL;
    //设置为私有，限制类外实例化，若没有子类可去掉final
    final protected function __construct() {
        echo '实例化成功！';
    }
    //设置为静态方法，类外能调用，实例化
    static public function getinstance() {
        //self代表当前类，判断是否实例化
        if (self::$ins instanceof self) {
            return self::$ins;
        }
        self::$ins = new self();
        return self::$ins;
    }
}  

$s1 = Single::getinstance();
$s2 = Single::getinstance();  

//子类继承父类若还要单例，要用final修饰父类构造方法，
//阻止子类重写构造方法自己去new的问题
class Single2 extends Single {
}  

$s11 = Single2::getInstance();
$s12 = Single2::getInstance();  

if ($s11 === $s12) {
    echo "相等";
}
```

**final**

final 不能修饰属性

final 修饰方法，此方法能继承，不能被重写

final 修饰类, 则此类 不能够被继承

## 魔术方法

是指某些情况下, 会自动调用的方法, 称为魔术方法 ； 感觉一般都是那些权限不允许调用或者是不存在的属性 才会触发魔术方法

PHP 面向对象中, 提供了这几个魔术方法,

他们的特点 都是以双下划线`__`开头的

`__construct()`, `__destruct()`, `__call()`, `__callStatic()`, `__get()`, `__set()`, `__isset()`, `__unset()`, `__sleep()`, `__wakeup()`, `__toString()`, `__invoke()`, `__set_state()` 和 `__clone()`

**__clone()**: 克隆方法, 当对象被克隆时, 将会自动调用

![][20]

**__get() ：**当我们调用一个权限上不允许调用的属性，和不存在的属性时，`__get` 魔术方法会自动调用，并且自动传参，参数值是属性名。酱紫就能避免系统会直接报错, 甚至 fatal error, 通过`__get()` 我们就能自定义用户访问时的处理行为。注意如果是数组形式的话那么这里的 $p 相当于键值（即是下标）

![][21]

流程:

$lily->age-- 无权 -->__get(age);

$lily->friend-- 没有此属性 -->__get('friend');

**__set() ：**当为无权操作的属性赋值时, 或不存在的属性赋值时,`__set()` 自动调用，且自动传 2 个参数 属性 属性值

**![][22]**

**__isset() ：**当用 isset() 判断对象不可见的属性时 (protected/private / 不存在的属性)

会引发 __isset() 来执行

![][23]

![][24]

isset($obj->xyz) 属性为真, 能说明 类声明了一个 xyz 属性吗?

答: 不能，因为 isset($hua->tail)---- 没有 tail 属性 ---->__isset('tail');-à 如果__isset 返回 1 则不能

`__unset()` : 当 用 unset 销毁对象的不可见属性时, 会引发 `__unset()`;

`__call($a,$b)` : 调用不可见 (不存在或无权限) 的方法时, 自动调用；前参数是方法名，后是传参

`__callStatic($a,$b)` ： 是调用不可见的静态方法时, 自动调用.

![][25]

`__call` 是调用不可见 (不存在或无权限) 的方法时, 自动调用

$lisi->say(1,2,3);----- 没有 say() 方法 ----> __call('say',array(1,2,3)) 运行

![][26]

`__autoload()` : 如果调用某个不存在的类, 在报错之前, 系统会调用`__autoload($n)` 函数, 并把 "类名" 自动传给`__autoload` 函数我们自然可以在`__autoload` 里 加载需要的类!

![][27]

**魔术方法的应用**

TP 中设置用户注册的做法： 把表单中接受到的信息，直接付给一个对象的属性，然后

对象 add() 用 sql 语句写到数据库中

![][28]

**具体的思路**

在一个类中设置一个空数组，利用`__set()` 把传进来的值放到数组中，然后利用 add 方法 与数据库交互 ； 酱紫避免了与其他同名属性的冲突

都是使用魔法方法来进行操作

$date = array() 设置一个空数组

implode() ：将数组按值进行分割

array_keys(array,value) ：获得数组中键名并以数组的形式 ； 前者数组名必选 ， 后者数组值可选 ； 只选前者则返回所有键名 ； 两者选返回对应值得键名

2015/7/23

## 重载与重写

**重写 / 覆盖 override:**子类重写了父类的同名方法。只要子类有该方法只调用子类的无论参数是否一致

```php
<?php
//模仿重载的功能
class Circle {
    public function area() {
        $a = func_get_args();
        $num = count($a);
        if ($num == 0) {
            echo '传入参数' . "\n";
        } else if ($num == 1) {
            echo 3.14 * $a[0] . "\n"; //学会利用已有的条件进行分析
            
        } else if ($num == 2) {
            echo $a[0] * $a[1] . "\n";
        }
    }
}  

$c = new Circle();
$c->area();
$c->area(3);  

class P {
    public function a() {
        echo "nihao";
    }
}  

$b = new P();
$b->a(2123, 'sdf');
```

**重载 overload:**指存在多个同名方法, 但参数类型 / 个数不同, 传不同的参数, 调用不同的方法。但是在 PHP 中, 不允许存在多个同名方法. 因此, 不能够完成 java,c++ 中的这种重载

但是, PHP 的灵活, 能达到类似的效果

```php
<?php 
function __autoload($n){
    require('./' . $n . '.php');
    echo "加载成功！";
} 

$test = new autoload_class();
$test->say();
```

## 常量 （常量名全大写，不带 $）

普通常量 ：define('常量名', 常量值); 全局有效. 无论是页面内, 函数内, 类内, 都可以访问 ；

类内常量 : 类常量 在类内用 const 声明即可；前面不用加修饰符,；且权限是 public 的, 即外部也可以访问

作用域在类内，类似于静态属性 ；又是常量, 则不可改.

其实就是 "不可改变的静态属性"，即是能够 类名：：常量名 访问

![][29]

**魔术常量**

1: 无法手动修改他的值, 所以叫常量

2: 但是值又是随环境变动的, 所以叫魔术

`__FILE__` 返回当前文件的路径 + 文件名

在框架开发或者是网站初始化脚本中, 用来计算网站的根目录

`__DIR__` 返回当前的文件路径

`__LINE__` 返回当前的行号

在框架中, 可以用来在 debug 时, 记录错误信息

`__CLASS__` 返回当前的类名

`__METHOD__` 返回当前的方法名

![][30]

**延迟绑定**

注意 ：static：：方法名 表示调用 对象类中的方法 或者属性

注意 一般书写的时候 public 等权限修饰符在 static 前，增加规范可读性

![][31]

## 抽象

抽象类 ：类前加 `abstract` 是抽象类，是抽象方法抽象类 **不能** `new` 来实例化，有抽象方法, 则此类必是抽象类；抽象类，内未必有抽象方法

抽象方法 ：方法前加 `abstract`，抽象方法 不能有方法体，所以没有 `{}` ； 而是直接 `()`;

子类 继承 抽象的父类 必须 重写父类的抽象方法！并且参数个数要一样

// 利用面向对象思想实现不同语言首页欢迎！

// 抽象类就是个模板，你们子类继承我的类和方法自己搞自己想要弄的东西

// 比如我想要开发英语语言，只要增加一个子类，不用修改父类的东西

// 所以面向对象是可插拔的

```php
<?php
//利用面向对象思想实现不同语言首页欢迎！
//抽象类就是个模板，你们子类继承我的类和方法自己搞自己想要弄的东西
//比如我想要开发英语语言，只要增加一个子类，不用修改父类的东西
//所以面向对象是可插拔的
abstract class Language { //抽象方法
    public abstract function wel();
}
class China extends Language {
    public function wel() {
        echo "欢迎！";
    }
}
class English extends Language {
    public function wel($a) {
        echo "Welcome!";
    }
}
$language = 'China';
$w = new $language(); //666
$w->wel();
```

说明 ： 抽象类就是一个模板，我不用担心同类的类不会做，反正你只要根据我的模板做就不会错。从而达到兼容多种不同的情况 和 避免代码大量的修改 和 代码的规范（方法一致）

比如 ：

公司网站要上线了，要选择什么数据库？ 先弄个 mysql 开发着，到时候有问题再换也行。那么换数据库, 会不会以前的代码又得重写? 其实不用担心, 用抽象类！开发者, 开发时, 就以 db 抽象类来开发。不管上线时, 真正用什么数据库，我只需要再写一份如下类 (右图) 即可。所以业务逻辑层不用改，因为都实现的 db 抽象类。

## 接口

    （没有括号） interface 接口名 { }

类如果是一种事物 / 动物的抽象，那么 接口则是事物 / 动物的功能的抽象，即再把它们的功能各拆成小块自由组合成新的物种。

以人类为例, class Human 是人的草图而接口 是零件可以用多种零件组合出一种新特种来.

1、接口本身即是抽象的, 内部声明的方法 默认也是抽象的. 不用加 `abstract`

2、一个类可以一次性实现多个接口. 语法用 `implements` 实现 (把我这几个功能实现了)

3、接口可继承另一个接口, 用 `extends` ；注意实现时须把继承的接口的方

4、接口是一堆抽象方法的说明, 不能加属性

5、接口就是供组装成类用的, 封闭起来没有意义, 因此方法只能是 public

```php
<?php
/*
接口 就更加抽象了，比如一个社交网站，关于用户的处理是核心应用。
登陆 退出 写信 看信 招呼 更换心情
吃饭 骂人 捣乱 示爱 撩骚

这么多的方法,都是用户的方法，可写一个user类,全包装起来
但是，分析用户一次性使不了这么方法。于是分开多个类

用户信息类:{登陆,写信,看信,招呼,更换心情,退出}
用户娱乐类:{登陆,骂人,捣乱,示爱,撩骚,退出}
*/
interface UserBase { //注意没括号
    public function login($u, $p);
    public function logout(); //注意是抽象方法
    
}
interface UserMsg {
    public function wirteMsg($to, $title, $content);
    public function readMsg($from, $title);
}
interface UserFun {
    public function spit($to);
    public function showLove($to);
}
/*
作为调用者, 我不需要了解你的用户信息类,用户娱乐类,
我就可以知道如何调用这两个类

因为: 这两个类 都要实现 上述接口.
通过这个接口,就可以规范开发.

*/
class User implements UserBase {
    public function login($u, $p) {
        echo "用户登录";
    }
    public function logout() {
        echo "用户注销";
    }
}
```

## 包含类进来

include/require 能够包含某个 php 文件，但是不知道是否调用过；改进使用魔术方法`__aotoload($)`

`__autoload()` : 如果调用某个不存在的类, 在报错之前, 系统会调用`__autoload($n)` 函数, 并把 "类名" 自动传给`__autoload` 函数我们自然可以在`__autoload` 里 加载需要的类!

★自定义 自动加载方法

通知系统, 让系统知道 -- 我自己写了一个自动加载方法, 用这个 `spl_auto_register($n)`

![][32]

★方法中能定义一个类，但是想要执行类里面的东西，必须先动态调用方法（直接方法名），有 return 也不关事

![][33]

## 异常

讨论：如何判断 mysql 类连接是否成功？ 利用 在方法里面 return？

实例化后返回一个对象，无法确定是否连接成功 。 return 无法干扰，仍然是返回对象

解决这种问题，用异常类 Exception

注意` @mysql_connect();` //`@表示忽略此处输出的错误`

关闭所有的错误报告 ： Error_reporting(0);

```php 
<?php
class mysql{
    protected $conn = NULL;

    public function __construct()
    {
        $this->conn = mysql_connect('localhost','root','111');

        if (!$this->conn) //如果连接失败了，抛出错误
        {
        $e = new Exception('失败了！',9); // 
        throw $e;  //抛出异常
        }
    }
}
//若抛出异常，没有接受处理则会报错
try  // 可能出现错误的代码并尝试捕捉错误信息
{
    $my = new mysql();
}catch(Exception $e) // 注意括号，处理错误
{
    echo $e->getMessage();
    echo '错误代码',$e->getCode();
    echo '错误文件',$e->getFile();
    echo '错误行',$e->getLine();//抛出错误的行
}
```




[0]: ../img/1715514037.png
[1]: ../img/1333806919.png
[2]: ../img/2089674680.png
[3]: ../img/1361467761.png
[4]: ../img/75183877.png
[5]: ../img/593820088.png
[6]: ../img/1100236576.png
[7]: ../img/602941868.png
[8]: ../img/1445546622.png
[9]: ../img/1211569825.png
[10]: ../img/1858430790.png
[11]: ../img/732052331.png
[12]: ../img/1807163444.png
[13]: ../img/1066463053.png
[14]: ../img/234719294.png
[15]: ../img/1457368639.png
[16]: ../img/2061513836.png
[17]: ../img/248355072.png
[18]: ../img/1166808070.png
[19]: ../img/393187020.png
[20]: ../img/225009126.png
[21]: ../img/25986191.png
[22]: ../img/1116921590.png
[23]: ../img/1388845894.png
[24]: ../img/1949065924.png
[25]: ../img/1622601877.png
[26]: ../img/1319676448.png
[27]: ../img/828385081.png
[28]: ../img/99331093.png
[29]: ../img/2072753831.png
[30]: ../img/1862842902.png
[31]: ../img/68517623.png
[32]: ../img/1293351406.png
[33]: ../img/901317917.png