## PHP FPM源代码反刍品味之一：无限运行程序

2016.07.31 18:02*

来源：[https://www.jianshu.com/p/3bd0aef2f2b7](https://www.jianshu.com/p/3bd0aef2f2b7)


          
## 基础: 无限运行程序.

程序可以简单的分为两种类型:

* 程序启动后,一段时间后,完成了任务,会主动退出,这里称为 **`有限程序`** .
* 程序启动后,会一直运行,不会主动退出,这里称为 **`无限程序`** .


显然,服务器程序如nginx,php-fpm和桌面图形界面(GUI)程序如firefox,word 都属无限程序.

这类程序的共同点是启动后一直运行,如果不出故障,能源足够,且未收到退出指令的情况下,无限程序会永久运行.

服务器程序和图形界面,一个前端,一个后端,相距甚远. 两者内部的核心机制且及其相近.

服务器程序,启动后,等待网络请求, 并做出响应.

图形界面,启动后,等待用户事件,点击或键盘输入等,并做出响应

简单的道理,如果程序运行一段时间后就退出, 就无法响应网络请求或用户事件.

我们简单的想一下,一个程序要如何才能无限运行呢? 再复杂的逻辑,总有计算完成的时候.

直觉告诉我们,程序要无限运行,里面应该有个 **`无限循环`** .

没错服务器程序和图形界面程序都有个无限循环.

程序在无限循环里运行, 如果马不停蹄的飞转, 会独占100%CPU资源,机器不累,看的人都累.

于是我们想到,应该在程序无限循环里歇一歇,最简单的办法就是sleep一下:如下:

```c
while(1){
  process();
  sleep(1);
}

```

这样程序可以一直运行且不独占CPU,很多人都这样做过.

但在正式的产品程序里,这不是个好办法.

首先, sleep时间太短,没意义,sleep时间太长会导致响应缓慢停顿.

还有,sleep 效率也不高.
## 怎么办?

多数服务器程序和图形界面程序在无限循环里,

通常会在对一个对文件句柄(网络连接也是文件)的操作上停一下,收到信息后或超时后继续循环运行.

程序停在那里等待信息,有个专业术语叫 **`阻塞`** (blocking).

操作系统在内核层面上,支持阻塞(blocking)机制, 所以程序阻塞在对IO的操作上,高效且占用的资源很小.

有的程序员说,我开发了很多android应用,没看到哪里有无限循环啊?

主要的原因就android在框架里实现了,对一般开发者不可见,如果你看android框架源码,会在某个地方发现无限循环.

在服务器程序和图形界面程序的另一个很相似的地方就是:事件和事件队列.

通常与事件相关的详细信息和回调函数会包装成一个事件对象,放到事件队列里. (C语言用结构体表示对象)

对文件句柄fd阻塞读取操作(监听)只是个获取个触发信号.

无限循环里,获取和处理队列里的事件.

常见的设计中,定时运行逻辑,会放到一个定时队列里,无限循环时顺带检查定时队列,处理到时的运行逻辑.

以下用一个简单的程序说明:

```c
// simple_event.c
#include <stdio.h>

int  fd= 0;
char event[100];

void wait_event(){
    int length;
    printf("Please input event\n");
    length = read(fd,event,sizeof(event));
    event[length] = 0;
    printf("Recieved event: %s",event);
}

void process_event(){
     printf("Processed event: %s",event);
}

int main() {
    while(1){
        wait_event();
        process_event();
    }
    return 0;
}

```

运行

```
gcc -o  simple_event simple_event.c
./simple_event
Please input event
keyup
Recieved event: keyup
Processed event: keyup
Please input event
click
Recieved event: click
Processed event: click

```

这个很简单的无限程序,确也体现了服务器和图形界面程序的基础结构:
 **`无限循环`** , **`阻塞监听事件`** , **`处理事件`** .

这个程序占用CPU很小,也说明了阻塞操作在无限循环里的重要性.

这个程序和成品无限程序相比,还需要改进:

* 这个程序监听0号文件(fd=0), 也就是标准输入键盘, 成品程序通常会使用pipe或sockpair 创建虚拟文件用于通信. (重复一下,unix下,一切IO设备皆文件)
* 成品程序通常会在循环中加入处理定时任务的逻辑.
* 没有输入的情况下,这个程序会一直阻塞, 无法处理其他任务.


成品程序通常会搭配select (epoll) 使用, 设置阻塞超时时间,以便处理到时的定时任务.

这里的阻塞超时时间，通常依据最近的定时任务的时间来设定。

改良后，循环的大致结构如下：

```c
while(1){
    timeout = get_timeout(timer_task_queue); 依据最近的定时任务
    ready_io_events = wait_io_event(timeout);
    process(ready_io_events);
    process_timer_task()
}

```
## 总结：

无线循环里：

1，获取阻塞超时时间（依据下一个定时任务），

2，阻塞等待IO事件，

3，处理IO事件，

4，处理定时任务。

周而复始，不停运行，这可以说是服务器和图形界面程序设计的一个套路。

了解了这个套路，研究无限程序源代码就不会陌生。

