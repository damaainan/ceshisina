# PHP引用(&)详解

(https://www.zhihu.com/people/phpgod)[舒铭][0]

1 小时前

在PHP 中引用的意思是：不同的名字访问同一个变量内容. 

与Ｃ语言中的指针是有差别的．Ｃ语言中的指针里面存储的是变量的内容在内存中存放的地址 

**变量的引用**

PHP 的引用允许你用两个变量来指向同一个内容 

```php
    <?php
    $a="ABC"; 
    $b =&$a; 
    echo $a;//这里输出:ABC 
    echo $b;//这里输出:ABC 
    $b="EFG"; 
    echo $a;//这里$a的值变为EFG 所以输出EFG 
    echo $b;//这里输出EFG 
    ?>
```
**函数的传址调用**

传址调用我就不多说了 下面直接给出代码 

```php
    <?php
    function test(&$a) 
    { 
    $a=$a+100; 
    } 
    $b=1; 
    echo $b;//输出１ 
    test($b); //这里$b传递给函数的其实是$b的变量内容所处的内存地址，通过在函数里改变$a的值　就可以改变$b的值了 
    echo "<br>"; 
    echo $b;//输出101 
```
要注意的是，在这里test(１);的话就会出错，原因自己去想 

**函数的引用返回**

先看代码 
```php
    <?php
    function &test() 
    { 
    static $b=0;//申明一个静态变量 
    $b=$b+1; 
    echo $b; 
    return $b; 
    } 
    $a=test();//这条语句会输出　$b的值　为１ 
    $a=5; 
    $a=test();//这条语句会输出　$b的值　为2 
    $a=&test();//这条语句会输出　$b的值　为3 
    $a=5; 
    $a=test();//这条语句会输出　$b的值　为6 
```
下面解释下： 

通过这种方式$a=test();得到的其实不是函数的引用返回，这跟普通的函数调用没有区别 至于原因： 这是ＰＨＰ的规定 

ＰＨＰ规定通过$a=&test(); 方式得到的才是函数的引用返回 

至于什么是引用返回呢（ＰＨＰ手册上说：引用返回用在当想用函数找到引用应该被绑定在哪一个变量上面时。) 这句狗屁话 害我半天没看懂 

用上面的例子来解释就是 

$a=test()方式调用函数，只是将函数的值赋给$a而已， 而$a做任何改变 都不会影响到函数中的$b 

而通过$a=&test()方式调用函数呢, 他的作用是 将return $b中的 $b变量的内存地址与$a变量的内存地址 指向了同一个地方 

即产生了相当于这样的效果($a=&b;) 所以改变$a的值 也同时改变了$b的值 所以在执行了 

$a=&test(); 

$a=5; 

以后，$b的值变为了5 

这里是为了让大家理解函数的引用返回才使用静态变量的，其实函数的引用返回多用在对象中 

**对象的引用**

```php
    <?php 
    class a{ 
    var $abc="ABC"; 
    } 
    $b=new a; 
    $c=$b; 
    echo $b->abc;//这里输出ABC 
    echo $c->abc;//这里输出ABC 
    $b->abc="DEF"; 
    echo $c->abc;//这里输出DEF 
    ?>
```
以上代码是在PHP5中的运行效果 在PHP5中 对象的复制 是通过引用来实现的。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&$b; PHP5中默认就是通过引用来调用对象， 但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本 . 为了这样的目的，PHP定义了一个特殊的方法，称为__clone. **引用的作用** 如果程序比较大,引用同一个对象的变量比较多,并且希望用完该对象后手工清除它,个人建议用 "&" 方式,然后用$var=null的方式清除. 其它时候还是用php5的默认方式吧. 另外, php5中对于大数组的传递,建议用 "&" 方式, 毕竟节省内存空间使用。 

**取消引用**

当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。例如：

```php
    <?php 
    $a = 1; 
    $b =& $a; 
    unset ($a); 
    ?>
```
不会 unset $b，只是 $a。 

**global 引用**

当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的： 

```php
    <?php 
    $var =& $GLOBALS["var"]; 
    ?>
```
这意味着，例如，unset $var 不会 unset 全局变量。 $this 在一个对象的方法中，$this 永远是调用它的对象的引用。 

//下面再来个小插曲 

php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。 

通俗的讲 

1:如果有下面的代码 

    $a="ABC"; 

    $b=$a; 

其实此时 $a与$b都是指向同一内存地址 而并不是$a与$b占用不同的内存 

２:如果在上面的代码基础上再加上如下代码 

    $a="EFG"; 

由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断 自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储

[0]: https://www.zhihu.com/people/phpgod