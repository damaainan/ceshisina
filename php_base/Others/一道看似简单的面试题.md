## 一道看似简单的面试题

来源：[https://segmentfault.com/a/1190000015718348](https://segmentfault.com/a/1190000015718348)

![][0]
## 前言

使用PHP,给定一个数,判断这个数是否是二的N次方
这样看似简单的一个面试题, 实际牵出了很多基础知识,本章在为大家补习基础知识的情况下来解答这道题。先亮出答案

```php
function exponentiation($number)
{
    if ($number < 0) {
        return false;
    }
        
    if (($number & ($number - 1)) == 0) {
        return true;
    } else {
        return false;
    }
}
    
exponentiation (2);
exponentiation (8);
exponentiation (16);
exponentiation (32);
exponentiation (128);
```

这是查阅后的最最标准的答案，其他类似通过循环等等答案就略过把。
## 运算

实际这道面试题考的并非是算法，而是作为开发人员的你“底子”够不够。
运算符应该是每门语言hello world 后立马要学习的。运算符分很多种，赋值运算符，比较运算符等等。我想大多自学或者培训出道的没有经过系统化学习的童鞋的，对这块的知识应该很薄弱把。当然赋值、比较什么的很熟悉，因业务基本逃不过这些。但对位运算符，你真的吃透了吗？

这道题的考点一是位运算符的使用，上面说过了本题考察的并非算法，而是你对二进制的了解，而在php中能操作二进制的运算符 **`貌似`**  (我的知识范围内) 只有位运算符
## PHP位运算符 (部分)

本道面试题用到了 & 所以不详解其他的运算符，需要更多了解请移步官方
[http://php.net/manual/zh/lang...][3]

| 运算符 | 附加信息 |
|-|-|
| & | 按位与运算符 |
| ^ | 按位异或运算符 |


## 按位与

按位与以简单易懂的方式来讲就是二进制位不相同的抵消，相同的保留

![][1]

举几个栗子

公式 -> 转为二进制后的公式 -> 二进制结果 -> 十进制结果
```
2 & 3 -> 0010 & 0011 -> 0010 = 2
10 & 7 -> 1010 & 0111 -> 0010 = 2
32 & 70 -> 0100000 & 1000110 -> 0000000 = 0
```
## 按位异或

按位异或以简单易懂的方式来讲就是二进制位相同的抵消，不相同的保留

![][2]

举几个栗子

公式 -> 转为二进制后的公式 -> 二进制结果 -> 十进制结果
```
2 ^ 3 -> 0010 ^ 0011 -> 0001 = 1
10 ^ 7 -> 1010 ^ 0111 -> 1101 = 13
32 ^ 70 -> 0100000 ^ 1000110 -> 1100110 = 102
```
## 进制

借用百度百科上的一段话

二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。
二进制本身就是为2这个数字而使用的，所以说这道面试题直指二进制的使用是没错的。2的n次方则就是

| n | 公式 | 结果 |
|-|-|-|
| 1 | 2 | 2 |
| 2 | 2x2 | 4 |
| 3 | 2x2x2 | 8 |
| 4 | 2x2x2x2 | 16 |


换算成二进制的表格是

| n | 公式 | 结果 |
|-|-|-|
| 1 | 2 | 000010 |
| 2 | 2x2 | 000100 |
| 3 | 2x2x2 | 001000 |
| 4 | 2x2x2x2 | 010000 |


由此看出2的n次方的二进制最高位是1，其余补0，(n&(n-1))==0 并且 n> 0 的情况下必定是2的n次方，为什么要-1呢？在二进制中每一位必须都不相同&后才会得出0，上述已经讲解了&的运算结果。例如十进制的16

```
16 & (16 - 1) = 
010000 & (001111) = 0 
```

不要纠结(n&(n-1))==0 这个公式是怎么来的，作为程序员，我感觉应该把更多时间放到反推上面来，去应证这个公式的正确性。

验证是否是2的n次方，笨的方法就是一直除2，除到最后等于0则就是2的次方，所以公式如上
## 补位

如果是2个二进制进行运算时，计算机会统一位数，例如

```
01
011
<------> 
001
011
```

计算机会将01自动补一位为001去方便运算。
## 正负

在二进制中，第一位为1的是负数，0是正数。如果没有补零的情况下

```
10000000000
01111111111
```

虽然计算后也是0，但它并不是2的n次方，因为第一组二进制是负数。
## 补充

由上述题补充的另外一道题

给定任意数，计算是2的几次方？
```php
function power($number){
    if ($number < 0) {
        return false;
    }
    
    if (($number & ($number - 1)) == 0) {
        
        // 数学不好的,就看下面的方法
        // $number = decbin($number);
        // return (mb_strlen($number)-1);
        // 数学可以的就看下面的方法
        return floor(log($number,2));
    } else {
        return false;
    }
}
```


* 判断是否是2的n次方
* 如果是则将十进制数字转为二进制
* 计算总长度-1获取到是2的几次方,按照0的个数来计算


## 致谢

感谢你看到这里，我也是文中提起的没好好学基础的一名程序员，但当你看到我这篇文章后，希望你也可以提起精神，去重温下基础，对你未来的职业生涯会起作用的。本章内容纯属自己理解，如有出入，请大佬们监督批评，谢谢🙏

[3]: http://php.net/manual/zh/language.operators.bitwise.php
[0]: ../img/bVbd7d0.png 
[1]: ../img/bVbd7ao.png 
[2]: ../img/bVbd7au.png 