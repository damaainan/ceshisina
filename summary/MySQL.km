{"root":{"data":{"id":"bwp53usduy80","created":1567389218925,"text":"MySQL"},"children":[{"data":{"id":"bwp56lxi0280","created":1567389434736,"text":"锁","font-size":24,"layout":null,"color":"#000000","background":"#ffff00"},"children":[{"data":{"id":"bwq99i1nlrs0","created":1567502505769,"text":"分类","layout":null},"children":[{"data":{"id":"bxc9epqy9ow0","created":1569737233403,"text":"按使用方式","note":"**乐观锁与悲观锁是两种并发控制的思想**"},"children":[{"data":{"id":"bxc9er3dsi00","created":1569737236332,"text":"乐观锁"},"children":[]},{"data":{"id":"bxc9etmni1k0","created":1569737241850,"text":"悲观锁","note":"悲观锁是一种思想，它的实现是使用了 共享锁与排他锁来实现的。因此悲观锁本身并不是MySQL实现的锁机制，它是我们造出来的一个概念"},"children":[]}]},{"data":{"id":"bxc9f4p7zh40","created":1569737265950,"text":"按粒度"},"children":[{"data":{"id":"bxc9f6k22cg0","created":1569737269992,"text":"表级锁"},"children":[{"data":{"id":"bxc9fubmrgw0","created":1569737321725,"text":"表共享读锁"},"children":[]},{"data":{"id":"bxc9fwd5b480","created":1569737326170,"text":"表独占写锁"},"children":[]}]},{"data":{"id":"bxc9f97ojuo0","created":1569737275774,"text":"行级锁","note":"InnoDB 实现了两种类型的行锁，共享锁（S）与排他锁（X）。然后由于 InnoDB引擎又支持表级锁，所以它内部又有意向共享锁（IS）与意向排他锁（IX）"},"children":[{"data":{"id":"bxc9g528t1c0","created":1569737345102,"text":"共享锁"},"children":[]},{"data":{"id":"bxc9g88uf0o0","created":1569737352031,"text":"排他锁"},"children":[]}]},{"data":{"id":"bxc9fbfgvd40","created":1569737280598,"text":"页级锁"},"children":[]}]}]},{"data":{"id":"bwq99nbu2kg0","created":1567502517268,"text":"设置","layout":null},"children":[]},{"data":{"id":"bwq99st3w080","created":1567502529196,"text":"原理","layout":null},"children":[]},{"data":{"id":"bwq99v3ncyo0","created":1567502534187,"text":"应用","layout":null},"children":[{"data":{"id":"bxc9jjwu4e00","created":1569737612519,"text":"InnoDB锁算法"},"children":[{"data":{"id":"bxc9jrni3kw0","created":1569737629369,"text":"记录锁"},"children":[]},{"data":{"id":"bxc9jsn9x7k0","created":1569737631532,"text":"gap间隙锁"},"children":[]},{"data":{"id":"bxc9jz8er7s0","created":1569737645871,"text":"next-key锁","note":"**结合了记录锁与间隙锁**\n\nInnoDB对于行的查询加锁是使用的是next-key locking这种算法，一定程度上解决了幻读问题"},"children":[]}]}]},{"data":{"id":"bwq99zwfloo0","created":1567502544635,"text":"难点分析"},"children":[]}]},{"data":{"id":"bwp57e17bhs0","created":1567389495910,"text":"隔离机制","font-size":24,"layout":null,"color":"#000000","background":"#ffff00"},"children":[{"data":{"id":"bwq9a88kcso0","created":1567502562783,"text":"原因"},"children":[{"data":{"id":"bx2247fawdk0","created":1568701062539,"text":"任何支持事务的数据库，都必须具备四个特性，分别是：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)"},"children":[]},{"data":{"id":"bx2265wjs8w0","created":1568701215957,"text":"可能影响"},"children":[{"data":{"id":"bx226e0le680","created":1568701233616,"text":"脏读(dirty read)"},"children":[]},{"data":{"id":"bx226elyy3c0","created":1568701234908,"text":"不可重复读(unrepeatable read)"},"children":[]},{"data":{"id":"bx226f9gkyw0","created":1568701236328,"text":"幻读(phantom problem)"},"children":[]}]}]},{"data":{"id":"bwq9ab2cy200","created":1567502568938,"text":"隔离级别分类"},"children":[{"data":{"id":"bx225p03md40","created":1568701179166,"text":"读未提交(Read Uncommitted)"},"children":[{"data":{"id":"bx227h28xf40","created":1568701318610,"text":"可以读到未提交的内容"},"children":[]}]},{"data":{"id":"bx225pu1n600","created":1568701180977,"text":"读提交(Read Committed) "},"children":[{"data":{"id":"bx227t74odk0","created":1568701345027,"text":"只能读到已经提交了的内容","note":"“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”"},"children":[]},{"data":{"id":"bx228ximi3k0","created":1568701432793,"text":"快照读(Snapshot Read)","note":"那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢?\n \n这就要说道另一个机制“快照(snapshot)”，而这种既能保证一致性又不加锁的读也被称为“快照读(Snapshot Read)”\n\n \n假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。\n \n而“快照读”就可以完成高并发的查询"},"children":[]}]},{"data":{"id":"bx225r9jfa80","created":1568701184090,"text":"可重复读(Repeated Read) "},"children":[{"data":{"id":"bx229ocfle00","created":1568701491192,"text":"门针对“不可重复读”这种情况而制定的隔离级别","note":"它就可以有效的避免“不可重复读”。而它也是**MySql**的默认隔离级别\n\n在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作(Update)”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作(Insert or Delete)”而产生的"},"children":[]}]},{"data":{"id":"bx225ryzft40","created":1568701185629,"text":"串行化(Serializable) "},"children":[{"data":{"id":"bx22at0s0tk0","created":1568701579735,"text":"数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行","note":"这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用"},"children":[]}]}]},{"data":{"id":"bwq9adbcueo0","created":1567502573836,"text":"应用"},"children":[]},{"data":{"id":"bx22bdmek2o0","created":1568701624578,"text":"总结","note":"为什么会出现“脏读”?因为没有“select”操作没有规矩。\n \n为什么会出现“不可重复读”?因为“update”操作没有规矩。\n \n为什么会出现“幻读”?因为“insert”和“delete”操作没有规矩。\n \n“读未提(Read Uncommitted)”能预防啥?啥都预防不了。\n \n“读提交(Read Committed)”能预防啥?使用“快照读(Snapshot Read)”，避免“脏读”，但是可能出现“不可重复读”和“幻读”。\n \n“可重复读(Repeated Red)”能预防啥?使用“快照读(Snapshot Read)”，锁住被读取记录，避免出现“脏读”、“不可重复读”，但是可能出现“幻读”。\n \n“串行化(Serializable)”能预防啥?排排坐，吃果果，有效避免“脏读”、“不可重复读”、“幻读”，不过效果谁用谁知道。"},"children":[]}]},{"data":{"id":"bwp57mk572g0","created":1567389514469,"text":"复制原理","font-size":24,"layout":null,"color":"#000000","background":"#ffff00"},"children":[]},{"data":{"id":"bwp57v5mnsw0","created":1567389533182,"text":"索引原理","font-size":24,"layout":null,"color":"#000000","background":"#ffff00"},"children":[{"data":{"id":"bwq9ahwep6w0","created":1567502583816,"text":"分类"},"children":[]},{"data":{"id":"bwq9amh4sk80","created":1567502593776,"text":"应用"},"children":[]}]},{"data":{"id":"bwp5821inw80","created":1567389548171,"text":"优化","font-size":24,"layout":null,"color":"#000000","background":"#ffff00"},"children":[]}]},"template":"right","theme":"fish","version":"1.4.43"}