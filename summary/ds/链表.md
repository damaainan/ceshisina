* ##### 链表和数组一样，都是一种线性结构

1. 数组是物理地址上一段连续的存储空间。 可以通过下标直接获取元素 当内容超出容量时需要重新定义数组。
1. 链表空间不一定保持联系，为临时分配的。 只能从链表的头部开始一个一个查找 增删的效率高于数组，因为不需要更改内存结构


链表是物理存储单元上非连续的、非顺序的存储结构，不同于栈和队列。链表由一系列节点组成，每个结点包括两个部分：一个是存储数据元素的**`数据域`**，另一个是存储下一个结点地址的**`指针域`**。

由于不必须按顺序存储，链表在插入的时候可以达到`O(1)`的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而`线性表`和`顺序表`相应的时间复杂度分别是`O(logn)`和`O(1)`。使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

#### 节点
节点包含了两部分，一部分是存储数据的元素区域，一部分是指向下一个节点的指针区域，上图中绿色部分表示数据区域，蓝色部分表示指针区域，它们共同构成一个节点。
#### 首尾节点
链表中的第一个节点是首节点，最后一个节点是尾节点。
### 有头链表和无头链表
1. 无头链表是指第一个节点既有数据域，又有指针域，第一个节点既是首节点又是头节点。
1. 有头链表是指第一个节点只有指针域，而没有数据域。通常有头链表的数据域可以存放当前的链表的一些信息。
#### 链表的方法
append， 添加一个新的元素  
insert，在指定位置插入一个元素  
remove，删除指定位置的节点  
get，返回指定索引位置的元素  
print，打印整个链表  

### 链表的分类

###### 按连接方向分类

1. 单链表 每个节点只能通过`next指`针，指向下一个节点。
1. 双链表 除了`next指针`之外，还有一个`prev指针`指向其上一个节点。

###### 按照有无循环分类

1. 普通链表 头无prev，尾无next。
1. 循环链表 首尾相接的链表。 最后一个节点的next指针指向其第一个节点 对于双链表，其第一个节点的prev指针指向最后一个节点。


### 链表问题代码实现的关键点

##### 边界条件的处理

**`头节点`**，**`尾节点`**，**`空节点`**的特殊处理。

### 单链表特点

* 创建单链表时无需指定链表的长度，这个比起数组结构更加有优势，而数组纵使实现成动态数组也是需要指定一个更大的数组长度，而且要把原来的数组元素一个个复制到新数组中。
* 单链表中的节点删除操作很方便，它可以直接改变指针指向来实现删除操作，而某些场景下数组的删除会导致移动剩下的元素。
* 单链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素，而数组则可以使用随机访问，这点算是单链表的缺点。

## 双链表特点

* 创建双链表时无需指定链表的长度。
* 比起单链表，双链表需要**多一个指针**用于指向**前驱节点**，所以需要存储空间比单链表多一点。
* 双链表的插入和删除需要同时维护 **`next`** 和 **`prev`** 两个指针。
* 双链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素。

## 双向循环链表

前面的双向链表的 head 节点和链尾没有连接关系，所以如果要访问最后一个节点的话需要从头开始遍历，直到最后一个节点。在双向链表基础上改进一下，把 header 节点的 prev 指针指向最后一个节点，而最后一个节点的 next 指针指向 header 节点，于是便构成双向循环链表。

