{"root":{"data":{"id":"by9akh0u7eo0","created":1573091984276,"text":"MySQL优化","background":"#92cddc","font-family":"微软雅黑,Microsoft YaHei","font-size":24},"children":[{"data":{"id":"by9aofpegvs0","created":1573092294863,"text":"配置优化","layout":null},"children":[{"data":{"id":"by9k4jkejmg0","created":1573118947084,"text":"通用设置","layout":null},"children":[]},{"data":{"id":"by9k45tougg0","created":1573118917171,"text":"innodb 参数","layout":null},"children":[{"data":{"id":"bz585f65qcw0","created":1576335081174,"text":"innodb_buffer_pool_size","font-weight":"bold","background":"#ffff00","layout":null},"children":[{"data":{"id":"bz585pvy8f40","created":1576335104502,"text":"服务器允许 InnoDB 使用物理内存数量","layout":null},"children":[]},{"data":{"id":"bz585yrr6rk0","created":1576335123839,"text":"公认的“经验法则”是设置为你的服务器物理内存的 80%","layout":null},"children":[]}]},{"data":{"id":"bz585f65qcw0","created":1576335081174,"text":"innodb_buffer_pool_instances","font-weight":"bold","background":"#ffff00","layout":null},"children":[{"data":{"id":"bz586ghv4i00","created":1576335162424,"text":"如果服务器上的参数 innodb_buffer_pool_size 的配置是大于 1 GB 设置该参数","layout":null},"children":[]},{"data":{"id":"bz586lfhvts0","created":1576335173164,"text":"将 InnoDB 的缓冲池划分为多个","layout":null},"children":[]},{"data":{"id":"bz587fx6og00","created":1576335239537,"text":"拥有多于一个的缓冲池的好处有\n在多线程同时访问缓冲池时可能会遇到瓶颈。你可以通过启用多缓冲池来最小化这种争用情况","layout":null},"children":[]},{"data":{"id":"bz589gmr2so0","created":1576335397811,"text":"为了实现最佳的效果，要综合考虑 innodb_buffer_pool_instances 和 innodb_buffer_pool_size 的设置，以确保每个实例至少有不小于 1 GB 的缓冲池","layout":null},"children":[]}]}]}]},{"data":{"id":"bz57ln277j40","created":1576333531066,"text":"查询缓存","layout":null},"children":[{"data":{"id":"bz57rd3tfsw0","created":1576333979581,"text":"不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，\n只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升","font-size":18,"font-weight":"bold","color":"#31849b","background":"#c6d9f1","layout":null},"children":[]},{"data":{"id":"bz57n21h0e00","created":1576333642038,"text":"失效","font-size":16,"font-weight":"bold","color":"#00b050","layout":null},"children":[{"data":{"id":"bz57n7njcbs0","created":1576333654256,"text":"MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效","font-size":16,"layout":null},"children":[]},{"data":{"id":"bz57npulavc0","created":1576333693864,"text":"在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效","font-weight":"bold","font-size":16,"layout":null},"children":[]},{"data":{"id":"bz57nxxears0","created":1576333711448,"text":"如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿","layout":null},"children":[]}]},{"data":{"id":"bz57o5ilgm00","created":1576333727968,"text":"查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外","font-weight":"bold","font-size":16,"layout":null},"children":[{"data":{"id":"bz57oif9e000","created":1576333756064,"text":"任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存","layout":null},"children":[]},{"data":{"id":"bz57oif9uhs0","created":1576333756065,"text":"如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗","layout":null},"children":[]}]},{"data":{"id":"bz57rd3tfsw0","created":1576333979581,"text":"不要轻易打开查询缓存，特别是写密集型应用","font-size":18,"font-weight":"bold","color":"#31849b","background":"#c6d9f1","layout":null},"children":[{"data":{"id":"bz57tit1k7k0","created":1576334148718,"text":"可以将query_cache_type设置为DEMAND，\n这时只有加入SQL_CACHE的查询才会走缓存，\n其他查询则不会，\n这样可以非常自由地控制哪些查询需要被缓存","font-size":16,"layout":null},"children":[]},{"data":{"id":"bz5a4gn94uo0","created":1576340648240,"text":"query_cache_type"},"children":[{"data":{"id":"bz5a4ltxwco0","created":1576340659529,"text":"在配置文件中开启缓存"},"children":[]},{"data":{"id":"bz5a4qz7bo80","created":1576340670731,"text":"0：不开启"},"children":[]},{"data":{"id":"bz5a4qz85dk0","created":1576340670732,"text":"1：开启，默认缓存所有，需要在SQL语句中增加select sql-no-cache提示来放弃缓存"},"children":[]},{"data":{"id":"bz5a4qz8myw0","created":1576340670733,"text":"2：开启，默认都不缓存，需要在SQL语句中增加select sql-cache来主动缓存（==常用==）"},"children":[]}]}]}]},{"data":{"id":"bz57g32ky8w0","created":1576333095733,"text":"查询优化","layout":null},"children":[{"data":{"id":"bz57gidauq00","created":1576333129032,"text":"MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个","font-size":16,"background":"#ffff00","layout":null},"children":[]},{"data":{"id":"bz57gidauq00","created":1576333129032,"text":"有非常多的原因会导致MySQL选择错误的执行计划，\n比如统计信息不准确、\n不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、\nMySQL认为的最优跟我们想的不一样\n（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等","font-size":16,"background":"#ffff00","layout":null},"children":[]},{"data":{"id":"bz57gidauq00","created":1576333129032,"text":"MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划","font-size":16,"background":"#ffff00","layout":null},"children":[{"data":{"id":"bz57juakev40","created":1576333390081,"text":"重新定义表的关联顺序","note":"（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）","layout":null},"children":[]},{"data":{"id":"bz57jyub3n40","created":1576333399982,"text":"优化MIN()和MAX()函数","note":"（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值）","layout":null},"children":[]},{"data":{"id":"bz57k6y4prk0","created":1576333417627,"text":"提前终止查询","note":"（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）","layout":null},"children":[]},{"data":{"id":"bz57kftjoe80","created":1576333436941,"text":"优化排序","note":"在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多","layout":null},"children":[]}]}]},{"data":{"id":"by9aok7frns0","created":1573092304661,"text":"语句优化","layout":null},"children":[{"data":{"id":"bz5a0exwg740","created":1576340331074,"text":"select","layout":null},"children":[{"data":{"id":"bz5a0zzn0gw0","created":1576340376891,"text":"如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据\n（否则只要有一个字段没有建立索引就会做全表扫描），\n这叫索引覆盖","layout":null},"children":[]},{"data":{"id":"bz5a0r8qyaw0","created":1576340357851,"text":"尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率","layout":null},"children":[]}]},{"data":{"id":"by9aorpppeo0","created":1573092321004,"text":"order by","layout":null},"children":[]},{"data":{"id":"by9aow7wzwg0","created":1573092330811,"text":"group by","layout":null},"children":[]},{"data":{"id":"by9ap0h2ouo0","created":1573092340072,"text":"count","layout":null},"children":[{"data":{"id":"bz50y22ay080","created":1576314756324,"text":"当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数\n统计列值时，要求列值是非空的，它不会统计NULL\n如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好","layout":null},"children":[]},{"data":{"id":"byfjankgbfk0","created":1573725964609,"text":"COUNT(*)","layout":null},"children":[{"data":{"id":"byfjb41xi7c0","created":1573726000495,"text":"COUNT(*)是SQL92定义的标准统计行数的语法，并且效率高","font-weight":"bold","color":"#000000","background":"#e36c0a","font-size":16,"layout":null},"children":[]},{"data":{"id":"byfjcnvye740","created":1573726122033,"text":"MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，","layout":null},"children":[]},{"data":{"id":"byfjcnvydwg0","created":1573726122033,"text":"而InnoDB则会在扫表的时候选择最小的索引来降低成本。","layout":null},"children":[]},{"data":{"id":"byfjchbeqao0","created":1573726107730,"text":"这些优化的前提都是没有进行where和group的条件查询","layout":null},"children":[]}]},{"data":{"id":"byfjankgt9k0","created":1573725964610,"text":"COUNT(1)","layout":null},"children":[{"data":{"id":"byfjc1er3ow0","created":1573726073104,"text":"在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样","layout":null},"children":[]}]},{"data":{"id":"byfjankgb5k0","created":1573725964609,"text":"COUNT(字段)","layout":null},"children":[{"data":{"id":"byfjc8idq400","created":1573726088561,"text":"在InnoDB中COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些","layout":null},"children":[]}]},{"data":{"id":"byzc7cr0qrc0","created":1575737157333,"text":"count(*)=count(1)>count(primary key)>count(column)","font-size":16,"background":"#ffff00","color":"#ff0000","font-weight":"bold","layout":null},"children":[]}]},{"data":{"id":"by9apvbd95c0","created":1573092407207,"text":"where","layout":null},"children":[]},{"data":{"id":"by9auywew200","created":1573092806831,"text":"负向查询（>,<,in,not in）","layout":null},"children":[{"data":{"id":"by9awdsk8e00","created":1573092917614,"text":">,<,in,between等等，都是可以使用索引的","background":"#e36c0a","font-size":16,"font-weight":"bold","layout":null},"children":[]},{"data":{"id":"by9axn3ha000","created":1573093016229,"text":"使用IN查询时，数据为相同类型的数据是可以正常使用索引的","layout":null},"children":[]},{"data":{"id":"by9axx0l7jk0","created":1573093037823,"text":"当IN里面嵌套子查询时，不使用索引，用select之后使用了函数内部转换，mysql是不支持函数索引的","layout":null},"children":[]}]},{"data":{"id":"by9av88sk3s0","created":1573092827171,"text":"between","layout":null},"children":[]},{"data":{"id":"bz5111kjl7s0","created":1576314990343,"text":"limit","layout":null},"children":[{"data":{"id":"bz511ma0oao0","created":1576315035419,"text":"一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。\n然后根据需要做一次关联查询再返回所有的列。\n对于偏移量很大时，这样做的效率会提升非常大","layout":null},"children":[]}]},{"data":{"id":"bz512br6in40","created":1576315090876,"text":"UNION","layout":null},"children":[]}]},{"data":{"id":"by9atcr09pc0","created":1573092680251,"text":"explain 解释","layout":null},"children":[{"data":{"id":"by9atvdspeo0","created":1573092720811,"text":"select_type","layout":null},"children":[{"data":{"id":"by9cxksfgm80","created":1573098653428,"text":"SELECT 查询的类型","note":"SIMPLE: 表示此查询不包含 UNION 查询或子查询\n\nPRIMARY: 表示此查询是最外层的查询\n\nUNION: 表示此查询是 UNION 的第二或随后的查询\n\nDEPENDENT UNION: UNION 中的第二个或后面的查询语句, 取决于外面的查询\n\nUNION RESULT: UNION 的结果\n\nSUBQUERY: 子查询中的第一个 SELECT\n\nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\n","layout":null},"children":[]}]},{"data":{"id":"by9au0eik1c0","created":1573092731738,"text":"type","layout":null},"children":[{"data":{"id":"by9cxogyasw0","created":1573098661441,"text":"join 类型","layout":null},"children":[{"data":{"id":"by9cz7e6qg80","created":1573098780997,"text":"ALL < index < range ~ index_merge < ref < eq_ref < const < system","font-weight":"bold","background":"#ffff00","layout":null},"children":[{"data":{"id":"by9fee1zteg0","created":1573105613179,"text":"解释","note":"system : 表中只有一条数据. 这个类型是特殊的 const 类型. \n\nconst : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可\n\neq_ref : 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 = , 查询效率较高\n\nref : 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询\n\nrange : 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中. \n\n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个\n\nindex : 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. \n\nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index\n\nALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一","layout":null},"children":[]}]}]}]},{"data":{"id":"by9au2lnolc0","created":1573092736524,"text":"possible_keys","layout":null},"children":[{"data":{"id":"by9cxrlnv9k0","created":1573098668256,"text":"此次查询中可能选用的索引","note":"possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定","layout":null},"children":[]}]},{"data":{"id":"by9au7eebog0","created":1573092746969,"text":"key","layout":null},"children":[{"data":{"id":"by9cxv1tkvk0","created":1573098675763,"text":"此次查询中确切使用到的索引","layout":null},"children":[{"data":{"id":"by9ffk4d2tk0","created":1573105704747,"text":"此字段是 MySQL 在当前查询时所真正使用到的索引","layout":null},"children":[]}]}]},{"data":{"id":"by9cy14dycg0","created":1573098688979,"text":"ref","layout":null},"children":[{"data":{"id":"by9cy8bexu00","created":1573098704642,"text":"哪个字段或常数与 key 一起被使用","layout":null},"children":[]}]},{"data":{"id":"by9au9xxpe80","created":1573092752504,"text":"key_len","layout":null},"children":[{"data":{"id":"by9fgwj1yq80","created":1573105810121,"text":"查询优化器使用了索引的字节数","note":"这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到\n\nkey_len 的计算规则如下:\n\n* 字符串\n  * char(n): n 字节长度\n  * varchar(n): 如果是 utf8 编码, 则是 3n + 2字节; 如果是 utf8mb4 编码, 则是 4n + 2 字节.\n\n* 数值类型:\n  * TINYINT: 1字节\n  * SMALLINT: 2字节\n  * MEDIUMINT: 3字节\n  * INT: 4字节\n  * BIGINT: 8字节\n\n* 时间类型\n  * DATE: 3字节\n  * TIMESTAMP: 4字节\n  * DATETIME: 8字节\n\n* 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n","layout":null},"children":[]}]},{"data":{"id":"by9auhputpc0","created":1573092769429,"text":"Extra","layout":null},"children":[{"data":{"id":"by9cye1u4880","created":1573098717123,"text":"额外的信息","layout":null},"children":[{"data":{"id":"by9fjcymikg0","created":1573106002619,"text":"Using filesort","note":"当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大","layout":null},"children":[]},{"data":{"id":"by9fjp68ouw0","created":1573106029201,"text":"Using index","note":"\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错","layout":null},"children":[]},{"data":{"id":"by9fjxfaa1s0","created":1573106047162,"text":"Using temporary","note":"查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化","layout":null},"children":[]}]}]}]}]},"template":"right","theme":"fish","version":"1.4.43"}