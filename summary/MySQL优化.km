{"root":{"data":{"id":"by9akh0u7eo0","created":1573091984276,"text":"MySQL优化","background":"#92cddc","font-family":"微软雅黑,Microsoft YaHei","font-size":24},"children":[{"data":{"id":"by9aofpegvs0","created":1573092294863,"text":"配置优化","layout_right_offset":{"x":60,"y":-90}},"children":[{"data":{"id":"by9k4jkejmg0","created":1573118947084,"text":"通用设置"},"children":[]},{"data":{"id":"by9k45tougg0","created":1573118917171,"text":"innodb 参数"},"children":[]}]},{"data":{"id":"by9aok7frns0","created":1573092304661,"text":"语句优化","layout_right_offset":{"x":48,"y":40}},"children":[{"data":{"id":"by9aorpppeo0","created":1573092321004,"text":"order by"},"children":[]},{"data":{"id":"by9aow7wzwg0","created":1573092330811,"text":"group by"},"children":[]},{"data":{"id":"by9ap0h2ouo0","created":1573092340072,"text":"count"},"children":[{"data":{"id":"byfjankgbfk0","created":1573725964609,"text":"COUNT(*)"},"children":[{"data":{"id":"byfjb41xi7c0","created":1573726000495,"text":"COUNT(*)是SQL92定义的标准统计行数的语法，并且效率高","font-weight":"bold","color":"#000000","background":"#e36c0a","font-size":16},"children":[]},{"data":{"id":"byfjcnvye740","created":1573726122033,"text":"MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，"},"children":[]},{"data":{"id":"byfjcnvydwg0","created":1573726122033,"text":"而InnoDB则会在扫表的时候选择最小的索引来降低成本。"},"children":[]},{"data":{"id":"byfjchbeqao0","created":1573726107730,"text":"这些优化的前提都是没有进行where和group的条件查询"},"children":[]}]},{"data":{"id":"byfjankgt9k0","created":1573725964610,"text":"COUNT(1)"},"children":[{"data":{"id":"byfjc1er3ow0","created":1573726073104,"text":"在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样"},"children":[]}]},{"data":{"id":"byfjankgb5k0","created":1573725964609,"text":"COUNT(字段)"},"children":[{"data":{"id":"byfjc8idq400","created":1573726088561,"text":"在InnoDB中COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些"},"children":[]}]}]},{"data":{"id":"by9apvbd95c0","created":1573092407207,"text":"where"},"children":[]},{"data":{"id":"by9auywew200","created":1573092806831,"text":"负向查询（>,<,in,not in）"},"children":[{"data":{"id":"by9awdsk8e00","created":1573092917614,"text":">,<,in,between等等，都是可以使用索引的","background":"#e36c0a","font-size":16,"font-weight":"bold"},"children":[]},{"data":{"id":"by9axn3ha000","created":1573093016229,"text":"使用IN查询时，数据为相同类型的数据是可以正常使用索引的"},"children":[]},{"data":{"id":"by9axx0l7jk0","created":1573093037823,"text":"当IN里面嵌套子查询时，不使用索引，用select之后使用了函数内部转换，mysql是不支持函数索引的"},"children":[]}]},{"data":{"id":"by9av88sk3s0","created":1573092827171,"text":"between"},"children":[]}]},{"data":{"id":"by9atcr09pc0","created":1573092680251,"text":"explain 解释","layout_right_offset":{"x":435,"y":171}},"children":[{"data":{"id":"by9atvdspeo0","created":1573092720811,"text":"select_type"},"children":[{"data":{"id":"by9cxksfgm80","created":1573098653428,"text":"SELECT 查询的类型","note":"SIMPLE: 表示此查询不包含 UNION 查询或子查询\n\nPRIMARY: 表示此查询是最外层的查询\n\nUNION: 表示此查询是 UNION 的第二或随后的查询\n\nDEPENDENT UNION: UNION 中的第二个或后面的查询语句, 取决于外面的查询\n\nUNION RESULT: UNION 的结果\n\nSUBQUERY: 子查询中的第一个 SELECT\n\nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\n"},"children":[]}]},{"data":{"id":"by9au0eik1c0","created":1573092731738,"text":"type"},"children":[{"data":{"id":"by9cxogyasw0","created":1573098661441,"text":"join 类型"},"children":[{"data":{"id":"by9cz7e6qg80","created":1573098780997,"text":"ALL < index < range ~ index_merge < ref < eq_ref < const < system","font-weight":"bold","background":"#ffff00"},"children":[{"data":{"id":"by9fee1zteg0","created":1573105613179,"text":"解释","note":"system : 表中只有一条数据. 这个类型是特殊的 const 类型. \n\nconst : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可\n\neq_ref : 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 = , 查询效率较高\n\nref : 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询\n\nrange : 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中. \n\n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个\n\nindex : 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. \n\nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index\n\nALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一"},"children":[]}]}]}]},{"data":{"id":"by9au2lnolc0","created":1573092736524,"text":"possible_keys"},"children":[{"data":{"id":"by9cxrlnv9k0","created":1573098668256,"text":"此次查询中可能选用的索引","note":"possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定"},"children":[]}]},{"data":{"id":"by9au7eebog0","created":1573092746969,"text":"key"},"children":[{"data":{"id":"by9cxv1tkvk0","created":1573098675763,"text":"此次查询中确切使用到的索引"},"children":[{"data":{"id":"by9ffk4d2tk0","created":1573105704747,"text":"此字段是 MySQL 在当前查询时所真正使用到的索引"},"children":[]}]}]},{"data":{"id":"by9cy14dycg0","created":1573098688979,"text":"ref"},"children":[{"data":{"id":"by9cy8bexu00","created":1573098704642,"text":"哪个字段或常数与 key 一起被使用"},"children":[]}]},{"data":{"id":"by9au9xxpe80","created":1573092752504,"text":"key_len"},"children":[{"data":{"id":"by9fgwj1yq80","created":1573105810121,"text":"查询优化器使用了索引的字节数","note":"这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到\n\nkey_len 的计算规则如下:\n\n* 字符串\n  * char(n): n 字节长度\n  * varchar(n): 如果是 utf8 编码, 则是 3n + 2字节; 如果是 utf8mb4 编码, 则是 4n + 2 字节.\n\n* 数值类型:\n  * TINYINT: 1字节\n  * SMALLINT: 2字节\n  * MEDIUMINT: 3字节\n  * INT: 4字节\n  * BIGINT: 8字节\n\n* 时间类型\n  * DATE: 3字节\n  * TIMESTAMP: 4字节\n  * DATETIME: 8字节\n\n* 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n"},"children":[]}]},{"data":{"id":"by9auhputpc0","created":1573092769429,"text":"Extra"},"children":[{"data":{"id":"by9cye1u4880","created":1573098717123,"text":"额外的信息"},"children":[{"data":{"id":"by9fjcymikg0","created":1573106002619,"text":"Using filesort","note":"当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大"},"children":[]},{"data":{"id":"by9fjp68ouw0","created":1573106029201,"text":"Using index","note":"\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错"},"children":[]},{"data":{"id":"by9fjxfaa1s0","created":1573106047162,"text":"Using temporary","note":"查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化"},"children":[]}]}]}]}]},"template":"right","theme":"fish","version":"1.4.43"}