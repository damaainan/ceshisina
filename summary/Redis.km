{"root":{"data":{"id":"bxc998s9lnc0","created":1569736804657,"text":"Redis"},"children":[{"data":{"id":"bxc9a93roqo0","created":1569736883716,"text":"数据类型","layout":null},"children":[{"data":{"id":"bxc9arjf7e00","created":1569736923845,"text":"字符串 string","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"缓存功能","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"计数器","layout":null},"children":[]},{"data":{"id":"bydt8qb16680","created":1573550905027,"text":"共享用户Session","layout":null},"children":[]}]}]},{"data":{"id":"bxc9au4lbzs0","created":1569736929479,"text":"散列表 hash","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"一般就是可以将结构化的数据，\n比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，\n然后每次读写缓存的时候，可以就操作 Hash 里的某个字段","layout":null},"children":[]}]},{"data":{"id":"bydti8mzxi80","created":1573551650210,"text":"原理","layout":null},"children":[{"data":{"id":"bydtidefuig0","created":1573551660577,"text":"使用 数组 + 链表 的二维结构实现","layout":null},"children":[]}]}]},{"data":{"id":"bxc9aw0rg940","created":1569736933600,"text":"列表 list","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"消息队列","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"文章列表或者数据分页展示的应用","layout":null},"children":[]}]},{"data":{"id":"bydti8mzxi80","created":1573551650210,"text":"原理","layout":null},"children":[{"data":{"id":"bydtidefuig0","created":1573551660577,"text":"使用 链表 实现","layout":null},"children":[]},{"data":{"id":"bydtj5gxgio0","created":1573551721677,"text":"插入删除操作很快，但 索引定位非常慢","layout":null},"children":[]}]}]},{"data":{"id":"bxc9ay7k5kw0","created":1569736938365,"text":"集合 set","layout":null},"children":[{"data":{"id":"bydtaydx4gg0","created":1573551079345,"text":"定义","layout":null},"children":[{"data":{"id":"bydtb4r7t8g0","created":1573551093209,"text":"无序集合，自动去重","layout":null},"children":[]}]},{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[]}]},{"data":{"id":"bxc9uoogwkg0","created":1569738484903,"text":"有序集合 sorted set","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"排行榜","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"带权重的队列","layout":null},"children":[]}]},{"data":{"id":"bydtjif4k5s0","created":1573551749866,"text":"原理","layout":null},"children":[{"data":{"id":"bydtjkr0f4w0","created":1573551754939,"text":"使用 跳表 实现","layout":null},"children":[]}]}]},{"data":{"id":"bxc9v98f6340","created":1569738529645,"text":"高级类型","layout":null},"children":[{"data":{"id":"bxca2qved9s0","created":1569739116589,"text":"bitmap","layout":null},"children":[]},{"data":{"id":"bxca2us2i880","created":1569739125095,"text":"hyperLogLog","layout":null},"children":[{"data":{"id":"byfix38b5yo0","created":1573724901605,"text":"供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV"},"children":[]}]},{"data":{"id":"bydqu43xytk0","created":1573544117391,"text":"BloomFilter","layout":null},"children":[]},{"data":{"id":"bydqu8y5eig0","created":1573544127925,"text":"GeoHash","layout":null},"children":[]},{"data":{"id":"bydsyyw5nd40","created":1573550140077,"text":"Pub/Sub","layout":null},"children":[]},{"data":{"id":"bydsz3454xc0","created":1573550149267,"text":"Redis Module","layout":null},"children":[]},{"data":{"id":"bydsz6uuzrc0","created":1573550157413,"text":"RedisSearch","layout":null},"children":[]},{"data":{"id":"bydszhjy6m80","created":1573550180698,"text":"Redis-ML","layout":null},"children":[]}]},{"data":{"id":"bydtk52z9z40","created":1573551799198,"text":"其他","layout":null},"children":[{"data":{"id":"bydtk7hmxds0","created":1573551804438,"text":"Pipline","layout":null},"children":[]},{"data":{"id":"bydtkcy7hls0","created":1573551816324,"text":"事务","layout":null},"children":[]}]}]},{"data":{"id":"bxc9ahlw5wo0","created":1569736902226,"text":"内部数据结构","layout":null},"children":[{"data":{"id":"bxca4chq5gw0","created":1569739242016,"text":"dict","layout":null},"children":[]},{"data":{"id":"bxca4facqv40","created":1569739248100,"text":"sds","layout":null},"children":[]},{"data":{"id":"bxca4h75hs80","created":1569739252260,"text":"robj","layout":null},"children":[]},{"data":{"id":"bxca4k8lz5s0","created":1569739258879,"text":"ziplist","layout":null},"children":[]},{"data":{"id":"bxca4nmrye80","created":1569739266265,"text":"quicklist","layout":null},"children":[]},{"data":{"id":"bxc9b6ztxnc0","created":1569736957489,"text":"跳跃链表 skip list","layout":null},"children":[]},{"data":{"id":"bxca51zxuuo0","created":1569739297536,"text":"intset","layout":null},"children":[]}]},{"data":{"id":"bxc9vjwklo80","created":1569738552873,"text":"持久化策略","layout":null},"children":[{"data":{"id":"bxc9wg9q9xs0","created":1569738623326,"text":"快照方式持久化RDB","note":"快照方式持久化就是在某时刻把所有数据进行完整备份","layout":null},"children":[{"data":{"id":"bxc9y7trzso0","created":1569738761675,"text":"方式","layout":null},"children":[{"data":{"id":"bydspme90280","created":1573549407596,"text":"对 Redis 中的数据执行周期性的持久化\nRDB做镜像全量持久化","layout":null},"children":[]}]},{"data":{"id":"bxc9ybq5da00","created":1569738770163,"text":"原理","layout":null},"children":[{"data":{"id":"bydt5e4akds0","created":1573550643406,"text":"fork和cow。\nfork是指redis通过创建子进程来进行RDB操作，\ncow指的是copy on write，\n子进程创建后，父子进程共享数据段，父进程继续提供读写服务，\n写脏的页面数据会逐渐和子进程分离开来","layout":null},"children":[]}]},{"data":{"id":"bxc9yehdvkw0","created":1569738776163,"text":"优缺点","layout":null},"children":[{"data":{"id":"bxc9znmtgzc0","created":1569738874447,"text":"1. 生成多个数据文件\n2. 对Redis的性能影响非常小，是因为在同步数据的时候只是fork了一个子进程去做持久化的\n3. 数据恢复的时候速度比AOF快","layout":null},"children":[]},{"data":{"id":"bxc9zu3c7bs0","created":1569738888507,"text":"1. 数据完整性差，容易丢失数据\n2. RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒\n消耗性能","layout":null},"children":[]}]},{"data":{"id":"bydsqilkpu00","created":1573549477696,"text":"RDB更适合做冷备","layout":null},"children":[]}]},{"data":{"id":"bxc9wkfoxnk0","created":1569738632393,"text":"写日志方式持久化AOF","note":"写日志方式持久化就是把用户执行的所有写指令（增删改）备份到文件中，还原数据时只需要把备份的所有指令重新执行一遍即可","layout":null},"children":[{"data":{"id":"bxc9y7trzso0","created":1569738761675,"text":"方式","layout":null},"children":[{"data":{"id":"bydspsrylmo0","created":1573549421485,"text":"对每条写入命令作为日志，\n以 append-only 的模式写入一个日志文件中，\n因为这个模式是只追加的方式，\n所以没有任何磁盘寻址的开销，所以很快，\n有点像Mysql中的binlog\nAOF做增量持久化","layout":null},"children":[]}]},{"data":{"id":"bxc9ybq5da00","created":1569738770163,"text":"原理","layout":null},"children":[]},{"data":{"id":"bxc9yehdvkw0","created":1569738776163,"text":"优缺点","layout":null},"children":[{"data":{"id":"bxca1j2bi080","created":1569739021229,"text":"1. 数据完整性好\n2. 以append-only的方式去写的，只是追加的方式写数据，少了很多磁盘寻址的开销，写入性能好，文件也不容易破损\n3. AOF的日志是通过一个叫非常可读的方式记录的，易恢复","layout":null,"note":"AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据"},"children":[]},{"data":{"id":"bxca0t6o7c00","created":1569738964896,"text":"1. 文件体积大\n2. 速度慢，AOF开启后，Redis支持写的QPS会比RDB支持写的要低","layout":null},"children":[]}]},{"data":{"id":"bydsqm4tvcw0","created":1573549485390,"text":"AOF更适合做热备","layout":null},"children":[]}]},{"data":{"id":"bydsqu35swo0","created":1573549502704,"text":"两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的","color":"#000000","layout":null},"children":[]}]},{"data":{"id":"bxc9vs2iuko0","created":1569738570647,"text":"缓存过期策略","layout":null},"children":[{"data":{"id":"bydsfo2cvs00","created":1573548627588,"text":"定期删除","layout":null},"children":[{"data":{"id":"bydsgo2cqxc0","created":1573548705952,"text":"默认 100ms 就随机抽一些设置了过期时间的key，\n去检查是否过期，过期了就删了","layout":null},"children":[]}]},{"data":{"id":"bydsfszz9vk0","created":1573548638329,"text":"惰性删除","layout":null},"children":[{"data":{"id":"bydsh6lsdj40","created":1573548746310,"text":"不主动删，等来查询了看看过期没，\n过期就删了并且不返回，没过期该怎么样就怎么样","layout":null},"children":[]}]},{"data":{"id":"bydsmgo83xc0","created":1573549160046,"text":"LRU","background":"#92d050","font-weight":"bold","font-size":18,"layout":null},"children":[{"data":{"id":"bydsmik31vk0","created":1573549164149,"text":"Least recently used，最近最少使用","background":"#ffff00","font-weight":"bold","layout":null},"children":[]},{"data":{"id":"bydso4nzplc0","created":1573549290638,"text":"redis 采用近似 LRU 算法","font-weight":"bold","layout":null},"children":[]},{"data":{"id":"bydsoldqhk80","created":1573549327024,"text":"真实的LRU实现是需要太多的内存","layout":null},"children":[]}]}]},{"data":{"id":"bydshtd9bug0","created":1573548795860,"text":"内存淘汰机制","layout":null},"children":[{"data":{"id":"bydtmew2eyw0","created":1573551977276,"text":"缓存过期策略没有生效，大量 key 堆积，走内存淘汰机制","background":"#c0504d","font-weight":"bold","font-size":16,"layout":null},"children":[]},{"data":{"id":"bydsi5uu5uw0","created":1573548823044,"text":"noeviction","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsj5pe1zc0","created":1573548901079,"text":"当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用","layout":null},"children":[]}]},{"data":{"id":"bydsi752w2g0","created":1573548825840,"text":"allkeys-lru","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjayxepc0","created":1573548912540,"text":"当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）","layout":null,"font-weight":"bold","background":"#ffff00"},"children":[]}]},{"data":{"id":"bydsi7rt2iw0","created":1573548827215,"text":"volatile-lru","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjivdx340","created":1573548929740,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，移除最近最少使用的 key\n（这个一般不太合适）","layout":null},"children":[]}]},{"data":{"id":"bydsi8enob40","created":1573548828596,"text":"allkeys-random","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjnm38x40","created":1573548940062,"text":"当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，一般没人用。\n为啥要随机，肯定是把最近最少使用的 key 给干掉啊","layout":null},"children":[]}]},{"data":{"id":"bydsi92kwz40","created":1573548830043,"text":"volatile-random","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjrwewfc0","created":1573548949393,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，随机移除某个 key","layout":null},"children":[]}]},{"data":{"id":"bydsioyjsg80","created":1573548864627,"text":"volatile-ttl","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjy9z7bk0","created":1573548963274,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，有更早过期时间的 key 优先移除","layout":null},"children":[]}]}]},{"data":{"id":"bxc9aeyhqhs0","created":1569736896458,"text":"应用","layout":null},"children":[{"data":{"id":"bxc9b1kmtm00","created":1569736945686,"text":"缓存","layout":null},"children":[]}]},{"data":{"id":"bxca7qq0nzc0","created":1569739508084,"text":"安装","layout":null},"children":[{"data":{"id":"bxca7uuks880","created":1569739517067,"text":"Linux","note":"安装配置","layout":null},"children":[]},{"data":{"id":"bxca7wywbq80","created":1569739521682,"text":"windows","layout":null},"children":[]}]}]},"template":"right","theme":"fish","version":"1.4.43"}