# (9)TCP/IP协议-UDP


## 一、引言

UDP(User Datagram Protocol 用户数据包协议)是一个简单的面向数据包的运输层协议。进程的每一次输出操作都正好产生一个UDP协议（有长度限制）。这是面向流字符协议不同。UDP协议是封装在IP数据包中的。UDP不提供可靠性：它把应用程序传给 I P层的数据发送出去，但是并不保证它们能到达目的地。

## 二、UDP结构

![][1]



图1. UDP结构

* 源端口号：长度2字节，标识该数据包来至于源主机的哪个端口；
* 目的端口号：长度2字节，标识该数据包目的主机端口号；
* UDP长度：长度2个字节，指明是UDP首部和UDP数据的字节长度,单位字节长度；该字段的最小值为 8字节（发送一份0字节的UDP数据包是OK的）。这个UDP长度是有冗余的。IP数据包长度指的是数据包全长，因此UDP数据报长度是全长减去IP首部的长度。
* UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部。UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地。

![][2]



图2. UDP校验和技术过程中的结构


**> 说明**  
_>  由于IP层已经把IP数据包分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。_

## 三、IP分片

物理网络层一般要限制每次发送数据帧的最大长度。当要发送的数据长度大于了最大长度（MTU），就要对数据进行分片处理传输。  
把一份IP数据包分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层(TCP与UDP)是透明的，除了某些可能的越级操作外。

![][3]



图3.IP数据包结构

* 16位标识字段（Identity）：对于发送端发送的每份IP数据包来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中。
* 3位标志字段（flag）：标志字段用最后一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置 1。中间比特为“不分片”位。如果将这一比特置 1，IP将不对数据报进行分片。
* 13位片偏移字段（offset）：该片偏移原始数据包开始处的位置。另外，当数据包被分片后，每个片的总长度值要改为该片的长度值。

抓包，执行如下PHP代码：

```php
    <?php
    $handle = stream_socket_client("udp://110.12.15.10:9999", $errno, $errstr);
    if( !$handle ){    
          die("ERROR: {$errno} - {$errstr}\n");
    }
    $str = 'start';
    for($i=0;$i<500;$i++){    
          $str .= 'abcdefjhijklmnopkrstuvwxyz1234567890';
    }
    $str .= 'end';
    fwrite($handle, $str."\n");
```
![][4]



图4.IP分片抓包

  
如上一个udp数据被分成了3个ip数据包。

[1]: ./img/301894-dcfad9847090577a.png
[2]: ./img/301894-b4a32c00136be9da.png
[3]: ./img/301894-54f6bfb0951a452a.png
[4]: ./img/301894-6ecf9fee9d929489.png