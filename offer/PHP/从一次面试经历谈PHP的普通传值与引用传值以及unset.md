## 从一次面试经历谈PHP的普通传值与引用传值以及unset

来源：[https://www.cnblogs.com/nixi8/p/4925094.html](https://www.cnblogs.com/nixi8/p/4925094.html)

2015-10-31 10:36


关于这个概念一般都会在PHP的第一堂课说变量的时候给介绍,并且我以前还给其他PHPer介绍这个概念。但是作为一个工作一段时间的PHPer的我,竟然在面试的时候一下子拿不定主意最后还答错了，很觉得丢脸（下面我会一一道来），所以就写一篇关于这个概念的博文，该概念在PHP面试中也算是常考的题吧；


首先,要理解变量名存储在内存栈中,它是指向堆中具体内存的地址,通过变量名查找堆中的内存;

普通传值,传值以后,是不同的地址名称,指向不同的内存实体;

引用传值,传引用后,是 **`不同的地址名称,但都指向同一个内存实体;改变其中一个,另外一个就也被改变;`** 

以下我将通过三个列子来详细讲解这两个传值的区别:

Example1：

```php
<?php
//普通传值
$param1=1; 
$param2=2; 
$param2 = $param1; 
$param1 = 5; //变量1和变量2是两块内存,互不影响;
echo $param2; //所以此处还是显示为1

//引用传值 ↓↓
$param1=1; 
$param2=2; 
$param2 = &$param1; //把变量1的内存地址赋给变量2;此时的变量2和变量1全等;
echo $param2;// 1
$param1 = 5; //变量1和变量2是一处内存,改变其中一个,另外一个也被改变;
echo $param2; //显示为5
?>
```

Example2:

```php
<?php
//函数中的普通传值 ↓↓
$param1 = 1; 
function add($param2){
  $param2=3; 
}
$param3=add($param1); //调用方法add，并将变量1传给变量2,此处是普通传值,所以变量1和变量2是两处内存,互不影响;
echo '<br/>$param1=='.$param1.'<br/>'; //显示为$param1==1
echo '<br/>$param2=='.$param2.'<!-- <br/> -->'; //显示为$param2== 因为$param2是局部变量，函数运行完了以后就自动销毁,其不能影响全局

//函数中的引用传值 ↓↓ 注意,php不建议这样使用,并且php.in里面设置其会报错;
$param1 = 1; 
function add($param2){
  $param2=3; 
  return $param2;
}
$param3=add(&$param1); //调用方法add，并将变量1的引用传给变量2,此时两个地址指向同一内存,改变其中一个,另外一个也要被改变;
echo $param1; //3,内存已在函数内部改变;
echo $param3; //3 
?>
```

Example3:

```php
<?php
//给数组里面的键值各增加10;
$arr = array(3,5);

foreach($arr as $k=>$v){
 $v+=10;//1.更改无效,相当于遍历出的键值扔给变量$v,然后更改变量$v的值,跟数组无关;
 echo $v." ";//输出13 15;
}

foreach($arr as $k=>$v){
  $arr[$k]+=10;//2.更改有效,直接更改键名里面的值;
  echo $v;//输出3,5;
 }  

foreach($arr as &$v){
  $v+=10;//3.更改有效,遍历的键值直接给了$v的地址,这个地址其实就是键名..$v+10就等于$arr[$k]+10;
} 
?>
```

然后我们来看一下这道面试题:

```php
$a = 1;
$b = &$a;
unset($a);
echo $b; //??
```

```
当时我的回答是这样的: 会报一个notice的错误,因为$b和$a共用一处内存,unset就把这处内存销毁掉了,然后输出$b变量的时候找不内存,所以应该是Notice:  Undefined variable: b in
```
 **`但是要注意: unset并没有真正销毁变量的作用...仅仅是切断了变量与内存之间的关系，内存只要还被引用着就不会被释放;`**  $b和$a同时指向1,切断其中$a的关系,$b还是指向1,所以上题不报错,照样输出1。

另外补充一点： 在PHP中对象的传值默认是引用传值

再看一题：

在做这题之前我们回顾一下什么是析构函数，而PHP中对象销毁的方式有哪些：
 **`析构函数`** ：对象销毁时执行;注意在隐式销毁中是在是所有php代码执行完最后一行代码的时候才销毁,还有要注意在单入口文件下的MVC模式
 **`对象的销毁`** ：


* 显试销毁: 当对象没有被引用时就会被销毁,所以我们可以unset或为其赋值NULL;
* 隐试销毁:PHP是脚本语言,在代码执行完最后一行时,所有申请的内存都要释放掉.


Example1：

```php
class Human { 
  public $name = '张三'; 
  public $gender = null; 
  public function __destruct() { 
      echo '死了!<br/>'; 
  } 
} 
$a = new Human(); 
$b = $c = $d = $a;
unset($a);  
echo '<hr />';  //析构函数究竟是触发了几次,是在线上触发,还是在线下触发?
```

答案:

```
$b = $c = $d = $a;默认引用传值,四个变量指向同一处内存，unset的时候对象还是被还是其它三个变量使用，所以对象并没有被销毁，所以析构函数是在线下触发的（代码执行完了，内存自动释放）
```

Example2：

```php
class Human { 
  public $name = '张三'; 
  public $gender = null; 
   
  public function __destruct() { 
      echo '死了!<br/>'; 
  } 
} 
$e = $f = $g = new Human(); 
unset($e); 
unset($f); 
unset($g); 
echo '<hr />'; //同样的问题: 析构函数是在线上触发还是线下触发?
```

我相信通过Example1的讲解,应该很快知道答案是在线上触发;在代码运行完自动释放内存之前由于对象已经没有被任何变量引用所以就自动释放了内存....

最后:


其实这家面试是我第一家面试，各方面都还挺满意的，也谈妥了；但是我还是很想多面试几家，并不是为了去比价或者怎么的，很多时候我认为在面试中其实可以学到很多东西的。现在的人事小姐真的是巨能说话，架不住她的那种气场就答应早点上班了，真心想多面试几家～～唉！

