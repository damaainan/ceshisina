## [八年phper的高级工程师面试之路](https://zhuanlan.zhihu.com/p/27493130)

<font face=微软雅黑>

这是一篇反面教材，希望也能引起部分程序员的警惕。

最近半个月时间，经过几次面试，差不多已经对自己有了定位————距离腾讯T3岗位还是有一点距离。

因为在一家小公司呆的习惯了（6年），公司没有人在技术层面超过我，作为技术核心，感觉自己很牛，活在一个小圈子里面，几乎不会主动去了解新技术，甚至对php以及js本身都不能算精通。

所以变故出现的时候，我才发现自己的技术脱节有多厉害，虽然之前的面试并没有做专门的准备，但是与6年前找工作的情形相比，差距非常的大。

下面是我整理的一部分遇到的面试题，我尽量用我所知道的知识来进行陈述，肯定会有很多误解以及遗漏，希望大家能够指正。

## 公司1：

#### 1、mysql_real_escape_string mysql_escape_string有什么本质的区别，有什么用处，为什么被弃用？

答：`mysql_real_escape_string`需要预先连接数据库，并可在第二个参数传入数据库连接（不填则使用上一个连接）

两者都是对数据库插入数据进行转义，但是`mysql_real_escape_string`转义时，会考虑数据库连接的字符集。

它们的用处都是用来能让数据正常插入到数据库中，并防止`sql注入`，但是并不能做到100%防止sql注入。

再问：为什么不能100%防止？

答；因为客户端编码以及服务器端编码不同，可能产生注入问题，但是其实这种场景不多见。

继续答：被弃用的原因是官方不再建议使用mysql_xx的数据库操作方式，建议使用pdo和mysqli，因为不管从性能跟安全来看，mysqli都比mysql要好。

衍生出来的问题是 **mysqli的连接复用（持久化）**问题，这一块我并没有答好。



#### 2、什么是内存泄漏，js内存泄漏是怎么产生的？

答：内存泄漏是因为一块被分配内存既不能被使用，也不能被回收，直到浏览器进程结束。

产生泄漏的原因是闭包维持函数内局部变量，不能被释放，尤其是使用闭包并存在外部引用还`setInterval`的时候危害很大。

备注：我觉得这块回答并不好，因为肯定不是闭包的原因。

我查了一下资料，从比较浅的方位来再回答一下这个问题：

产生泄漏的原因有好几种：

(1) 页面元素被删除，但是绑定在该元素上的事件未被删除；

(2) 闭包维持函数内局部变量（外部不可控），使其得不到释放；

(3) 意外的全局变量；

(4) 引用被删除，但是引用内的引用，还存在内存中。

从上述原因上看，内存泄漏产生的根本原因是引用无法正确回收，值类型并不能引发内存泄漏。

对于每个引用，都有自己的引用计数，当引用计数归零或被标记清除时，js垃圾回收器会认为该引用可以回收了。



#### 3、什么是闭包，跟原型链、作用域链有什么关联

答：闭包是指存在于一个作用域链分支的函数域内的函数，该函数可以向上逐级访问作用域链上的变量，直到找到为止。当闭包存在外部引用时，js会维持闭包自身以及所在函数作用域链的内存状态。

备注：这个是我自己瞎说的。

继续答：跟原型链没有什么关联，函数的原型（`prototype`）主要用于实现继承，原型链可用于追溯继承关系，与作用域链类似，都是向上逐级访问属性，直到被找到，原型链的顶层是null，可以理解为所有的`object`都继承至null，所以null的类型是`object`。

继续答：作用域链可以看作是一个树形结构，由根节点`window`向下扩散，下层节点可以访问上层节点，但是上层节点无法访问下层节点，产生闭包的函数作用域属于节点中的一个，向下扩散后闭包函数产生叶子节点，叶子节点之间可以互相访问，当访问的变量在叶子节点中无法找到时，向上层节点查找，直到被找到为止，这个概念有点类似原型链上的属性查找。



#### 4、一台电脑配置无限好，可以同时打开多少个网页

答：65535-1000 = 64535（端口数）



#### 5、ip地址能被伪造吗？

答：http头部可以被篡改，但是只能修改`X_FORWARDED_FOR`，真实ip地址（`REMOTE_ADDR`）很难修改（除非是路由器去修改），因为真实ip是底层会话ip地址，而且因为TCP 3次握手的存在，连接无法建立，伪造的意义不大，至于UDP的话，一般是内网才使用UDP通信。



#### 6、有100万个奖品，每个人可以中奖3次，先到先得，怎么控制并发，不能发超，并保证完全的先到先得模式

答：百万奖品在打乱后预先insert到数据库，所有中奖操作，均只能update，不能insert。进来抽奖的用户使用memcahe原子加锁，实现抽奖次数自增，当抽奖次数到达3时，返回不中奖。

再问：预先插入需要很多资源，如果奖品数量上了1亿怎么办？

答：使用redis队列存储请求，跑守护进程异步发奖，产生的问题是用户无法实时看到中奖情况。

再问：这样肯定不行。

再答：使用全局内存加锁确保抽奖过程是单进程在跑，但是会面临大并发阻塞问题。

再问：内存比较宝贵，在不用内存加锁的情况下怎么办，并且如果碰到1亿奖池的情况，预先插入数据库肯定不好，怎么办？

答：设置奖品概率，分三张表，都使用innodb引擎，一张存中奖记录（预先插入一行），一张存奖品发放概况，一张存用户抽奖情况（uin唯一索引），大并发情况下，利用mysql的排他锁进行并发控制。流程如下：

begin

查询用户抽奖次数，加排他锁

对用户抽奖次数的更新/插入

锁行查询发放情况

获得抽奖结果（某些奖品发完之后，动态变更概率）

更新发放表

插入中奖记录

commit

再问：遇到脏读怎么办？

答：这方面不是很了解

再问：innodb的master线程在什么情况下fork其他子线程？

答：不知道



#### 7、数据链路层的数据是怎么校验的，有哪些校验方式？

答：crc32，别的校验可能是取模校验奇偶数吧。

备注：答个crc校验就行了。



#### 8、b+树的查询时间复杂度是多少，哈希表是多少，为什么数据库索引用b+树存储，而不是哈希表，数据库索引存储还有其他数据结构吗？

答：`O(log(n))`，O(1)

因为哈希表是散列的，在遇到`key`>'12'这种查找条件时，不起作用，并且空间复杂度较高。

备注：b+数根据层数决定时间复杂度，数据量多的情况下一般4-5层，然后用二分法查找页中的数据，时间复杂度远小于log(n)。



#### 9、apache是怎么跟php通讯的，sapi是什么

答：使用**`sapi通讯`**， **sapi**是php封装的对外数据传递接口，通常有`cgi`/`fastcgi`/`cli`/`apache2handler`四种运行模式。



#### 10、php的垃圾回收机制？

答：垃圾回收是指当php运行状态结束时，比如遇到了exit/die/致命错误/脚本运行结束时，php需要回收运行过程中创建的变量、资源的内存。

ZEND引擎维护了一个栈zval，每个创建的变量和资源都会压入这个栈中，每个压入的数组结构都类似：`[refcount => int, is_ref => 0|1, value => union, type => string]`，变量被`unset`时，`ref_count`如果变成0，则被回收。

当遇到变量循环引用自身时，使用同步回收算法回收。

备注：PHP7已经重写了zal的结构体。



#### 11、jquery的sizzle引擎工作原理

答：除了直到是DOM元素查找引擎之外，一无所知。



#### 12、seajs的工作原理，如何解决重复加载库的问题，如何进行资源的同步加载

答：建立映射关系并缓存起来；资源并不能真正同步加载，只是返回一个回调。



#### 13、memcache跟redis的区别

答：可存储数据结构不同；redis支持持久化存储。



#### 14、md5逆向原理

答：先用字典查找，再尝试暴力破解。

再问：没有更好的方法了吗？

答：没有了。

备注：嗯，事实上也确实没有特别好的办法，只能使用TB级的海量特征库用数据库存起来，然再分片查找。



#### 15、父类方法是protected，子类重构为private，会发生什么？

答：会发生fatal错误，因为继承的方法或属性只能维持或放大权限，不能缩小，比如`protected`重载为`public`是可行的。



#### 16、一个网页从输入地址回车，到完整展示网页内容这段时间里，做了哪些工作，越详细越好。

答：

0、浏览器本地缓存匹配；



1、本地hosts映射对比;



2、本地dns缓存解析；



3、远程dns解析获得服务器ip地址；



4、浏览器发送tcp连接请求包(syn)；



5、请求包经过传输层、网络层、数据链路层封装通过网卡到达路由器；



6、路由器转发数据包到所属运营商服务器；



7、运营商服务器通过寻址最短路径通过中继节点到达指定ip地址；



8、服务器端可能存在反向代理或者负载均衡，都是直接转发请求至上游服务器，当然也可以制定安全防御规则直接丢弃请求包；



9、上游服务器收到连接请求，在自身可用的情况下，返回(syn+ack)；



10、浏览器校验ack，再次发送(syn+ack)；



11、服务器校验ack切换连接状态至established，然后根据请求传输数据包；



12、当transform-encoding为chunked时，浏览器开始渲染页面；



13、四次挥手，连接关闭；



14、渲染数据完成。



备注：还有很多东西不懂，一些东西完全是自己瞎蒙的，因为时间原因，以后有时间详细画一下。



#### 17、keep-alive的概念

答：长连接机制，表示`keep-alive-timeout`时间内，如果连接没有`closed`，再次传输数据不再需要三次握手了。

备注：这里也有很多疑问，需要好好捋一捋。



#### 18、linux文件压缩操作命令，shell脚本等



备注：因为平时开发都是在windows环境，对linux了解不足，这一块几乎是0分。



## 公司2：

这个是被鄙视最惨的一家了，首先会有笔试，相对来说并不复杂，但是有些坑，很多已经忘记了。

印象深刻的是我说自己熟悉常用设计模式，然后让我画UML类图，我就懵逼了，所以在写简历的时候，最好是写自己非常熟悉的，如果只是一知半解，并没有必要放到简历中。



## 公司3：

这里仅列举几个问到的问题：

#### 1、设计一个中继服务器，转发客户A->客户B的请求；

#### 2、myisam跟innodb有什么区别；

#### 3、php进程死锁产生的原因是什么？怎么自动排查与自动恢复？

#### 4、有class A { public function b($a, $b, $c){}};

怎么使用`['b' => 2, 'a' => 1, 'c' => 3]`，对进行A::b进行调用，并顺利赋值？

#### 5、php5.2->php7.1的各版本演进历史，新增特性等？

#### 6、画一个tcp三次握手图



目前还在找工作中，在我看来8年的程序员怎么也不应该是这样子的，温水煮青蛙的教训非常惨痛，好在现在认识到问题还不晚，等到了35岁这个年纪，可能就真的晚了。

</font>