## 搞定PHP面试 - 运算符知识点整理

来源：[https://segmentfault.com/a/1190000016281794](https://segmentfault.com/a/1190000016281794)


## 一、[算术运算符][0]

### 1. 概览
| 例子 | 名称 | 结果 |
| - | - | - |
| $a + $b | 加法 | $a 和 $b 的和。 |
| $a - $b | 减法 | $a 和 $b 的差。 |
| $a * $b | 乘法 | $a 和 $b 的积。 |
| $a / $b | 除法 | $a 除以 $b 的商。 |
| $a % $b | 取余 | $a 除以 $b 的余数。 |
| -$a | 取反 | $a 的相反数。 |


### 2. TIPS

除法运算符总是返回浮点数。只有在下列情况例外：两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一个整数。

取模运算符的操作数在运算之前都会转换成整数（除去小数部分）。

取模运算符 % 的结果和被除数的符号（正负号）相同。即 $a % $b 的结果和 $a 的符号相同。例如：

```php
echo (5 % 3)."\n";        // prints 2
echo (5 % -3)."\n";        // prints 2
echo (-5 % 3)."\n";        // prints -2
echo (-5 % -3)."\n";       // prints -2
```
## 二、[位运算符][1]

### 1. 概览
| 例子 | 名称 | 结果 |
| - | - | - |
| $a & $b | And（按位与） | 将把 $a 和 $b 中都为 1 的位设为 1。 |
| $a | $b | Or（按位或） | 将把 $a 和 $b 中任何一个为 1 的位设为 1。 |
| $a ^ $b | Xor（按位异或） | 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。 |
| ~ $a | Not（按位取反） | 将 $a 中为 0 的位设为 1，反之亦然。 |
| $a << $b | Shift left（左移） | 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。 |
| $a >> $b | Shift right（右移） | 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。 |


### 2. TIPS

位移在 PHP 中是数学运算。
向任何方向移出去的位都被丢弃。
左移时右侧以零填充，符号位被移走意味着正负号不被保留。
右移时左侧以符号位填充，意味着正负号被保留。
 **`使用位运算符时要特别注意优先级。`** 例如 ：
`$a & $b == true`先进行比较再进行按位与；
`($a & $b) == true`则先进行按位与再进行比较。
## 三、[比较运算符][2]

### 1. 概览
| 例子 | 名称 | 结果 |
| - | - | - |
| $a == $b | 等于 | TRUE，如果类型转换后 $a 等于 $b。 |
| $a === $b | 全等 | TRUE，如果 $a 等于 $b，并且它们的类型也相同。 |
| $a != $b | 不等 | TRUE，如果类型转换后 $a 不等于 $b。 |
| $a <> $b | 不等 | TRUE，如果类型转换后 $a 不等于 $b。 |
| $a !== $b | 不全等 | TRUE，如果 $a 不等于 $b，或者它们的类型不同。 |
| $a < $b | 小与 | TRUE，如果 $a 严格小于 $b。 |
| $a > $b | 大于 | TRUE，如果 $a 严格大于 $b。 |
| $a <= $b | 小于等于 | TRUE，如果 $a 小于或者等于 $b。 |
| $a >= $b | 大于等于 | TRUE，如果 $a 大于或者等于 $b。 |
| $a <=> $b | 太空船运算符（组合比较符） | 当$a小于、等于、大于$b时 分别返回一个小于、等于、大于0的integer 值。 PHP7开始提供 |
| $a ?? $b ?? $c | NULL 合并操作符 | 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP7开始提供。 |


### 2. TIPS

如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。此规则也适用于 switch 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对。

```php
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // 永远不会到达a，因为 "a" 已经与 0 匹配
    echo "a";
    break;
}
?>
```
### 3. 对于多种类型，比较运算符根据下表比较（按顺序）
| 运算数1类型 | 运算数2类型 | 结果 |
| - | - | - |
| null 或 string | string | 将 NULL 转换为 ""，进行数字或词汇比较 |
| bool 或 null | 任何其它类型 | 转换为 bool，FALSE < TRUE |
| object | object | 内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP 4 中），PHP 5 有其自己的说明 |
| string，resource 或 number | string，resource 或 number | 将字符串和资源转换成数字，按普通数学比较 |
| array | array | 具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较（见下例） |
| object | 任何其它类型 | object 总是更大 |
| array | 任何其它类型 | array 总是更大 |


### 4. 松散比较表
| \ | 1 | 0 | -1 | "1" | "0" | "-1" | NULL | array() | "php" | "" |
| - | - | - | - | - | - | - | - | - | - | - |
| TRUE | √ | × | √ | √ | × | √ | × | × | √ | × |
| FALSE | × | √ | × | × | √ | × | √ | √ | × | √ |
| 1 |  | × | × | √ | × | × | × | × | × | × |
| 0 |  |  | × | × | √ | × | √ | × | √ | √ |
| -1 |  |  |  | × | × | √ | × | × | × | × |
| "1" |  |  |  |  | × | × | × | × | × | × |
| "0" |  |  |  |  |  | × | × | × | × | × |
| "-1" |  |  |  |  |  |  | × | × | × | × |
| NULL |  |  |  |  |  |  |  | √ | × | √ |
| array() |  |  |  |  |  |  |  |  | × | × |
| "php" |  |  |  |  |  |  |  |  |  | × |


## 四、[递增／递减运算符][3]

### 1. 概览
| 例子 | 名称 | 效果 |
| - | - | - |
| ++$a | 前加 | $a 的值加一，然后返回 $a。 |
| $a++ | 后加 | 返回 $a，然后将 $a 的值加一。 |
| --$a | 前减 | $a 的值减一， 然后返回 $a。 |
| $a-- | 后减 | 返回 $a，然后将 $a 的值减一。 |


### 2. TIPS
 **`递增／递减运算符不影响布尔值。`** 
 **`递减 NULL 值也没有效果，但是递增 NULL 的结果是 1。`** 
在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。
例如，在 Perl 中 $a = 'Z'; $a++; 将把 $a 变成'AA'，而在 C 中，a = 'Z'; a++; 将把 a 变成 '['（'Z' 的 ASCII 值是 90，'[' 的 ASCII 值是 91）。
注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。
递增／递减其他字符变量则无效，原字符串没有变化。
## 五、[逻辑运算符][4]

### 1. 概览
| 例子 | 名称 | 结果 |
| - | - | - |
| $a and $b | And（逻辑与） | TRUE，如果 $a 和 $b 都为 TRUE。 |
| $a or $b | Or（逻辑或） | TRUE，如果 $a 或 $b 任一为 TRUE。 |
| $a xor $b | Xor（逻辑异或） | TRUE，如果 $a 或 $b 任一为 TRUE，但不同时是。 |
| ! $a | Not（逻辑非） | TRUE，如果 $a 不为 TRUE。 |
| $a && $b | And（逻辑与） | TRUE，如果 $a 和 $b 都为 TRUE。 |
| `$a`||`$b` | Or（逻辑或） | TRUE，如果 $a 或 $b 任一为 TRUE。 |


### 2. TIPS

“与”和“或”有两种不同形式运算符的原因是它们运算的优先级不同。

```php
// "&&" 比 "and" 的优先级高

// 表达式 (true && false) 的结果被赋给 $g
// 等同于：($g = (true && false))
$g = true && false;

// 常量 true 被赋给 $h，false 被忽略
// 等同于：(($h = true) and false)
$h = true and false;
```
## 六、[数组运算符][5]

### 1. 概览
| 例子 | 名称 | 结果 |
| - | - | - |
| $a + $b | 联合 | $a 和 $b 的联合。 |
| $a == $b | 相等 | 如果 $a 和 $b 具有相同的键／值对则为 TRUE。 |
| $a === $b | 全等 | 如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。 |
| $a != $b | 不等 | 如果 $a 不等于 $b 则为 TRUE。 |
| $a <> $b | 不等 | 如果 $a 不等于 $b 则为 TRUE。 |
| $a !== $b | 不全等 | 如果 $a 不全等于 $b 则为 TRUE。 |


### 2. TIPS
#### **`数组中的单元如果具有相同的键名和值则比较时相等`** 

```php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
```
#### **``+ 运算符`和`array_merge()`的区别`** 

当数组下标为字符时，遇到相同键名，`+ 运算符`会抛弃掉后面的值；`array_merge()`会用后面的值覆盖前面的值。
当数组下标为数值时，`array_merge()`会保留所有的值，并重新索引数组。`+ 运算符`同样会抛弃掉后面具有相同下标的值。

```php
$arr1 = ['color' => 'red', 10, 20];
$arr2 = [0, 1, 'color' => 'green'];

print_r($arr1 + $arr2);
print_r(array_merge($arr1, $arr2));
```

输出：

```php
Array ( [color] => red [0] => 10 [1] => 20 ) 
Array ( [color] => green [0] => 10 [1] => 20 [2] => 0 [3] => 1 )
```
## 七、[运算符优先级][6]

### 1. 概览
| 结合方向 | 运算符 | 附加信息 |
| - | - | - |
| 无 | clone new | clone 和 new |
| 左 | `[` | array() |
| 右 | ** | 算术运算符 |
| 右 | ++ -- ~ (int) (float) (string) (array) (object) (bool) @ | 类型和递增／递减 |
| 无 | instanceof | 类型 |
| 右 | ! | 逻辑运算符 |
| 左 | * / % | 算术运算符 |
| 左 | + - . | 算术运算符和字符串运算符 |
| 左 | `<<` `>>` | 位运算符 |
| 无 | `<` `<=` `>` `>=` | 比较运算符 |
| 无 | == != === !== <> <=> | 比较运算符 |
| 左 | & | 位运算符和引用 |
| 左 | ^ | 位运算符 |
| 左 | `|` | 位运算符 |
| 左 | && | 逻辑运算符 |
| 左 | `||` | 逻辑运算符 |
| 左 | ?? | 比较运算符 |
| 左 | ? : | ternary |
| 右 | = += -= = *= /= .= %= &= |= ^= <<= >>= | 赋值运算符 |
| 左 | and | 逻辑运算符 |
| 左 | xor | 逻辑运算符 |
| 左 | or | 逻辑运算符 |


### 2. TIPS

如果运算符优先级相同，那运算符的结合方向决定了该如何运算。例如，"-"是左联的，那么 1 - 2 - 3 就等同于 (1 - 2) - 3 并且结果是 -4. 另外一方面，"="是右联的，所以 $a = $b = $c 等同于 $a = ($b = $c)。

没有结合的相同优先级的运算符不能连在一起使用，例如 1 < 2 > 1 在PHP是不合法的。但另外一方面表达式 1 <= 1 == 1 是合法的, 因为 == 的优先级低于 <=。

括号的使用，哪怕在不是必要的场合下，通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。
#### **`着重记忆：`** 
`递增/递减`>`!`>`算术运算符`>`大小比较`>`（不）相等比较`>`引用`>`位运算符（^）`>`位运算符（|）`>`逻辑与`>`逻辑或`>`三目`>`赋值`>`and`>`xor`>`or`### 3. 实战例题

请写出下列程序输出的结果

```php
$a = 0;
$b = 0;

if ($a = 3 > 0 || $b = 3 > 0) 
{
    $a++;
    $b++;
    echo $a. "\n";
    echo $b. "\n";
}
```
#### **`例题分析`** 

1.题目中包含`=``>``||`三种运算符，优先级顺序为`>`>`||`>`=`
2.`$a = 3 > 0 || $b = 3 > 0`等价于`$a = ( ( 3 > 0 ) || $b = ( 3 > 0 ) )`
3.`( 3 > 0 )`为 true，因此不会再运算`||`后面的式子
4.$a = true，所以程序可以改写为

```php
$a = 0;
$b = 0;

if ($a = true) 
{
    $a++;
    $b++;
    echo $a. "\n";
    echo $b. "\n";
}
```

5.因为 “递增／递减运算符不影响布尔值”，所以`$a++`后，$a 的值依然是 true，`echo true`，会输出 1
6.因为`$b = 0`，所以`$b++`后，$b 的值为 1
7.输出结果为

```php
1
1
```

[0]: http://php.net/manual/zh/language.operators.arithmetic.php
[1]: http://php.net/manual/zh/language.operators.bitwise.php
[2]: http://php.net/manual/zh/language.operators.comparison.php
[3]: http://php.net/manual/zh/language.operators.increment.php
[4]: http://php.net/manual/zh/language.operators.logical.php
[5]: http://php.net/manual/zh/language.operators.array.php
[6]: http://php.net/manual/zh/language.operators.precedence.php