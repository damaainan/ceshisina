/*
Â© Sarath Saleem , license : https://github.com/sarathsaleem/graphoverflow#LICENSE 

 Knockout JavaScript library v2.3.0 
 (c) Steven Sanderson - http://knockoutjs.com/ 
 License: MIT (http://www.opensource.org/licenses/mit-license.php) */

define("utils/utils", [], function() {
    "use strict";
    return {
        hasLocalStorage: function() {
            return "localStorage" in window && null !== window.localStorage ? window.localStorage : (console.error("GO: Localstorage is not supported by the browser. You may experience perfomance issues"), !1)
        },
        addGradient: function(t, e, n) {
            var r, i = t.namespaceURI,
                o = document.createElementNS(i, "linearGradient");
            if (o.setAttribute("id", "grad-" + e), n[0] instanceof Object) n.forEach(function(t) {
                var e, n = document.createElementNS(i, "stop");
                for (e in t) t.hasOwnProperty(e) && n.setAttribute(e, t[e]);
                o.appendChild(n)
            });
            else if ("string" == typeof n[0]) {
                var a = 0 === (r = n.length) || 1 === r ? [0] : Array.apply(null, new Array(r)).map(function(t, e) {
                    return 100 / (r - 1) * e
                });
                n.forEach(function(t, e) {
                    var n = document.createElementNS(i, "stop");
                    n.setAttribute("offset", a[e] + "%"), n.setAttribute("stop-color", t), o.appendChild(n)
                })
            }
            return (t.querySelector("defs") || t.insertBefore(document.createElementNS(i, "defs"), t.firstChild)).appendChild(o)
        },
        addImage: function(t, e, n, r, i) {
            var o = t.namespaceURI,
                a = document.createElementNS(o, "pattern");
            a.setAttribute("x", 0), a.setAttribute("y", 0), a.setAttribute("id", "image-" + e), a.setAttribute("width", r), a.setAttribute("height", i);
            var s = document.createElementNS(o, "image");
            return s.setAttribute("x", 0), s.setAttribute("y", 0), s.setAttribute("width", r), s.setAttribute("height", i), s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n), a.appendChild(s), (t.querySelector("defs") || t.insertBefore(document.createElementNS(o, "defs"), t.firstChild)).appendChild(a)
        },
        addClipPathCircle: function(t, e, n) {
            var r = t.namespaceURI,
                i = document.createElementNS(r, "clipPath");
            i.setAttribute("id", e);
            var o = document.createElementNS(r, "circle");
            return o.setAttribute("r", n), o.setAttribute("cx", 50), o.setAttribute("cy", 50), i.appendChild(o), (t.querySelector("defs") || t.insertBefore(document.createElementNS(r, "defs"), t.firstChild)).appendChild(i)
        },
        getTagColors: function() {
            return {
                "c#": "#68217A",
                java: "#C50000,#DF0000,#FE0000",
                javascript: "#F8DC3D",
                php: "#777BB4",
                android: "#A4C439",
                python: "#3779AF,#FFCC3B",
                jquery: "#0769AD",
                "c++": "#A1BCDF",
                html: "#E34C26,#F06529",
                html5: "#E34C26,#F06529",
                mysql: "#93AFC0,#F8900C",
                "asp.net": "#0054A3",
                ".net": "#0054A3",
                "asp.net-mvs": "#0054A3",
                wpf: "#0054A3",
                ios: "#585AD7,#5998EB,#5AC8FA",
                iphone: "#E0E0E1,#7B7B7B",
                "objective-c": "#323F50",
                ruby: "#D51F07,#AF1401,#991301",
                "ruby-on-rails": "#D51F07,#AF1401,#991301",
                "sql-server": "#DFE0E1,#8C9197,#A0041E,#FA4C44",
                ajax: "#005A9C",
                xml: "#005A9C",
                django: "#7FB83D,#234F32,#092E20",
                linux: "#2E2C2C,#E7E8E9,#FDD23C",
                perl: "#E9F2FB,#A9CBEE,#5A8ACB"
            }
        },
        gitColors: function() {
            return {
                ActionScript: "#e3491a",
                Ada: "#02f88c",
                Agda: "#467C91",
                Alloy: "#cc5c24",
                ANTLR: "#9DC3FF",
                Arc: "#ca2afe",
                Arduino: "#bd79d1",
                ASP: "#6a40fd",
                AspectJ: "#1957b0",
                Assembly: "#a67219",
                ATS: "#1ac620",
                AutoHotkey: "#6594b9",
                AutoIt: "#36699B",
                Boo: "#d4bec1",
                C: "#555",
                "C#": "#5a25a2",
                "C++": "#f34b7d",
                Cirru: "#aaaaff",
                Clean: "#3a81ad",
                Clojure: "#db5855",
                CoffeeScript: "#244776",
                ColdFusion: "#ed2cd6",
                "Common Lisp": "#3fb68b",
                "Component Pascal": "#b0ce4e",
                CSS: "#563d7c",
                D: "#fcd46d",
                Dart: "#98BAD6",
                DM: "#075ff1",
                Dogescript: "#cca760",
                Dylan: "#3ebc27",
                E: "#ccce35",
                Eagle: "#3994bc",
                ECL: "#8a1267",
                edn: "#db5855",
                Eiffel: "#946d57",
                Elixir: "#6e4a7e",
                "Emacs Lisp": "#c065db",
                Erlang: "#0faf8d",
                "F#": "#b845fc",
                Factor: "#636746",
                Fancy: "#7b9db4",
                Fantom: "#dbded5",
                FLUX: "#33CCFF",
                Forth: "#341708",
                FORTRAN: "#4d41b1",
                Frege: "#00cafe",
                "Game Maker Language": "#8ad353",
                Glyph: "#e4cc98",
                Gnuplot: "#f0a9f0",
                Go: "#375eab",
                Gosu: "#82937f",
                "Grammatical Framework": "#ff0000",
                Groovy: "#e69f56",
                Harbour: "#0e60e3",
                Haskell: "#29b544",
                Haxe: "#f7941e",
                Hy: "#7891b1",
                IDL: "#e3592c",
                Io: "#a9188d",
                Ioke: "#078193",
                Java: "#b07219",
                JavaScript: "#f1e05a",
                Julia: "#a270ba",
                KRL: "#f5c800",
                Lasso: "#2584c3",
                Latte: "#A8FF97",
                LFE: "#004200",
                LiveScript: "#499886",
                Lua: "#fa1fa1",
                Mask: "#f97732",
                Matlab: "#bb92ac",
                Max: "#ce279c",
                Mercury: "#abcdef",
                Mirah: "#c7a938",
                MTML: "#0095d9",
                Nemerle: "#0d3c6e",
                nesC: "#ffce3b",
                NetLogo: "#ff2b2b",
                Nimrod: "#37775b",
                Nu: "#c9df40",
                "Objective-C": "#438eff",
                "Objective-C++": "#4886FC",
                "Objective-J": "#ff0c5a",
                OCaml: "#3be133",
                Omgrofl: "#cabbff",
                ooc: "#b0b77e",
                Oxygene: "#5a63a3",
                Pan: "#cc0000",
                Parrot: "#f3ca0a",
                Pascal: "#b0ce4e",
                PAWN: "#dbb284",
                Perl: "#0298c3",
                Perl6: "#0298c3",
                PHP: "#4F5D95",
                Pike: "#066ab2",
                PogoScript: "#d80074",
                Processing: "#2779ab",
                Prolog: "#74283c",
                "Propeller Spin": "#2b446d",
                Puppet: "#cc5555",
                "Pure Data": "#91de79",
                PureScript: "#bcdc53",
                Python: "#3581ba",
                QML: "#44a51c",
                R: "#198ce7",
                Racket: "#ae17ff",
                "Ragel in Ruby Host": "#ff9c2e",
                Rebol: "#358a5b",
                Red: "#ee0000",
                Rouge: "#cc0088",
                Ruby: "#701516",
                Rust: "#dea584",
                SAS: "#1E90FF",
                Scala: "#7dd3b0",
                Scheme: "#1e4aec",
                Self: "#0579aa",
                Shell: "#5861ce",
                Shen: "#120F14",
                Slash: "#007eff",
                Smalltalk: "#596706",
                SourcePawn: "#f69e1d",
                "Standard ML": "#dc566d",
                SuperCollider: "#46390b",
                Swift: "#ffac45",
                SystemVerilog: "#343761",
                Tcl: "#e4cc98",
                TeX: "#3D6117",
                Turing: "#45f715",
                TypeScript: "#31859c",
                "Unified Parallel C": "#755223",
                UnrealScript: "#a54c4d",
                Vala: "#ee7d06",
                VCL: "#0298c3",
                Verilog: "#848bf3",
                VHDL: "#543978",
                VimL: "#199c4b",
                "Visual Basic": "#945db7",
                Volt: "#0098db",
                wisp: "#7582D1",
                xBase: "#3a4040",
                XQuery: "#2700e2",
                Zephir: "#118f9e"
            }
        },
        convertHex: function(t, e) {
            return t = t.replace("#", ""), "rgba(" + parseInt(t.substring(0, 2), 16) + "," + parseInt(t.substring(2, 4), 16) + "," + parseInt(t.substring(4, 6), 16) + "," + e / 100 + ")"
        }
    }
});
var THREE = {
    REVISION: "73"
};
"function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE), void 0 !== self.requestAnimationFrame && void 0 !== self.cancelAnimationFrame || function() {
        for (var t = 0, e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length && !self.requestAnimationFrame; ++n) self.requestAnimationFrame = self[e[n] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[e[n] + "CancelAnimationFrame"] || self[e[n] + "CancelRequestAnimationFrame"];
        void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function(e) {
            var n = Date.now(),
                r = Math.max(0, 16 - (n - t)),
                i = self.setTimeout(function() {
                    e(n + r)
                }, r);
            return t = n + r, i
        }), void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function(t) {
            self.clearTimeout(t)
        })
    }(), void 0 === self.performance && (self.performance = {}), void 0 === self.performance.now && function() {
        var t = Date.now();
        self.performance.now = function() {
            return Date.now() - t
        }
    }(), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(t) {
        return 0 > t ? -1 : 0 < t ? 1 : +t
    }), void 0 === Function.prototype.name && void 0 !== Object.defineProperty && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
        }
    }), THREE.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.NeverDepth = 0, THREE.AlwaysDepth = 1, THREE.LessDepth = 2, THREE.LessEqualDepth = 3, THREE.EqualDepth = 4, THREE.GreaterEqualDepth = 5, THREE.GreaterDepth = 6, THREE.NotEqualDepth = 7, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.HalfFloatType = 1025, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGBEFormat = THREE.RGBAFormat, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.RGB_PVRTC_4BPPV1_Format = 2100, THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, THREE.RGBA_PVRTC_2BPPV1_Format = 2103, THREE.LoopOnce = 2200, THREE.LoopRepeat = 2201, THREE.LoopPingPong = 2202, THREE.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function(t, e) {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }, THREE.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }, THREE.Color = function(t) {
        return 3 === arguments.length ? this.fromArray(arguments) : this.set(t)
    }, THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t instanceof THREE.Color ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, n) {
            return this.r = t, this.g = e, this.b = n, this
        },
        setHSL: function() {
            function t(t, e, n) {
                return 0 > n && (n += 1), 1 < n && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : .5 > n ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }
            return function(e, n, r) {
                return e = THREE.Math.euclideanModulo(e, 1), n = THREE.Math.clamp(n, 0, 1), r = THREE.Math.clamp(r, 0, 1), 0 === n ? this.r = this.g = this.b = r : (r = 2 * r - (n = .5 >= r ? r * (1 + n) : r + n - r * n), this.r = t(r, n, e + 1 / 3), this.g = t(r, n, e), this.b = t(r, n, e - 1 / 3)), this
            }
        }(),
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && 1 > parseFloat(e) && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var r = n[2];
                switch (n[1]) {
                    case "rgb":
                    case "rgba":
                        if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                        if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
                            r = parseFloat(n[1]) / 360;
                            var i = parseInt(n[2], 10) / 100,
                                o = parseInt(n[3], 10) / 100;
                            return e(n[5]), this.setHSL(r, i, o)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                if (3 === (r = (n = n[1]).length)) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, this;
                if (6 === r) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, this
            }
            return t && 0 < t.length && (void 0 !== (n = THREE.ColorKeywords[t]) ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + t)), this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var n = 0 < e ? 1 / e : 1;
            return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
        },
        convertGammaToLinear: function() {
            var t = this.r,
                e = this.g,
                n = this.b;
            return this.r = t * t, this.g = e * e, this.b = n * n, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            t = t || {
                h: 0,
                s: 0,
                l: 0
            };
            var e, n = this.r,
                r = this.g,
                i = this.b,
                o = Math.max(n, r, i),
                a = ((u = Math.min(n, r, i)) + o) / 2;
            if (u === o) u = e = 0;
            else {
                var s = o - u,
                    u = .5 >= a ? s / (o + u) : s / (2 - o - u);
                switch (o) {
                    case n:
                        e = (r - i) / s + (r < i ? 6 : 0);
                        break;
                    case r:
                        e = (i - n) / s + 2;
                        break;
                    case i:
                        e = (n - r) / s + 4
                }
                e /= 6
            }
            return t.h = e, t.s = u, t.l = a, t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, n) {
            var r = this.getHSL();
            return r.h += t, r.s += e, r.l += n, this.setHSL(r.h, r.s, r.l), this
        },
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        }
    }, THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, THREE.Quaternion = function(t, e, n, r) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
    }, THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        get x() {
            return this._x
        },
        set x(t) {
            this._x = t, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(t) {
            this._y = t, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(t) {
            this._z = t, this.onChangeCallback()
        },
        get w() {
            return this._w
        },
        set w(t) {
            this._w = t, this.onChangeCallback()
        },
        set: function(t, e, n, r) {
            return this._x = t, this._y = e, this._z = n, this._w = r, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (!1 == t instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var n = Math.cos(t._x / 2),
                r = Math.cos(t._y / 2),
                i = Math.cos(t._z / 2),
                o = Math.sin(t._x / 2),
                a = Math.sin(t._y / 2),
                s = Math.sin(t._z / 2),
                u = t.order;
            return "XYZ" === u ? (this._x = o * r * i + n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i - o * a * s) : "YXZ" === u ? (this._x = o * r * i + n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i + o * a * s) : "ZXY" === u ? (this._x = o * r * i - n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i - o * a * s) : "ZYX" === u ? (this._x = o * r * i - n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i + o * a * s) : "YZX" === u ? (this._x = o * r * i + n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i - o * a * s) : "XZY" === u && (this._x = o * r * i - n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i + o * a * s), !1 !== e && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            var n = e / 2,
                r = Math.sin(n);
            return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            var e = (n = t.elements)[0];
            t = n[4];
            var n, r = n[8],
                i = n[1],
                o = n[5],
                a = n[9],
                s = n[2],
                u = n[6],
                h = e + o + (n = n[10]);
            return 0 < h ? (e = .5 / Math.sqrt(h + 1), this._w = .25 / e, this._x = (u - a) * e, this._y = (r - s) * e, this._z = (i - t) * e) : e > o && e > n ? (e = 2 * Math.sqrt(1 + e - o - n), this._w = (u - a) / e, this._x = .25 * e, this._y = (t + i) / e, this._z = (r + s) / e) : o > n ? (e = 2 * Math.sqrt(1 + o - e - n), this._w = (r - s) / e, this._x = (t + i) / e, this._y = .25 * e, this._z = (a + u) / e) : (e = 2 * Math.sqrt(1 + n - e - o), this._w = (i - t) / e, this._x = (r + s) / e, this._y = (a + u) / e, this._z = .25 * e), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new THREE.Vector3), 1e-6 > (e = n.dot(r) + 1) ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize(), this
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize(), this
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x,
                r = t._y,
                i = t._z,
                o = t._w,
                a = e._x,
                s = e._y,
                u = e._z,
                h = e._w;
            return this._x = n * h + o * a + r * u - i * s, this._y = r * h + o * s + i * a - n * u, this._z = i * h + o * u + n * s - r * a, this._w = o * h - n * a - r * s - i * u, this.onChangeCallback(), this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
                r = this._y,
                i = this._z,
                o = this._w,
                a = o * t._w + n * t._x + r * t._y + i * t._z;
            if (0 > a ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), 1 <= a) return this._w = o, this._x = n, this._y = r, this._z = i, this;
            var s = Math.acos(a),
                u = Math.sqrt(1 - a * a);
            return .001 > Math.abs(u) ? (this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this) : (a = Math.sin((1 - e) * s) / u, s = Math.sin(e * s) / u, this._w = o * a + this._w * s, this._x = n * a + this._x * s, this._y = r * a + this._y * s, this._z = i * a + this._z * s, this.onChangeCallback(), this)
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }, THREE.Quaternion.slerp = function(t, e, n, r) {
        return n.copy(t).slerp(e, r)
    }, THREE.Vector2 = function(t, e) {
        this.x = t || 0, this.y = e || 0
    }, THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        get width() {
            return this.x
        },
        set width(t) {
            this.x = t
        },
        get height() {
            return this.y
        },
        set height(t) {
            this.y = t
        },
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return isFinite(t) ? (this.x *= t, this.y *= t) : this.y = this.x = 0, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new THREE.Vector2, e = new THREE.Vector2), t.set(n, n), e.set(r, r), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n), this
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x;
            return e * e + (t = this.y - t.y) * t
        },
        setLength: function(t) {
            return this.multiplyScalar(t / this.length())
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t), this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromAttribute: function(t, e, n) {
            return void 0 === n && (n = 0), e = e * t.itemSize + n, this.x = t.array[e], this.y = t.array[e + 1], this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e),
                r = Math.sin(e),
                i = this.x - t.x,
                o = this.y - t.y;
            return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
        }
    }, THREE.Vector3 = function(t, e, n) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0
    }, THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function(t, e, n) {
            return this.x = t, this.y = e, this.z = n, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : this.z = this.y = this.x = 0, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function() {
            var t;
            return function(e) {
                return !1 == e instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromEuler(e)), this
            }
        }(),
        applyAxisAngle: function() {
            var t;
            return function(e, n) {
                return void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromAxisAngle(e, n)), this
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z;
            return t = t.elements, this.x = t[0] * e + t[3] * n + t[6] * r, this.y = t[1] * e + t[4] * n + t[7] * r, this.z = t[2] * e + t[5] * n + t[8] * r, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z;
            return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * r + t[12], this.y = t[1] * e + t[5] * n + t[9] * r + t[13], this.z = t[2] * e + t[6] * n + t[10] * r + t[14], this
        },
        applyProjection: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = 1 / ((t = t.elements)[3] * e + t[7] * n + t[11] * r + t[15]);
            return this.x = (t[0] * e + t[4] * n + t[8] * r + t[12]) * i, this.y = (t[1] * e + t[5] * n + t[9] * r + t[13]) * i, this.z = (t[2] * e + t[6] * n + t[10] * r + t[14]) * i, this
        },
        applyQuaternion: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = t.x,
                o = t.y,
                a = t.z,
                s = (t = t.w) * e + o * r - a * n,
                u = t * n + a * e - i * r,
                h = t * r + i * n - o * e;
            e = -i * e - o * n - a * r;
            return this.x = s * t + e * -i + u * -a - h * -o, this.y = u * t + e * -o + h * -i - s * -a, this.z = h * t + e * -a + s * -o - u * -i, this
        },
        project: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyProjection(t)
            }
        }(),
        unproject: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyProjection(t)
            }
        }(),
        transformDirection: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z;
            return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * r, this.y = t[1] * e + t[5] * n + t[9] * r, this.z = t[2] * e + t[6] * n + t[10] * r, this.normalize(), this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new THREE.Vector3, e = new THREE.Vector3), t.set(n, n, n), e.set(r, r, r), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n), this
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(t) {
            return this.multiplyScalar(t / this.length())
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t), this
        },
        cross: function(t, e) {
            if (void 0 !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e);
            var n = this.x,
                r = this.y,
                i = this.z;
            return this.x = r * t.z - i * t.y, this.y = i * t.x - n * t.z, this.z = n * t.y - r * t.x, this
        },
        crossVectors: function(t, e) {
            var n = t.x,
                r = t.y,
                i = t.z,
                o = e.x,
                a = e.y,
                s = e.z;
            return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
        },
        projectOnVector: function() {
            var t, e;
            return function(n) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(n).normalize(), e = this.dot(t), this.copy(t).multiplyScalar(e)
            }
        }(),
        projectOnPlane: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Vector3), t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Vector3), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            return t = this.dot(t) / (this.length() * t.length()), Math.acos(THREE.Math.clamp(t, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n + (t = this.z - t.z) * t
        },
        setEulerFromRotationMatrix: function(t, e) {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function(t, e) {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        setFromMatrixPosition: function(t) {
            return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this
        },
        setFromMatrixScale: function(t) {
            var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length(),
                n = this.set(t.elements[4], t.elements[5], t.elements[6]).length();
            return t = this.set(t.elements[8], t.elements[9], t.elements[10]).length(), this.x = e, this.y = n, this.z = t, this
        },
        setFromMatrixColumn: function(t, e) {
            var n = 4 * t,
                r = e.elements;
            return this.x = r[n], this.y = r[n + 1], this.z = r[n + 2], this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromAttribute: function(t, e, n) {
            return void 0 === n && (n = 0), e = e * t.itemSize + n, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this
        }
    }, THREE.Vector4 = function(t, e, n, r) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
    }, THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function(t, e, n, r) {
            return this.x = t, this.y = e, this.z = n, this.w = r, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this.w *= t) : this.w = this.z = this.y = this.x = 0, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = this.w;
            return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * r + t[12] * i, this.y = t[1] * e + t[5] * n + t[9] * r + t[13] * i, this.z = t[2] * e + t[6] * n + t[10] * r + t[14] * i, this.w = t[3] * e + t[7] * n + t[11] * r + t[15] * i, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, n, r, i = (t = t.elements)[0];
            r = t[4];
            var o = t[8],
                a = t[1],
                s = t[5],
                u = t[9];
            n = t[2], e = t[6];
            var h = t[10];
            return .01 > Math.abs(r - a) && .01 > Math.abs(o - n) && .01 > Math.abs(u - e) ? .1 > Math.abs(r + a) && .1 > Math.abs(o + n) && .1 > Math.abs(u + e) && .1 > Math.abs(i + s + h - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, h = (h + 1) / 2, r = (r + a) / 4, o = (o + n) / 4, u = (u + e) / 4, (i = (i + 1) / 2) > (s = (s + 1) / 2) && i > h ? .01 > i ? (e = 0, r = n = .707106781) : (n = r / (e = Math.sqrt(i)), r = o / e) : s > h ? .01 > s ? (e = .707106781, n = 0, r = .707106781) : (e = r / (n = Math.sqrt(s)), r = u / n) : .01 > h ? (n = e = .707106781, r = 0) : (e = o / (r = Math.sqrt(h)), n = u / r), this.set(e, n, r, t), this) : (t = Math.sqrt((e - u) * (e - u) + (o - n) * (o - n) + (a - r) * (a - r)), .001 > Math.abs(t) && (t = 1), this.x = (e - u) / t, this.y = (o - n) / t, this.z = (a - r) / t, this.w = Math.acos((i + s + h - 1) / 2), this)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new THREE.Vector4, e = new THREE.Vector4), t.set(n, n, n, n), e.set(r, r, r, r), this.clamp(t, e)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(t) {
            return this.multiplyScalar(t / this.length())
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t), this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromAttribute: function(t, e, n) {
            return void 0 === n && (n = 0), e = e * t.itemSize + n, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this.w = t.array[e + 3], this
        }
    }, THREE.Euler = function(t, e, n, r) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = r || THREE.Euler.DefaultOrder
    }, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
        constructor: THREE.Euler,
        get x() {
            return this._x
        },
        set x(t) {
            this._x = t, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(t) {
            this._y = t, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(t) {
            this._z = t, this.onChangeCallback()
        },
        get order() {
            return this._order
        },
        set order(t) {
            this._order = t, this.onChangeCallback()
        },
        set: function(t, e, n, r) {
            return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e, n) {
            var r = THREE.Math.clamp;
            t = (l = t.elements)[0];
            var i = l[4],
                o = l[8],
                a = l[1],
                s = l[5],
                u = l[9],
                h = l[2],
                c = l[6],
                l = l[10];
            return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(r(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(-u, l), this._z = Math.atan2(-i, t)) : (this._x = Math.atan2(c, s), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(o, l), this._z = Math.atan2(a, s)) : (this._y = Math.atan2(-h, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(-h, l), this._z = Math.atan2(-i, s)) : (this._y = 0, this._z = Math.atan2(a, t))) : "ZYX" === e ? (this._y = Math.asin(-r(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(c, l), this._z = Math.atan2(a, t)) : (this._x = 0, this._z = Math.atan2(-i, s))) : "YZX" === e ? (this._z = Math.asin(r(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-u, s), this._y = Math.atan2(-h, t)) : (this._x = 0, this._y = Math.atan2(o, l))) : "XZY" === e ? (this._z = Math.asin(-r(i, -1, 1)), .99999 > Math.abs(i) ? (this._x = Math.atan2(c, s), this._y = Math.atan2(o, t)) : (this._x = Math.atan2(-u, l), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var t;
            return function(e, n, r) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, r), this
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function() {
            var t = new THREE.Quaternion;
            return function(e) {
                t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }, THREE.Line3 = function(t, e) {
        this.start = void 0 !== t ? t : new THREE.Vector3, this.end = void 0 !== e ? e : new THREE.Vector3
    }, THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        center: function(t) {
            return (t || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return (t || new THREE.Vector3).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            var n = e || new THREE.Vector3;
            return this.delta(n).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(n, r) {
                t.subVectors(n, this.start), e.subVectors(this.end, this.start);
                var i = e.dot(e);
                i = e.dot(t) / i;
                return r && (i = THREE.Math.clamp(i, 0, 1)), i
            }
        }(),
        closestPointToPoint: function(t, e, n) {
            return t = this.closestPointToPointParameter(t, e), n = n || new THREE.Vector3, this.delta(n).multiplyScalar(t).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }, THREE.Box2 = function(t, e) {
        this.min = void 0 !== t ? t : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector2(-1 / 0, -1 / 0)
    }, THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new THREE.Vector2;
            return function(e, n) {
                var r = t.copy(n).multiplyScalar(.5);
                return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function(t) {
            return (t || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(t) {
            return (t || new THREE.Vector2).subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return (e || new THREE.Vector2).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        isIntersectionBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return (e || new THREE.Vector2).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new THREE.Vector2;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }, THREE.Box3 = function(t, e) {
        this.min = void 0 !== t ? t : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0)
    }, THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new THREE.Vector3;
            return function(e, n) {
                var r = t.copy(n).multiplyScalar(.5);
                return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
            }
        }(),
        setFromObject: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var n = this;
                return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse(function(e) {
                    if (void 0 !== (i = e.geometry))
                        if (i instanceof THREE.Geometry)
                            for (var r = i.vertices, i = 0, o = r.length; i < o; i++) t.copy(r[i]), t.applyMatrix4(e.matrixWorld), n.expandByPoint(t);
                        else if (i instanceof THREE.BufferGeometry && void 0 !== i.attributes.position)
                        for (r = i.attributes.position.array, i = 0, o = r.length; i < o; i += 3) t.set(r[i], r[i + 1], r[i + 2]), t.applyMatrix4(e.matrixWorld), n.expandByPoint(t)
                }), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function(t) {
            return (t || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(t) {
            return (t || new THREE.Vector3).subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return (e || new THREE.Vector3).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        isIntersectionBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        clampPoint: function(t, e) {
            return (e || new THREE.Vector3).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return (e = e || new THREE.Sphere).center = this.center(), e.radius = .5 * this.size(t).length(), e
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function() {
            var t = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function(e) {
                return t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.makeEmpty(), this.setFromPoints(t), this
            }
        }(),
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }, THREE.Matrix3 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function(t, e, n, r, i, o, a, s, u) {
            var h = this.elements;
            return h[0] = t, h[3] = e, h[6] = n, h[1] = r, h[4] = i, h[7] = o, h[2] = a, h[5] = s, h[8] = u, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            return t = t.elements, this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
        },
        applyToVector3Array: function() {
            var t;
            return function(e, n, r) {
                void 0 === t && (t = new THREE.Vector3), void 0 === n && (n = 0), void 0 === r && (r = e.length);
                for (var i = 0; i < r; i += 3, n += 3) t.fromArray(e, n), t.applyMatrix3(this), t.toArray(e, n);
                return e
            }
        }(),
        applyToBuffer: function() {
            var t;
            return function(e, n, r) {
                void 0 === t && (t = new THREE.Vector3), void 0 === n && (n = 0), void 0 === r && (r = e.length / e.itemSize);
                for (var i = 0; i < r; i++, n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(t.x, t.y, t.z);
                return e
            }
        }(),
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            var t, e = (t = this.elements)[0],
                n = t[1],
                r = t[2],
                i = t[3],
                o = t[4],
                a = t[5],
                s = t[6],
                u = t[7];
            return e * o * (t = t[8]) - e * a * u - n * i * t + n * a * s + r * i * u - r * o * s
        },
        getInverse: function(t, e) {
            var n = t.elements,
                r = this.elements;
            if (r[0] = n[10] * n[5] - n[6] * n[9], r[1] = -n[10] * n[1] + n[2] * n[9], r[2] = n[6] * n[1] - n[2] * n[5], r[3] = -n[10] * n[4] + n[6] * n[8], r[4] = n[10] * n[0] - n[2] * n[8], r[5] = -n[6] * n[0] + n[2] * n[4], r[6] = n[9] * n[4] - n[5] * n[8], r[7] = -n[9] * n[0] + n[1] * n[8], r[8] = n[5] * n[0] - n[1] * n[4], 0 === (n = n[0] * r[0] + n[1] * r[3] + n[2] * r[6])) {
                if (e) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
            }
            return this.multiplyScalar(1 / n), this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        flattenToArrayOffset: function(t, e) {
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        },
        getNormalMatrix: function(t) {
            return this.getInverse(t).transpose(), this
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        fromArray: function(t) {
            return this.elements.set(t), this
        },
        toArray: function() {
            var t = this.elements;
            return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]]
        }
    }, THREE.Matrix4 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function(t, e, n, r, i, o, a, s, u, h, c, l, p, f, d, E) {
            var m = this.elements;
            return m[0] = t, m[4] = e, m[8] = n, m[12] = r, m[1] = i, m[5] = o, m[9] = a, m[13] = s, m[2] = u, m[6] = h, m[10] = c, m[14] = l, m[3] = p, m[7] = f, m[11] = d, m[15] = E, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new THREE.Matrix4).fromArray(this.elements)
        },
        copy: function(t) {
            return this.elements.set(t.elements), this
        },
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        copyPosition: function(t) {
            var e = this.elements;
            return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this
        },
        extractBasis: function(t, e, n) {
            var r = this.elements;
            return t.set(r[0], r[1], r[2]), e.set(r[4], r[5], r[6]), n.set(r[8], r[9], r[10]), this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var t;
            return function(e) {
                void 0 === t && (t = new THREE.Vector3);
                var n = this.elements;
                e = e.elements;
                var r = 1 / t.set(e[0], e[1], e[2]).length(),
                    i = 1 / t.set(e[4], e[5], e[6]).length(),
                    o = 1 / t.set(e[8], e[9], e[10]).length();
                return n[0] = e[0] * r, n[1] = e[1] * r, n[2] = e[2] * r, n[4] = e[4] * i, n[5] = e[5] * i, n[6] = e[6] * i, n[8] = e[8] * o, n[9] = e[9] * o, n[10] = e[10] * o, this
            }
        }(),
        makeRotationFromEuler: function(t) {
            !1 == t instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                n = t.x,
                r = t.y,
                i = t.z,
                o = Math.cos(n),
                a = (n = Math.sin(n), Math.cos(r)),
                s = (r = Math.sin(r), Math.cos(i));
            i = Math.sin(i);
            if ("XYZ" === t.order) {
                t = o * s;
                var u = o * i,
                    h = n * s,
                    c = n * i;
                e[0] = a * s, e[4] = -a * i, e[8] = r, e[1] = u + h * r, e[5] = t - c * r, e[9] = -n * a, e[2] = c - t * r, e[6] = h + u * r, e[10] = o * a
            } else "YXZ" === t.order ? (t = a * s, u = a * i, h = r * s, c = r * i, e[0] = t + c * n, e[4] = h * n - u, e[8] = o * r, e[1] = o * i, e[5] = o * s, e[9] = -n, e[2] = u * n - h, e[6] = c + t * n, e[10] = o * a) : "ZXY" === t.order ? (t = a * s, u = a * i, h = r * s, c = r * i, e[0] = t - c * n, e[4] = -o * i, e[8] = h + u * n, e[1] = u + h * n, e[5] = o * s, e[9] = c - t * n, e[2] = -o * r, e[6] = n, e[10] = o * a) : "ZYX" === t.order ? (t = o * s, u = o * i, h = n * s, c = n * i, e[0] = a * s, e[4] = h * r - u, e[8] = t * r + c, e[1] = a * i, e[5] = c * r + t, e[9] = u * r - h, e[2] = -r, e[6] = n * a, e[10] = o * a) : "YZX" === t.order ? (t = o * a, u = o * r, h = n * a, c = n * r, e[0] = a * s, e[4] = c - t * i, e[8] = h * i + u, e[1] = i, e[5] = o * s, e[9] = -n * s, e[2] = -r * s, e[6] = u * i + h, e[10] = t - c * i) : "XZY" === t.order && (t = o * a, u = o * r, h = n * a, c = n * r, e[0] = a * s, e[4] = -i, e[8] = r * s, e[1] = t * i + c, e[5] = o * s, e[9] = u * i - h, e[2] = h * i - u, e[6] = n * s, e[10] = c * i + t);
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements,
                n = t.x,
                r = t.y,
                i = t.z,
                o = t.w,
                a = i + i;
            t = n * (h = n + n);
            var s = n * (c = r + r),
                u = (n = n * a, r * c),
                h = (r = r * a, i = i * a, o * h),
                c = o * c;
            o *= a;
            return e[0] = 1 - (u + i), e[4] = s - o, e[8] = n + c, e[1] = s + o, e[5] = 1 - (t + i), e[9] = r - h, e[2] = n - c, e[6] = r + h, e[10] = 1 - (t + u), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        lookAt: function() {
            var t, e, n;
            return function(r, i, o) {
                void 0 === t && (t = new THREE.Vector3), void 0 === e && (e = new THREE.Vector3), void 0 === n && (n = new THREE.Vector3);
                var a = this.elements;
                return n.subVectors(r, i).normalize(), 0 === n.lengthSq() && (n.z = 1), t.crossVectors(o, n).normalize(), 0 === t.lengthSq() && (n.x += 1e-4, t.crossVectors(o, n).normalize()), e.crossVectors(n, t), a[0] = t.x, a[4] = e.x, a[8] = n.x, a[1] = t.y, a[5] = e.y, a[9] = n.y, a[2] = t.z, a[6] = e.z, a[10] = n.z, this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements,
                r = e.elements,
                i = this.elements,
                o = n[0],
                a = n[4],
                s = n[8],
                u = n[12],
                h = n[1],
                c = n[5],
                l = n[9],
                p = n[13],
                f = n[2],
                d = n[6],
                E = n[10],
                m = n[14],
                g = n[3],
                v = n[7],
                y = n[11],
                T = (n = n[15], r[0]),
                R = r[4],
                x = r[8],
                b = r[12],
                H = r[1],
                _ = r[5],
                w = r[9],
                M = r[13],
                S = r[2],
                A = r[6],
                C = r[10],
                L = r[14],
                k = r[3],
                P = r[7],
                D = r[11];
            r = r[15];
            return i[0] = o * T + a * H + s * S + u * k, i[4] = o * R + a * _ + s * A + u * P, i[8] = o * x + a * w + s * C + u * D, i[12] = o * b + a * M + s * L + u * r, i[1] = h * T + c * H + l * S + p * k, i[5] = h * R + c * _ + l * A + p * P, i[9] = h * x + c * w + l * C + p * D, i[13] = h * b + c * M + l * L + p * r, i[2] = f * T + d * H + E * S + m * k, i[6] = f * R + d * _ + E * A + m * P, i[10] = f * x + d * w + E * C + m * D, i[14] = f * b + d * M + E * L + m * r, i[3] = g * T + v * H + y * S + n * k, i[7] = g * R + v * _ + y * A + n * P, i[11] = g * x + v * w + y * C + n * D, i[15] = g * b + v * M + y * L + n * r, this
        },
        multiplyToArray: function(t, e, n) {
            var r = this.elements;
            return this.multiplyMatrices(t, e), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), t.applyProjection(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
        },
        applyToVector3Array: function() {
            var t;
            return function(e, n, r) {
                void 0 === t && (t = new THREE.Vector3), void 0 === n && (n = 0), void 0 === r && (r = e.length);
                for (var i = 0; i < r; i += 3, n += 3) t.fromArray(e, n), t.applyMatrix4(this), t.toArray(e, n);
                return e
            }
        }(),
        applyToBuffer: function() {
            var t;
            return function(e, n, r) {
                void 0 === t && (t = new THREE.Vector3), void 0 === n && (n = 0), void 0 === r && (r = e.length / e.itemSize);
                for (var i = 0; i < r; i++, n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(t.x, t.y, t.z);
                return e
            }
        }(),
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                n = t[4],
                r = t[8],
                i = t[12],
                o = t[1],
                a = t[5],
                s = t[9],
                u = t[13],
                h = t[2],
                c = t[6],
                l = t[10],
                p = t[14];
            return t[3] * (+i * s * c - r * u * c - i * a * l + n * u * l + r * a * p - n * s * p) + t[7] * (+e * s * p - e * u * l + i * o * l - r * o * p + r * u * h - i * s * h) + t[11] * (+e * u * c - e * a * p - i * o * c + n * o * p + i * a * h - n * u * h) + t[15] * (-r * a * h - e * s * c + e * a * l + r * o * c - n * o * l + n * s * h)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        flattenToArrayOffset: function(t, e) {
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        },
        getPosition: function() {
            var t;
            return function() {
                void 0 === t && (t = new THREE.Vector3), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var e = this.elements;
                return t.set(e[12], e[13], e[14])
            }
        }(),
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        },
        getInverse: function(t, e) {
            var n = this.elements,
                r = (v = t.elements)[0],
                i = v[4],
                o = v[8],
                a = v[12],
                s = v[1],
                u = v[5],
                h = v[9],
                c = v[13],
                l = v[2],
                p = v[6],
                f = v[10],
                d = v[14],
                E = v[3],
                m = v[7],
                g = v[11],
                v = v[15];
            if (n[0] = h * d * m - c * f * m + c * p * g - u * d * g - h * p * v + u * f * v, n[4] = a * f * m - o * d * m - a * p * g + i * d * g + o * p * v - i * f * v, n[8] = o * c * m - a * h * m + a * u * g - i * c * g - o * u * v + i * h * v, n[12] = a * h * p - o * c * p - a * u * f + i * c * f + o * u * d - i * h * d, n[1] = c * f * E - h * d * E - c * l * g + s * d * g + h * l * v - s * f * v, n[5] = o * d * E - a * f * E + a * l * g - r * d * g - o * l * v + r * f * v, n[9] = a * h * E - o * c * E - a * s * g + r * c * g + o * s * v - r * h * v, n[13] = o * c * l - a * h * l + a * s * f - r * c * f - o * s * d + r * h * d, n[2] = u * d * E - c * p * E + c * l * m - s * d * m - u * l * v + s * p * v, n[6] = a * p * E - i * d * E - a * l * m + r * d * m + i * l * v - r * p * v, n[10] = i * c * E - a * u * E + a * s * m - r * c * m - i * s * v + r * u * v, n[14] = a * u * l - i * c * l - a * s * p + r * c * p + i * s * d - r * u * d, n[3] = h * p * E - u * f * E - h * l * m + s * f * m + u * l * g - s * p * g, n[7] = i * f * E - o * p * E + o * l * m - r * f * m - i * l * g + r * p * g, n[11] = o * u * E - i * h * E - o * s * m + r * h * m + i * s * g - r * u * g, n[15] = i * h * l - o * u * l + o * s * p - r * h * p - i * s * f + r * u * f, 0 === (n = r * n[0] + s * n[4] + l * n[8] + E * n[12])) {
                if (e) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
            }
            return this.multiplyScalar(1 / n), this
        },
        translate: function(t) {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function(t) {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function(t) {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function(t) {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function(t, e) {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        scale: function(t) {
            var e = this.elements,
                n = t.x,
                r = t.y;
            return t = t.z, e[0] *= n, e[4] *= r, e[8] *= t, e[1] *= n, e[5] *= r, e[9] *= t, e[2] *= n, e[6] *= r, e[10] *= t, e[3] *= n, e[7] *= r, e[11] *= t, this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements;
            return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            var n = Math.cos(e),
                r = Math.sin(e),
                i = 1 - n,
                o = t.x,
                a = t.y,
                s = t.z,
                u = i * o,
                h = i * a;
            return this.set(u * o + n, u * a - r * s, u * s + r * a, 0, u * a + r * s, h * a + n, h * s - r * o, 0, u * s - r * a, h * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, n) {
            return this.makeRotationFromQuaternion(e), this.scale(n), this.setPosition(t), this
        },
        decompose: function() {
            var t, e;
            return function(n, r, i) {
                void 0 === t && (t = new THREE.Vector3), void 0 === e && (e = new THREE.Matrix4);
                var o = this.elements,
                    a = t.set(o[0], o[1], o[2]).length(),
                    s = t.set(o[4], o[5], o[6]).length(),
                    u = t.set(o[8], o[9], o[10]).length();
                0 > this.determinant() && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], e.elements.set(this.elements), n = 1 / a;
                o = 1 / s;
                var h = 1 / u;
                return e.elements[0] *= n, e.elements[1] *= n, e.elements[2] *= n, e.elements[4] *= o, e.elements[5] *= o, e.elements[6] *= o, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, r.setFromRotationMatrix(e), i.x = a, i.y = s, i.z = u, this
            }
        }(),
        makeFrustum: function(t, e, n, r, i, o) {
            var a = this.elements;
            return a[0] = 2 * i / (e - t), a[4] = 0, a[8] = (e + t) / (e - t), a[12] = 0, a[1] = 0, a[5] = 2 * i / (r - n), a[9] = (r + n) / (r - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + i) / (o - i), a[14] = -2 * o * i / (o - i), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makePerspective: function(t, e, n, r) {
            var i = -(t = n * Math.tan(THREE.Math.degToRad(.5 * t)));
            return this.makeFrustum(i * e, t * e, i, t, n, r)
        },
        makeOrthographic: function(t, e, n, r, i, o) {
            var a = this.elements,
                s = e - t,
                u = n - r,
                h = o - i;
            return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -(e + t) / s, a[1] = 0, a[5] = 2 / u, a[9] = 0, a[13] = -(n + r) / u, a[2] = 0, a[6] = 0, a[10] = -2 / h, a[14] = -(o + i) / h, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(t) {
            var e = this.elements;
            t = t.elements;
            for (var n = 0; 16 > n; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        },
        fromArray: function(t) {
            return this.elements.set(t), this
        },
        toArray: function() {
            var t = this.elements;
            return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]]
        }
    }, THREE.Ray = function(t, e) {
        this.origin = void 0 !== t ? t : new THREE.Vector3, this.direction = void 0 !== e ? e : new THREE.Vector3
    }, THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            return (e || new THREE.Vector3).copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        recast: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function(t, e) {
            var n = e || new THREE.Vector3;
            n.subVectors(t, this.origin);
            var r = n.dot(this.direction);
            return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new THREE.Vector3;
            return function(e) {
                var n = t.subVectors(e, this.origin).dot(this.direction);
                return 0 > n ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                n = new THREE.Vector3;
            return function(r, i, o, a) {
                t.copy(r).add(i).multiplyScalar(.5), e.copy(i).sub(r).normalize(), n.copy(this.origin).sub(t);
                var s, u = .5 * r.distanceTo(i),
                    h = -this.direction.dot(e),
                    c = n.dot(this.direction),
                    l = -n.dot(e),
                    p = n.lengthSq(),
                    f = Math.abs(1 - h * h);
                return 0 < f ? (i = h * c - l, s = u * f, 0 <= (r = h * l - c) ? i >= -s ? i <= s ? h = (r *= u = 1 / f) * (r + h * (i *= u) + 2 * c) + i * (h * r + i + 2 * l) + p : (i = u, h = -(r = Math.max(0, -(h * i + c))) * r + i * (i + 2 * l) + p) : (i = -u, h = -(r = Math.max(0, -(h * i + c))) * r + i * (i + 2 * l) + p) : i <= -s ? h = -(r = Math.max(0, -(-h * u + c))) * r + (i = 0 < r ? -u : Math.min(Math.max(-u, -l), u)) * (i + 2 * l) + p : i <= s ? (r = 0, h = (i = Math.min(Math.max(-u, -l), u)) * (i + 2 * l) + p) : h = -(r = Math.max(0, -(h * u + c))) * r + (i = 0 < r ? u : Math.min(Math.max(-u, -l), u)) * (i + 2 * l) + p) : (i = 0 < h ? -u : u, h = -(r = Math.max(0, -(h * i + c))) * r + i * (i + 2 * l) + p), o && o.copy(this.direction).multiplyScalar(r).add(this.origin), a && a.copy(e).multiplyScalar(i).add(t), h
            }
        }(),
        isIntersectionSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        intersectSphere: function() {
            var t = new THREE.Vector3;
            return function(e, n) {
                t.subVectors(e.center, this.origin);
                var r = t.dot(this.direction),
                    i = t.dot(t) - r * r,
                    o = e.radius * e.radius;
                return i > o ? null : (i = r - (o = Math.sqrt(o - i)), r += o, 0 > i && 0 > r ? null : 0 > i ? this.at(r, n) : this.at(i, n))
            }
        }(),
        isIntersectionPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || 0 > t.normal.dot(this.direction) * e
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null
        },
        intersectPlane: function(t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        isIntersectionBox: function() {
            var t = new THREE.Vector3;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectBox: function(t, e) {
            var n, r, i, o, a;
            r = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z;
            var s = this.origin;
            return 0 <= r ? (n = (t.min.x - s.x) * r, r *= t.max.x - s.x) : (n = (t.max.x - s.x) * r, r *= t.min.x - s.x), 0 <= o ? (i = (t.min.y - s.y) * o, o *= t.max.y - s.y) : (i = (t.max.y - s.y) * o, o *= t.min.y - s.y), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), 0 <= a ? (i = (t.min.z - s.z) * a, a *= t.max.z - s.z) : (i = (t.max.z - s.z) * a, a *= t.min.z - s.z), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), 0 > r ? null : this.at(0 <= n ? n : r, e)))
        },
        intersectTriangle: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                n = new THREE.Vector3,
                r = new THREE.Vector3;
            return function(i, o, a, s, u) {
                if (e.subVectors(o, i), n.subVectors(a, i), r.crossVectors(e, n), 0 < (o = this.direction.dot(r))) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > o)) return null;
                    s = -1, o = -o
                }
                return t.subVectors(this.origin, i), 0 > (i = s * this.direction.dot(n.crossVectors(t, n))) ? null : 0 > (a = s * this.direction.dot(e.cross(t))) || i + a > o ? null : 0 > (i = -s * t.dot(r)) ? null : this.at(i / o, u)
            }
        }(),
        applyMatrix4: function(t) {
            return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }, THREE.Sphere = function(t, e) {
        this.center = void 0 !== t ? t : new THREE.Vector3, this.radius = void 0 !== e ? e : 0
    }, THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function() {
            var t = new THREE.Box3;
            return function(e, n) {
                var r = this.center;
                void 0 !== n ? r.copy(n) : t.setFromPoints(e).center(r);
                for (var i = 0, o = 0, a = e.length; o < a; o++) i = Math.max(i, r.distanceToSquared(e[o]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t),
                r = e || new THREE.Vector3;
            return r.copy(t), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
        },
        getBoundingBox: function(t) {
            return (t = t || new THREE.Box3).set(this.center, this.center), t.expandByScalar(this.radius), t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }, THREE.Frustum = function(t, e, n, r, i, o) {
        this.planes = [void 0 !== t ? t : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== o ? o : new THREE.Plane]
    }, THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function(t, e, n, r, i, o) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, n = 0; 6 > n; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes;
            t = (m = t.elements)[0];
            var n = m[1],
                r = m[2],
                i = m[3],
                o = m[4],
                a = m[5],
                s = m[6],
                u = m[7],
                h = m[8],
                c = m[9],
                l = m[10],
                p = m[11],
                f = m[12],
                d = m[13],
                E = m[14],
                m = m[15];
            return e[0].setComponents(i - t, u - o, p - h, m - f).normalize(), e[1].setComponents(i + t, u + o, p + h, m + f).normalize(), e[2].setComponents(i + n, u + a, p + c, m + d).normalize(), e[3].setComponents(i - n, u - a, p - c, m - d).normalize(), e[4].setComponents(i - r, u - s, p - l, m - E).normalize(), e[5].setComponents(i + r, u + s, p + l, m + E).normalize(), this
        },
        intersectsObject: function() {
            var t = new THREE.Sphere;
            return function(e) {
                var n = e.geometry;
                return null === n.boundingSphere && n.computeBoundingSphere(), t.copy(n.boundingSphere), t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            var e = this.planes,
                n = t.center;
            t = -t.radius;
            for (var r = 0; 6 > r; r++)
                if (e[r].distanceToPoint(n) < t) return !1;
            return !0
        },
        intersectsBox: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(n) {
                for (var r = this.planes, i = 0; 6 > i; i++) {
                    var o = r[i];
                    t.x = 0 < o.normal.x ? n.min.x : n.max.x, e.x = 0 < o.normal.x ? n.max.x : n.min.x, t.y = 0 < o.normal.y ? n.min.y : n.max.y, e.y = 0 < o.normal.y ? n.max.y : n.min.y, t.z = 0 < o.normal.z ? n.min.z : n.max.z, e.z = 0 < o.normal.z ? n.max.z : n.min.z;
                    var a = o.distanceToPoint(t);
                    o = o.distanceToPoint(e);
                    if (0 > a && 0 > o) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, n = 0; 6 > n; n++)
                if (0 > e[n].distanceToPoint(t)) return !1;
            return !0
        }
    }, THREE.Plane = function(t, e) {
        this.normal = void 0 !== t ? t : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }, THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, n, r) {
            return this.normal.set(t, e, n), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(n, r, i) {
                return r = t.subVectors(i, r).cross(e.subVectors(n, r)).normalize(), this.setFromNormalAndCoplanarPoint(r, n), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return this.orthoPoint(t, e).sub(t).negate()
        },
        orthoPoint: function(t, e) {
            var n = this.distanceToPoint(t);
            return (e || new THREE.Vector3).copy(this.normal).multiplyScalar(n)
        },
        isIntersectionLine: function(t) {
            var e = this.distanceToPoint(t.start);
            return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e
        },
        intersectLine: function() {
            var t = new THREE.Vector3;
            return function(e, n) {
                var r = n || new THREE.Vector3,
                    i = e.delta(t),
                    o = this.normal.dot(i);
                return 0 !== o ? 0 > (o = -(e.start.dot(this.normal) + this.constant) / o) || 1 < o ? void 0 : r.copy(i).multiplyScalar(o).add(e.start) : 0 === this.distanceToPoint(e.start) ? r.copy(e.start) : void 0
            }
        }(),
        coplanarPoint: function(t) {
            return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                n = new THREE.Matrix3;
            return function(r, i) {
                var o = i || n.getNormalMatrix(r),
                    a = (o = t.copy(this.normal).applyMatrix3(o), this.coplanarPoint(e));
                return a.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(o, a), this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }, THREE.Math = {
        generateUUID: function() {
            var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                n = Array(36),
                r = 0;
            return function() {
                for (var i = 0; 36 > i; i++) 8 === i || 13 === i || 18 === i || 23 === i ? n[i] = "-" : 14 === i ? n[i] = "4" : (2 >= r && (r = 33554432 + 16777216 * Math.random() | 0), t = 15 & r, r >>= 4, n[i] = e[19 === i ? 3 & t | 8 : t]);
                return n.join("")
            }
        }(),
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, r, i) {
            return r + (t - e) * (i - r) / (n - e)
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        random16: function() {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function() {
            var t = Math.PI / 180;
            return function(e) {
                return e * t
            }
        }(),
        radToDeg: function() {
            var t = 180 / Math.PI;
            return function(e) {
                return e * t
            }
        }(),
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        nearestPowerOfTwo: function(t) {
            return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
        },
        nextPowerOfTwo: function(t) {
            return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
        }
    }, THREE.Spline = function(t) {
        function e(t, e, n, r, i, o, a) {
            return (2 * (e - n) + (t = .5 * (n - t)) + (r = .5 * (r - e))) * a + (-3 * (e - n) - 2 * t - r) * o + t * i + e
        }
        this.points = t;
        var n, r, i, o, a, s, u, h, c, l = [],
            p = {
                x: 0,
                y: 0,
                z: 0
            };
        this.initFromArray = function(t) {
            this.points = [];
            for (var e = 0; e < t.length; e++) this.points[e] = {
                x: t[e][0],
                y: t[e][1],
                z: t[e][2]
            }
        }, this.getPoint = function(t) {
            return n = (this.points.length - 1) * t, r = Math.floor(n), i = n - r, l[0] = 0 === r ? r : r - 1, l[1] = r, l[2] = r > this.points.length - 2 ? this.points.length - 1 : r + 1, l[3] = r > this.points.length - 3 ? this.points.length - 1 : r + 2, s = this.points[l[0]], u = this.points[l[1]], h = this.points[l[2]], c = this.points[l[3]], a = i * (o = i * i), p.x = e(s.x, u.x, h.x, c.x, i, o, a), p.y = e(s.y, u.y, h.y, c.y, i, o, a), p.z = e(s.z, u.z, h.z, c.z, i, o, a), p
        }, this.getControlPointsArray = function() {
            var t, e, n = this.points.length,
                r = [];
            for (t = 0; t < n; t++) e = this.points[t], r[t] = [e.x, e.y, e.z];
            return r
        }, this.getLength = function(t) {
            var e, n, r, i = e = e = 0,
                o = new THREE.Vector3,
                a = new THREE.Vector3,
                s = [],
                u = 0;
            for (s[0] = 0, t || (t = 100), n = this.points.length * t, o.copy(this.points[0]), t = 1; t < n; t++) e = t / n, r = this.getPoint(e), a.copy(r), u += a.distanceTo(o), o.copy(r), e *= this.points.length - 1, (e = Math.floor(e)) !== i && (s[e] = u, i = e);
            return s[s.length] = u, {
                chunks: s,
                total: u
            }
        }, this.reparametrizeByArcLength = function(t) {
            var e, n, r, i, o, a, s = [],
                u = new THREE.Vector3,
                h = this.getLength();
            for (s.push(u.copy(this.points[0]).clone()), e = 1; e < this.points.length; e++) {
                for (n = h.chunks[e] - h.chunks[e - 1], a = Math.ceil(t * n / h.total), i = (e - 1) / (this.points.length - 1), o = e / (this.points.length - 1), n = 1; n < a - 1; n++) r = i + 1 / a * n * (o - i), r = this.getPoint(r), s.push(u.copy(r).clone());
                s.push(u.copy(this.points[e]).clone())
            }
            this.points = s
        }
    }, THREE.Triangle = function(t, e, n) {
        this.a = void 0 !== t ? t : new THREE.Vector3, this.b = void 0 !== e ? e : new THREE.Vector3, this.c = void 0 !== n ? n : new THREE.Vector3
    }, THREE.Triangle.normal = function() {
        var t = new THREE.Vector3;
        return function(e, n, r, i) {
            return (i = i || new THREE.Vector3).subVectors(r, n), t.subVectors(e, n), i.cross(t), 0 < (e = i.lengthSq()) ? i.multiplyScalar(1 / Math.sqrt(e)) : i.set(0, 0, 0)
        }
    }(), THREE.Triangle.barycoordFromPoint = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3,
            n = new THREE.Vector3;
        return function(r, i, o, a, s) {
            t.subVectors(a, i), e.subVectors(o, i), n.subVectors(r, i), r = t.dot(t), i = t.dot(e), o = t.dot(n);
            var u = e.dot(e);
            a = e.dot(n);
            var h = r * u - i * i;
            return s = s || new THREE.Vector3, 0 === h ? s.set(-2, -1, -1) : (u = (u * o - i * a) * (h = 1 / h), r = (r * a - i * o) * h, s.set(1 - u - r, r, u))
        }
    }(), THREE.Triangle.containsPoint = function() {
        var t = new THREE.Vector3;
        return function(e, n, r, i) {
            return 0 <= (e = THREE.Triangle.barycoordFromPoint(e, n, r, i, t)).x && 0 <= e.y && 1 >= e.x + e.y
        }
    }(), THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        },
        setFromPointsAndIndices: function(t, e, n, r) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        area: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function() {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(),
        midpoint: function(t) {
            return (t || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(t) {
            return THREE.Triangle.normal(this.a, this.b, this.c, t)
        },
        plane: function(t) {
            return (t || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(t, e) {
            return THREE.Triangle.barycoordFromPoint(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return THREE.Triangle.containsPoint(t, this.a, this.b, this.c)
        },
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }, THREE.Channels = function() {
        this.mask = 1
    }, THREE.Channels.prototype = {
        constructor: THREE.Channels,
        set: function(t) {
            this.mask = 1 << t
        },
        enable: function(t) {
            this.mask |= 1 << t
        },
        toggle: function(t) {
            this.mask ^= 1 << t
        },
        disable: function(t) {
            this.mask &= ~(1 << t)
        }
    }, THREE.Clock = function(t) {
        this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }, THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function() {
            this.oldTime = this.startTime = self.performance.now(), this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var e = self.performance.now();
                t = .001 * (e - this.oldTime);
                this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    }, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function(t) {
            t.addEventListener = THREE.EventDispatcher.prototype.addEventListener, t.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, t.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, t.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        },
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var r = n.indexOf(e); - 1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = [], r = e.length, i = 0; i < r; i++) n[i] = e[i];
                    for (i = 0; i < r; i++) n[i].call(this, t)
                }
            }
        }
    },
    function(t) {
        function e(t, e) {
            return t.distance - e.distance
        }

        function n(t, e, r, i) {
            if (!1 !== t.visible && (t.raycast(e, r), !0 === i)) {
                i = 0;
                for (var o = (t = t.children).length; i < o; i++) n(t[i], e, r, !0)
            }
        }
        t.Raycaster = function(e, n, r, i) {
            this.ray = new t.Ray(e, n), this.near = r || 0, this.far = i || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }, t.Raycaster.prototype = {
            constructor: t.Raycaster,
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(e, n) {
                n instanceof t.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(n).sub(this.ray.origin).normalize()) : n instanceof t.OrthographicCamera ? (this.ray.origin.set(e.x, e.y, -1).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, r) {
                var i = [];
                return n(t, this, i, r), i.sort(e), i
            },
            intersectObjects: function(t, r) {
                var i = [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var o = 0, a = t.length; o < a; o++) n(t[o], this, i, r);
                return i.sort(e), i
            }
        }
    }(THREE), THREE.Object3D = function() {
        Object.defineProperty(this, "id", {
            value: THREE.Object3DIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.channels = new THREE.Channels, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
        var t = new THREE.Vector3,
            e = new THREE.Euler,
            n = new THREE.Quaternion,
            r = new THREE.Vector3(1, 1, 1);
        e.onChange(function() {
            n.setFromEuler(e, !1)
        }), n.onChange(function() {
            e.setFromQuaternion(n, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: n
            },
            scale: {
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new THREE.Matrix4
            },
            normalMatrix: {
                value: new THREE.Matrix3
            }
        }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.DefaultMatrixAutoUpdate = !0, THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        get eulerOrder() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
        },
        set eulerOrder(t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
        },
        get useQuaternion() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set useQuaternion(t) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set renderDepth(t) {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new THREE.Quaternion;
            return function(e, n) {
                return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
            }
        }(),
        rotateX: function() {
            var t = new THREE.Vector3(1, 0, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new THREE.Vector3(0, 1, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new THREE.Vector3(0, 0, 1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new THREE.Vector3;
            return function(e, n) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
            }
        }(),
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        translateX: function() {
            var t = new THREE.Vector3(1, 0, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new THREE.Vector3(0, 1, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new THREE.Vector3(0, 0, 1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new THREE.Matrix4;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new THREE.Matrix4;
            return function(e) {
                t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function(t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t instanceof THREE.Object3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                type: "added"
            }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function(t) {
            if (1 < arguments.length)
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]); - 1 !== (e = this.children.indexOf(t)) && (t.parent = null, t.dispatchEvent({
                type: "removed"
            }), this.children.splice(e, 1))
        },
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function(t) {
            return t = t || new THREE.Vector3, this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3;
            return function(n) {
                return n = n || new THREE.Quaternion, this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
            }
        }(),
        getWorldRotation: function() {
            var t = new THREE.Quaternion;
            return function(e) {
                return e = e || new THREE.Euler, this.getWorldQuaternion(t), e.setFromQuaternion(t, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var t = new THREE.Vector3,
                e = new THREE.Quaternion;
            return function(n) {
                return n = n || new THREE.Vector3, this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
            }
        }(),
        getWorldDirection: function() {
            var t = new THREE.Quaternion;
            return function(e) {
                return e = e || new THREE.Vector3, this.getWorldQuaternion(t), e.set(0, 0, 1).applyQuaternion(t)
            }
        }(),
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== t || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = 0, n = this.children.length; e < n; e++) this.children[e].updateMatrixWorld(t)
        },
        toJSON: function(t) {
            function e(t) {
                var e, n = [];
                for (e in t) {
                    var r = t[e];
                    delete r.metadata, n.push(r)
                }
                return n
            }
            var n = {};
            (o = void 0 === t) && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, n.metadata = {
                version: 4.4,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r = {};
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), r.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), r.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), r.material = this.material.uuid), 0 < this.children.length) {
                r.children = [];
                for (var i = 0; i < this.children.length; i++) r.children.push(this.children[i].toJSON(t).object)
            }
            if (o) {
                var o = e(t.geometries),
                    a = (i = e(t.materials), e(t.textures));
                t = e(t.images), 0 < o.length && (n.geometries = o), 0 < i.length && (n.materials = i), 0 < a.length && (n.textures = a), 0 < t.length && (n.images = t)
            }
            return n.object = r, n
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.rotationAutoUpdate = t.rotationAutoUpdate, this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var n = 0; n < t.children.length; n++) this.add(t.children[n].clone());
            return this
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Face3 = function(t, e, n, r, i, o) {
        this.a = t, this.b = e, this.c = n, this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i instanceof THREE.Color ? i : new THREE.Color, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
    }, THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    }, THREE.Face4 = function(t, e, n, r, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(t, e, n, i, o, a)
    }, THREE.BufferAttribute = function(t, e) {
        this.uuid = THREE.Math.generateUUID(), this.array = t, this.itemSize = e, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }, THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute,
        get length() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
        },
        get count() {
            return this.array.length / this.itemSize
        },
        set needsUpdate(t) {
            !0 === t && this.version++
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t), this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new THREE.Color), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
            }
            return this
        },
        copyIndicesArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                e[n++] = o.a, e[n++] = o.b, e[n++] = o.c
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new THREE.Vector2), e[n++] = o.x, e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new THREE.Vector3), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new THREE.Vector4), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
        },
        setXYZW: function(t, e, n, r, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }, THREE.Int8Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Int8Array(t), e)
    }, THREE.Uint8Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Uint8Array(t), e)
    }, THREE.Uint8ClampedAttribute = function(t, e) {
        return new THREE.BufferAttribute(new Uint8ClampedArray(t), e)
    }, THREE.Int16Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Int16Array(t), e)
    }, THREE.Uint16Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Uint16Array(t), e)
    }, THREE.Int32Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Int32Array(t), e)
    }, THREE.Uint32Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Uint32Array(t), e)
    }, THREE.Float32Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Float32Array(t), e)
    }, THREE.Float64Attribute = function(t, e) {
        return new THREE.BufferAttribute(new Float64Array(t), e)
    }, THREE.DynamicBufferAttribute = function(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new THREE.BufferAttribute(t, e).setDynamic(!0)
    }, THREE.InstancedBufferAttribute = function(t, e, n) {
        THREE.BufferAttribute.call(this, t, e), this.meshPerAttribute = n || 1
    }, THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute, THREE.InstancedBufferAttribute.prototype.copy = function(t) {
        return THREE.BufferAttribute.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
    }, THREE.InterleavedBuffer = function(t, e) {
        this.uuid = THREE.Math.generateUUID(), this.array = t, this.stride = e, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }, THREE.InterleavedBuffer.prototype = {
        constructor: THREE.InterleavedBuffer,
        get length() {
            return this.array.length
        },
        get count() {
            return this.array.length / this.stride
        },
        set needsUpdate(t) {
            !0 === t && this.version++
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            this.array = new t.array.constructor(t.array), this.stride = t.stride, this.dynamic = t.dynamic
        },
        copyAt: function(t, e, n) {
            t *= this.stride, n *= e.stride;
            for (var r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }, THREE.InstancedInterleavedBuffer = function(t, e, n) {
        THREE.InterleavedBuffer.call(this, t, e), this.meshPerAttribute = n || 1
    }, THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype), THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer, THREE.InstancedInterleavedBuffer.prototype.copy = function(t) {
        return THREE.InterleavedBuffer.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
    }, THREE.InterleavedBufferAttribute = function(t, e, n) {
        this.uuid = THREE.Math.generateUUID(), this.data = t, this.itemSize = e, this.offset = n
    }, THREE.InterleavedBufferAttribute.prototype = {
        constructor: THREE.InterleavedBufferAttribute,
        get length() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
        },
        get count() {
            return this.data.array.length / this.data.stride
        },
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
        },
        setXYZW: function(t, e, n, r, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
        }
    }, THREE.Geometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
    }, THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function(t) {
            for (var e = (new THREE.Matrix3).getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(t);
            for (n = 0, r = this.faces.length; n < r; n++) {
                (t = this.faces[n]).normal.applyMatrix3(e).normalize();
                for (var i = 0, o = t.vertexNormals.length; i < o; i++) t.vertexNormals[i].applyMatrix3(e).normalize()
            }
            null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0
        },
        rotateX: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t;
            return function(e, n, r) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeTranslation(e, n, r), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t;
            return function(e, n, r) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeScale(e, n, r), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t;
            return function(e) {
                void 0 === t && (t = new THREE.Object3D), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        fromBufferGeometry: function(t) {
            function e(t, e, r) {
                var i = void 0 !== a ? [c[t].clone(), c[e].clone(), c[r].clone()] : [],
                    o = void 0 !== s ? [n.colors[t].clone(), n.colors[e].clone(), n.colors[r].clone()] : [];
                i = new THREE.Face3(t, e, r, i, o);
                n.faces.push(i), void 0 !== u && n.faceVertexUvs[0].push([l[t].clone(), l[e].clone(), l[r].clone()]), void 0 !== h && n.faceVertexUvs[1].push([p[t].clone(), p[e].clone(), p[r].clone()])
            }
            var n = this,
                r = null !== t.index ? t.index.array : void 0,
                i = t.attributes,
                o = i.position.array,
                a = void 0 !== i.normal ? i.normal.array : void 0,
                s = void 0 !== i.color ? i.color.array : void 0,
                u = void 0 !== i.uv ? i.uv.array : void 0,
                h = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== h && (this.faceVertexUvs[1] = []);
            for (var c = [], l = [], p = [], f = i = 0; i < o.length; i += 3, f += 2) n.vertices.push(new THREE.Vector3(o[i], o[i + 1], o[i + 2])), void 0 !== a && c.push(new THREE.Vector3(a[i], a[i + 1], a[i + 2])), void 0 !== s && n.colors.push(new THREE.Color(s[i], s[i + 1], s[i + 2])), void 0 !== u && l.push(new THREE.Vector2(u[f], u[f + 1])), void 0 !== h && p.push(new THREE.Vector2(h[f], h[f + 1]));
            if (void 0 !== r)
                if (0 < (o = t.groups).length)
                    for (i = 0; i < o.length; i++) {
                        var d = (f = o[i]).start,
                            E = f.count;
                        for (f = d, d = d + E; f < d; f += 3) e(r[f], r[f + 1], r[f + 2])
                    } else
                        for (i = 0; i < r.length; i += 3) e(r[i], r[i + 1], r[i + 2]);
                else
                    for (i = 0; i < o.length / 3; i += 3) e(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.center().negate();
            return this.translate(t.x, t.y, t.z), t
        },
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = 0 === (e = this.boundingSphere.radius) ? 1 : 1 / e,
                n = new THREE.Matrix4;
            return n.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
        },
        computeFaceNormals: function() {
            for (var t = new THREE.Vector3, e = new THREE.Vector3, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b];
                t.subVectors(this.vertices[i.c], a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, n, r;
            for (r = Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) r[e] = new THREE.Vector3;
            if (t) {
                var i, o, a, s = new THREE.Vector3,
                    u = new THREE.Vector3;
                for (t = 0, e = this.faces.length; t < e; t++) n = this.faces[t], i = this.vertices[n.a], o = this.vertices[n.b], a = this.vertices[n.c], s.subVectors(a, o), u.subVectors(i, o), s.cross(u), r[n.a].add(s), r[n.b].add(s), r[n.c].add(s)
            } else
                for (t = 0, e = this.faces.length; t < e; t++) r[(n = this.faces[t]).a].add(n.normal), r[n.b].add(n.normal), r[n.c].add(n.normal);
            for (e = 0, n = this.vertices.length; e < n; e++) r[e].normalize();
            for (t = 0, e = this.faces.length; t < e; t++) 3 === (i = (n = this.faces[t]).vertexNormals).length ? (i[0].copy(r[n.a]), i[1].copy(r[n.b]), i[2].copy(r[n.c])) : (i[0] = r[n.a].clone(), i[1] = r[n.b].clone(), i[2] = r[n.c].clone())
        },
        computeMorphNormals: function() {
            var t, e, n, r, i;
            for (n = 0, r = this.faces.length; n < r; n++)
                for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), t = 0, e = i.vertexNormals.length; t < e; t++) i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone();
            var o = new THREE.Geometry;
            for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [], i = this.morphNormals[t].faceNormals;
                    var a, s, u = this.morphNormals[t].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++) a = new THREE.Vector3, s = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, i.push(a), u.push(s)
                }
                for (u = this.morphNormals[t], o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], a = u.faceNormals[n], s = u.vertexNormals[n], a.copy(i.normal), s.a.copy(i.vertexNormals[0]), s.b.copy(i.vertexNormals[1]), s.c.copy(i.vertexNormals[2])
            }
            for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeTangents: function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            for (var t = 0, e = this.vertices, n = 0, r = e.length; n < r; n++) 0 < n && (t += e[n].distanceTo(e[n - 1])), this.lineDistances[n] = t
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (!1 == t instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
            else {
                var r, i = this.vertices.length,
                    o = this.vertices,
                    a = t.vertices,
                    s = this.faces,
                    u = t.faces,
                    h = this.faceVertexUvs[0];
                t = t.faceVertexUvs[0], void 0 === n && (n = 0), void 0 !== e && (r = (new THREE.Matrix3).getNormalMatrix(e));
                for (var c = 0, l = a.length; c < l; c++) {
                    var p = a[c].clone();
                    void 0 !== e && p.applyMatrix4(e), o.push(p)
                }
                for (c = 0, l = u.length; c < l; c++) {
                    var f, d = (a = u[c]).vertexNormals,
                        E = a.vertexColors;
                    for ((p = new THREE.Face3(a.a + i, a.b + i, a.c + i)).normal.copy(a.normal), void 0 !== r && p.normal.applyMatrix3(r).normalize(), e = 0, o = d.length; e < o; e++) f = d[e].clone(), void 0 !== r && f.applyMatrix3(r).normalize(), p.vertexNormals.push(f);
                    for (p.color.copy(a.color), e = 0, o = E.length; e < o; e++) f = E[e], p.vertexColors.push(f.clone());
                    p.materialIndex = a.materialIndex + n, s.push(p)
                }
                for (c = 0, l = t.length; c < l; c++)
                    if (r = [], void 0 !== (n = t[c])) {
                        for (e = 0, o = n.length; e < o; e++) r.push(n[e].clone());
                        h.push(r)
                    }
            }
        },
        mergeMesh: function(t) {
            !1 == t instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
        },
        mergeVertices: function() {
            var t, e, n, r = {},
                i = [],
                o = [],
                a = Math.pow(10, 4);
            for (e = 0, n = this.vertices.length; e < n; e++) t = this.vertices[e], void 0 === r[t = Math.round(t.x * a) + "_" + Math.round(t.y * a) + "_" + Math.round(t.z * a)] ? (r[t] = e, i.push(this.vertices[e]), o[e] = i.length - 1) : o[e] = o[r[t]];
            for (r = [], e = 0, n = this.faces.length; e < n; e++)
                for ((a = this.faces[e]).a = o[a.a], a.b = o[a.b], a.c = o[a.c], a = [a.a, a.b, a.c], t = 0; 3 > t; t++)
                    if (a[t] === a[(t + 1) % 3]) {
                        r.push(e);
                        break
                    }
            for (e = r.length - 1; 0 <= e; e--)
                for (a = r[e], this.faces.splice(a, 1), o = 0, n = this.faceVertexUvs.length; o < n; o++) this.faceVertexUvs[o].splice(a, 1);
            return e = this.vertices.length - i.length, this.vertices = i, e
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var r, i, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            for (o && o.length === e && (r = []), a && a.length === e && (i = []), n = 0; n < e; n++) {
                var s = t[n]._id;
                r && r.push(o[s]), i && i.push(a[s])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            function t(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }

            function e(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== h[e] ? h[e] : (h[e] = u.length / 3, u.push(t.x, t.y, t.z), h[e])
            }

            function n(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== l[e] ? l[e] : (l[e] = c.length, c.push(t.getHex()), l[e])
            }

            function r(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== f[e] ? f[e] : (f[e] = p.length / 2, p.push(t.x, t.y), f[e])
            }
            var i = {
                metadata: {
                    version: 4.4,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), void 0 !== this.parameters) {
                var o, a = this.parameters;
                for (o in a) void 0 !== a[o] && (i[o] = a[o]);
                return i
            }
            for (a = [], o = 0; o < this.vertices.length; o++) {
                var s = this.vertices[o];
                a.push(s.x, s.y, s.z)
            }
            s = [];
            var u = [],
                h = {},
                c = [],
                l = {},
                p = [],
                f = {};
            for (o = 0; o < this.faces.length; o++) {
                var d = this.faces[o],
                    E = void 0 !== this.faceVertexUvs[0][o],
                    m = 0 < d.normal.length(),
                    g = 0 < d.vertexNormals.length,
                    v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                    y = 0 < d.vertexColors.length,
                    T = t(T = t(T = t(T = t(T = t(T = t(T = t(T = t(T = 0, 0, 0), 1, !1), 2, !1), 3, E), 4, m), 5, g), 6, v), 7, y);
                s.push(T), s.push(d.a, d.b, d.c), E && (E = this.faceVertexUvs[0][o], s.push(r(E[0]), r(E[1]), r(E[2]))), m && s.push(e(d.normal)), g && (m = d.vertexNormals, s.push(e(m[0]), e(m[1]), e(m[2]))), v && s.push(n(d.color)), y && (d = d.vertexColors, s.push(n(d[0]), n(d[1]), n(d[2])))
            }
            return i.data = {}, i.data.vertices = a, i.data.normals = u, 0 < c.length && (i.data.colors = c), 0 < p.length && (i.data.uvs = [p]), i.data.faces = s, i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.vertices = [], this.faces = [], this.faceVertexUvs = [
                []
            ];
            for (var e = t.vertices, n = 0, r = e.length; n < r; n++) this.vertices.push(e[n].clone());
            for (n = 0, r = (e = t.faces).length; n < r; n++) this.faces.push(e[n].clone());
            for (n = 0, r = t.faceVertexUvs.length; n < r; n++) {
                e = t.faceVertexUvs[n], void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []);
                for (var i = 0, o = e.length; i < o; i++) {
                    for (var a = e[i], s = [], u = 0, h = a.length; u < h; u++) s.push(a[u].clone());
                    this.faceVertexUvs[n].push(s)
                }
            }
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.DirectGeometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }, THREE.DirectGeometry.prototype = {
        constructor: THREE.DirectGeometry,
        computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
        computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
        computeFaceNormals: function() {
            console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
        },
        computeVertexNormals: function() {
            console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
        },
        computeGroups: function(t) {
            var e, n, r = [];
            t = t.faces;
            for (var i = 0; i < t.length; i++) {
                var o = t[i];
                o.materialIndex !== n && (n = o.materialIndex, void 0 !== e && (e.count = 3 * i - e.start, r.push(e)), e = {
                    start: 3 * i,
                    materialIndex: n
                })
            }
            void 0 !== e && (e.count = 3 * i - e.start, r.push(e)), this.groups = r
        },
        fromGeometry: function(t) {
            var e = t.faces,
                n = t.vertices,
                r = t.faceVertexUvs,
                i = r[0] && 0 < r[0].length,
                o = r[1] && 0 < r[1].length,
                a = t.morphTargets,
                s = a.length;
            if (0 < s) {
                for (var u = [], h = 0; h < s; h++) u[h] = [];
                this.morphTargets.position = u
            }
            var c = t.morphNormals,
                l = c.length;
            if (0 < l) {
                var p = [];
                for (h = 0; h < l; h++) p[h] = [];
                this.morphTargets.normal = p
            }
            var f = t.skinIndices,
                d = t.skinWeights,
                E = f.length === n.length,
                m = d.length === n.length;
            for (h = 0; h < e.length; h++) {
                var g = e[h];
                this.vertices.push(n[g.a], n[g.b], n[g.c]);
                var v = g.vertexNormals;
                for (3 === v.length ? this.normals.push(v[0], v[1], v[2]) : (v = g.normal, this.normals.push(v, v, v)), 3 === (v = g.vertexColors).length ? this.colors.push(v[0], v[1], v[2]) : (v = g.color, this.colors.push(v, v, v)), !0 === i && (void 0 !== (v = r[0][h]) ? this.uvs.push(v[0], v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))), !0 === o && (void 0 !== (v = r[1][h]) ? this.uvs2.push(v[0], v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))), v = 0; v < s; v++) {
                    var y = a[v].vertices;
                    u[v].push(y[g.a], y[g.b], y[g.c])
                }
                for (v = 0; v < l; v++) y = c[v].vertexNormals[h], p[v].push(y.a, y.b, y.c);
                E && this.skinIndices.push(f[g.a], f[g.b], f[g.c]), m && this.skinWeights.push(d[g.a], d[g.b], d[g.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype), THREE.BufferGeometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }, THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            this.index = t
        },
        addAttribute: function(t, e, n) {
            !1 == e instanceof THREE.BufferAttribute && !1 == e instanceof THREE.InterleavedBufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new THREE.BufferAttribute(e, n))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e)) : this.attributes[t] = e
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            delete this.attributes[t]
        },
        get drawcalls() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
        },
        get offsets() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToVector3Array(e.array), e.needsUpdate = !0), void 0 !== (e = this.attributes.normal) && ((new THREE.Matrix3).getNormalMatrix(t).applyToVector3Array(e.array), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere()
        },
        rotateX: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t;
            return function(e) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t;
            return function(e, n, r) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeTranslation(e, n, r), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t;
            return function(e, n, r) {
                return void 0 === t && (t = new THREE.Matrix4), t.makeScale(e, n, r), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t;
            return function(e) {
                void 0 === t && (t = new THREE.Object3D), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.center().negate();
            return this.translate(t.x, t.y, t.z), t
        },
        setFromObject: function(t) {
            var e = t.geometry;
            if (t instanceof THREE.Points || t instanceof THREE.Line) {
                t = new THREE.Float32Attribute(3 * e.vertices.length, 3);
                var n = new THREE.Float32Attribute(3 * e.colors.length, 3);
                this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new THREE.Float32Attribute(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t instanceof THREE.Mesh && e instanceof THREE.Geometry && this.fromGeometry(e);
            return this
        },
        updateFromObject: function(t) {
            var e = t.geometry;
            if (t instanceof THREE.Mesh) {
                var n = e.__directGeometry;
                if (void 0 === n) return this.fromGeometry(e);
                n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n
            }
            return !0 === e.verticesNeedUpdate && (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new THREE.DirectGeometry).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            for (var n in this.addAttribute("position", new THREE.BufferAttribute(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new THREE.BufferAttribute(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new THREE.BufferAttribute(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new THREE.BufferAttribute(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new THREE.BufferAttribute(e, 2).copyVector2sArray(t.uvs2))), 0 < t.indices.length && (e = new(65535 < t.vertices.length ? Uint32Array : Uint16Array)(3 * t.indices.length), this.setIndex(new THREE.BufferAttribute(e, 1).copyIndicesArray(t.indices))), this.groups = t.groups, t.morphTargets) {
                e = [];
                for (var r = t.morphTargets[n], i = 0, o = r.length; i < o; i++) {
                    var a = r[i],
                        s = new THREE.Float32Attribute(3 * a.length, 3);
                    e.push(s.copyVector3sArray(a))
                }
                this.morphAttributes[n] = e
            }
            return 0 < t.skinIndices.length && (n = new THREE.Float32Attribute(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", n.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (n = new THREE.Float32Attribute(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", n.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            var t = new THREE.Vector3;
            return function() {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                var e = this.attributes.position.array;
                if (e) {
                    var n = this.boundingBox;
                    n.makeEmpty();
                    for (var r = 0, i = e.length; r < i; r += 3) t.fromArray(e, r), n.expandByPoint(t)
                }
                void 0 !== e && 0 !== e.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function() {
            var t = new THREE.Box3,
                e = new THREE.Vector3;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var n = this.attributes.position.array;
                if (n) {
                    t.makeEmpty();
                    for (var r = this.boundingSphere.center, i = 0, o = n.length; i < o; i += 3) e.fromArray(n, i), t.expandByPoint(e);
                    t.center(r);
                    var a = 0;
                    for (i = 0, o = n.length; i < o; i += 3) e.fromArray(n, i), a = Math.max(a, r.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index,
                e = this.attributes,
                n = this.groups;
            if (e.position) {
                var r = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(r.length), 3));
                else
                    for (var i = 0, o = (h = e.normal.array).length; i < o; i++) h[i] = 0;
                var a, s, u, h = e.normal.array,
                    c = new THREE.Vector3,
                    l = new THREE.Vector3,
                    p = new THREE.Vector3,
                    f = new THREE.Vector3,
                    d = new THREE.Vector3;
                if (t) {
                    t = t.array, 0 === n.length && this.addGroup(0, t.length);
                    for (var E = 0, m = n.length; E < m; ++E)
                        for (o = (i = n[E]).start, a = i.count, i = o, o += a; i < o; i += 3) a = 3 * t[i + 0], s = 3 * t[i + 1], u = 3 * t[i + 2], c.fromArray(r, a), l.fromArray(r, s), p.fromArray(r, u), f.subVectors(p, l), d.subVectors(c, l), f.cross(d), h[a] += f.x, h[a + 1] += f.y, h[a + 2] += f.z, h[s] += f.x, h[s + 1] += f.y, h[s + 2] += f.z, h[u] += f.x, h[u + 1] += f.y, h[u + 2] += f.z
                } else
                    for (i = 0, o = r.length; i < o; i += 9) c.fromArray(r, i), l.fromArray(r, i + 3), p.fromArray(r, i + 6), f.subVectors(p, l), d.subVectors(c, l), f.cross(d), h[i] = f.x, h[i + 1] = f.y, h[i + 2] = f.z, h[i + 3] = f.x, h[i + 4] = f.y, h[i + 5] = f.z, h[i + 6] = f.x, h[i + 7] = f.y, h[i + 8] = f.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function(t) {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        merge: function(t, e) {
            if (!1 != t instanceof THREE.BufferGeometry) {
                void 0 === e && (e = 0);
                var n, r = this.attributes;
                for (n in r)
                    if (void 0 !== t.attributes[n])
                        for (var i = r[n].array, o = (s = t.attributes[n]).array, a = 0, s = s.itemSize * e; a < o.length; a++, s++) i[s] = o[a];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function() {
            for (var t, e, n, r = this.attributes.normal.array, i = 0, o = r.length; i < o; i += 3) t = r[i], e = r[i + 1], n = r[i + 2], t = 1 / Math.sqrt(t * t + e * e + n * n), r[i] *= t, r[i + 1] *= t, r[i + 2] *= t
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.4,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e, n = this.parameters;
                for (e in n) void 0 !== n[e] && (t[e] = n[e]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var r = this.index;
            for (e in null !== r && (n = Array.prototype.slice.call(r.array), t.data.index = {
                    type: r.array.constructor.name,
                    array: n
                }), r = this.attributes) {
                var i = r[e];
                n = Array.prototype.slice.call(i.array);
                t.data.attributes[e] = {
                    itemSize: i.itemSize,
                    type: i.array.constructor.name,
                    array: n
                }
            }
            return 0 < (e = this.groups).length && (t.data.groups = JSON.parse(JSON.stringify(e))), null !== (e = this.boundingSphere) && (t.data.boundingSphere = {
                center: e.center.toArray(),
                radius: e.radius
            }), t
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            null !== (n = t.index) && this.setIndex(n.clone());
            var e, n = t.attributes;
            for (e in n) this.addAttribute(e, n[e].clone());
            for (e = 0, n = (t = t.groups).length; e < n; e++) {
                var r = t[e];
                this.addGroup(r.start, r.count)
            }
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.BufferGeometry.MaxIndex = 65535, THREE.InstancedBufferGeometry = function() {
        THREE.BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }, THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry, THREE.InstancedBufferGeometry.prototype.addGroup = function(t, e, n) {
        this.groups.push({
            start: t,
            count: e,
            instances: n
        })
    }, THREE.InstancedBufferGeometry.prototype.copy = function(t) {
        null !== (n = t.index) && this.setIndex(n.clone());
        var e, n = t.attributes;
        for (e in n) this.addAttribute(e, n[e].clone());
        for (e = 0, n = (t = t.groups).length; e < n; e++) {
            var r = t[e];
            this.addGroup(r.start, r.count, r.instances)
        }
        return this
    }, THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype), THREE.AnimationAction = function(t, e, n, r, i) {
        if (void 0 === t) throw Error("clip is null");
        this.clip = t, this.localRoot = null, this.startTime = e || 0, this.timeScale = n || 1, this.weight = r || 1, this.loop = i || THREE.LoopRepeat, this.loopCount = 0, this.enabled = !0, this.actionTime = -this.startTime, this.clipTime = 0, this.propertyBindings = []
    }, THREE.AnimationAction.prototype = {
        constructor: THREE.AnimationAction,
        setLocalRoot: function(t) {
            return this.localRoot = t, this
        },
        updateTime: function(t) {
            var e = this.clipTime,
                n = this.loopCount,
                r = this.clip.duration;
            return this.actionTime += t, this.loop === THREE.LoopOnce ? (this.loopCount = 0, this.clipTime = Math.min(Math.max(this.actionTime, 0), r), this.clipTime !== e && (this.clipTime === r ? this.mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 1
            }) : 0 === this.clipTime && this.mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: -1
            })), this.clipTime) : (this.loopCount = Math.floor(this.actionTime / r), t = this.actionTime - this.loopCount * r, t %= r, this.loop == THREE.LoopPingPong && 1 === Math.abs(this.loopCount % 2) && (t = r - t), this.clipTime = t, this.loopCount !== n && this.mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: this.loopCount - this.loopCount
            }), this.clipTime)
        },
        syncWith: function(t) {
            return this.actionTime = t.actionTime, this.timeScale = t.timeScale, this
        },
        warpToDuration: function(t) {
            return this.timeScale = this.clip.duration / t, this
        },
        init: function(t) {
            return this.clipTime = t - this.startTime, this
        },
        update: function(t) {
            return this.updateTime(t), this.clip.getAt(this.clipTime)
        },
        getTimeScaleAt: function(t) {
            return this.timeScale.getAt ? this.timeScale.getAt(t) : this.timeScale
        },
        getWeightAt: function(t) {
            return this.weight.getAt ? this.weight.getAt(t) : this.weight
        }
    }, THREE.AnimationClip = function(t, e, n) {
        if (this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, 0 > this.duration)
            for (t = 0; t < this.tracks.length; t++) e = this.tracks[t], this.duration = Math.max(e.keys[e.keys.length - 1].time);
        this.trim(), this.optimize(), this.results = []
    }, THREE.AnimationClip.prototype = {
        constructor: THREE.AnimationClip,
        getAt: function(t) {
            t = Math.max(0, Math.min(t, this.duration));
            for (var e = 0; e < this.tracks.length; e++) this.results[e] = this.tracks[e].getAt(t);
            return this.results
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        }
    }, THREE.AnimationClip.CreateFromMorphTargetSequence = function(t, e, n) {
        for (var r = e.length, i = [], o = 0; o < r; o++) {
            var a = [];
            a.push({
                time: (o + r - 1) % r,
                value: 0
            }), a.push({
                time: o,
                value: 1
            }), a.push({
                time: (o + 1) % r,
                value: 0
            }), a.sort(THREE.KeyframeTrack.keyComparer), 0 === a[0].time && a.push({
                time: r,
                value: a[0].value
            }), i.push(new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + e[o].name + "]", a).scale(1 / n))
        }
        return new THREE.AnimationClip(t, -1, i)
    }, THREE.AnimationClip.findByName = function(t, e) {
        for (var n = 0; n < t.length; n++)
            if (t[n].name === e) return t[n];
        return null
    }, THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function(t, e) {
        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, i = 0, o = t.length; i < o; i++) {
            var a = t[i],
                s = a.name.match(r);
            if (s && 1 < s.length) {
                var u = s[1];
                (s = n[u]) || (n[u] = s = []), s.push(a)
            }
        }
        for (u in r = [], n) r.push(THREE.AnimationClip.CreateFromMorphTargetSequence(u, n[u], e));
        return r
    }, THREE.AnimationClip.parse = function(t) {
        for (var e = [], n = 0; n < t.tracks.length; n++) e.push(THREE.KeyframeTrack.parse(t.tracks[n]).scale(1 / t.fps));
        return new THREE.AnimationClip(t.name, t.duration, e)
    }, THREE.AnimationClip.parseAnimation = function(t, e, n) {
        if (!t) return console.error("  no animation in JSONLoader data"), null;
        var r = function(t, e, n, r, i) {
                for (var o = [], a = 0; a < e.length; a++) {
                    var s = e[a];
                    void 0 !== s[n] && o.push({
                        time: s.time,
                        value: i(s)
                    })
                }
                return 0 < o.length ? new r(t, o) : null
            },
            i = [],
            o = t.name || "default",
            a = t.length || -1,
            s = t.fps || 30;
        t = t.hierarchy || [];
        for (var u = 0; u < t.length; u++) {
            var h = t[u].keys;
            if (h && 0 != h.length)
                if (h[0].morphTargets) {
                    a = {};
                    for (var c = 0; c < h.length; c++)
                        if (h[c].morphTargets)
                            for (var l = 0; l < h[c].morphTargets.length; l++) a[h[c].morphTargets[l]] = -1;
                    for (var p in a) {
                        var f = [];
                        for (l = 0; l < h[c].morphTargets.length; l++) {
                            var d = h[c];
                            f.push({
                                time: d.time,
                                value: d.morphTarget === p ? 1 : 0
                            })
                        }
                        i.push(new THREE.NumberKeyframeTrack(n + ".morphTargetInfluence[" + p + "]", f))
                    }
                    a = a.length * (s || 1)
                } else(l = r((c = n + ".bones[" + e[u].name + "]") + ".position", h, "pos", THREE.VectorKeyframeTrack, function(t) {
                    return (new THREE.Vector3).fromArray(t.pos)
                })) && i.push(l), (l = r(c + ".quaternion", h, "rot", THREE.QuaternionKeyframeTrack, function(t) {
                    return t.rot.slerp ? t.rot.clone() : (new THREE.Quaternion).fromArray(t.rot)
                })) && i.push(l), (h = r(c + ".scale", h, "scl", THREE.VectorKeyframeTrack, function(t) {
                    return (new THREE.Vector3).fromArray(t.scl)
                })) && i.push(h)
        }
        return 0 === i.length ? null : new THREE.AnimationClip(o, a, i)
    }, THREE.AnimationMixer = function(t) {
        this.root = t, this.time = 0, this.timeScale = 1, this.actions = [], this.propertyBindingMap = {}
    }, THREE.AnimationMixer.prototype = {
        constructor: THREE.AnimationMixer,
        addAction: function(t) {
            this.actions.push(t), t.init(this.time), t.mixer = this;
            for (var e = t.clip.tracks, n = t.localRoot || this.root, r = 0; r < e.length; r++) {
                var i = e[r],
                    o = n.uuid + "-" + i.name,
                    a = this.propertyBindingMap[o];
                void 0 === a && (a = new THREE.PropertyBinding(n, i.name), this.propertyBindingMap[o] = a), t.propertyBindings.push(a), a.referenceCount += 1
            }
        },
        removeAllActions: function() {
            for (var t = 0; t < this.actions.length; t++) this.actions[t].mixer = null;
            for (var e in this.propertyBindingMap) this.propertyBindingMap[e].unbind();
            return this.actions = [], this.propertyBindingMap = {}, this
        },
        removeAction: function(t) {
            var e = this.actions.indexOf(t); - 1 !== e && (this.actions.splice(e, 1), t.mixer = null), e = t.localRoot || this.root, t = t.clip.tracks;
            for (var n = 0; n < t.length; n++) {
                var r = e.uuid + "-" + t[n].name,
                    i = this.propertyBindingMap[r];
                i.referenceCount -= 1, 0 >= i.referenceCount && (i.unbind(), delete this.propertyBindingMap[r])
            }
            return this
        },
        findActionByName: function(t) {
            for (var e = 0; e < this.actions.length; e++)
                if (this.actions[e].name === t) return this.actions[e];
            return null
        },
        play: function(t, e) {
            return t.startTime = this.time, this.addAction(t), this
        },
        fadeOut: function(t, e) {
            var n = [];
            return n.push({
                time: this.time,
                value: 1
            }), n.push({
                time: this.time + e,
                value: 0
            }), t.weight = new THREE.NumberKeyframeTrack("weight", n), this
        },
        fadeIn: function(t, e) {
            var n = [];
            return n.push({
                time: this.time,
                value: 0
            }), n.push({
                time: this.time + e,
                value: 1
            }), t.weight = new THREE.NumberKeyframeTrack("weight", n), this
        },
        warp: function(t, e, n, r) {
            var i = [];
            return i.push({
                time: this.time,
                value: e
            }), i.push({
                time: this.time + r,
                value: n
            }), t.timeScale = new THREE.NumberKeyframeTrack("timeScale", i), this
        },
        crossFade: function(t, e, n, r) {
            if (this.fadeOut(t, n), this.fadeIn(e, n), r) {
                var i = 1 / (r = t.clip.duration / e.clip.duration);
                this.warp(t, 1, r, n), this.warp(e, i, 1, n)
            }
            return this
        },
        update: function(t) {
            t *= this.timeScale, this.time += t;
            for (var e = 0; e < this.actions.length; e++) {
                var n = this.actions[e],
                    r = n.getWeightAt(this.time),
                    i = n.getTimeScaleAt(this.time);
                i = n.update(t * i);
                if (!(0 >= n.weight) && n.enabled)
                    for (var o = 0; o < i.length; o++) n.propertyBindings[o].accumulate(i[o], r)
            }
            for (var a in this.propertyBindingMap) this.propertyBindingMap[a].apply();
            return this
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype), THREE.AnimationUtils = {
        getEqualsFunc: function(t) {
            return t.equals ? function(t, e) {
                return t.equals(e)
            } : function(t, e) {
                return t === e
            }
        },
        clone: function(t) {
            if ("object" == typeof t) {
                if (t.clone) return t.clone();
                console.error("can not figure out how to copy exemplarValue", t)
            }
            return t
        },
        lerp: function(t, e, n, r) {
            return THREE.AnimationUtils.getLerpFunc(t, r)(t, e, n)
        },
        lerp_object: function(t, e, n) {
            return t.lerp(e, n)
        },
        slerp_object: function(t, e, n) {
            return t.slerp(e, n)
        },
        lerp_number: function(t, e, n) {
            return t * (1 - n) + e * n
        },
        lerp_boolean: function(t, e, n) {
            return .5 > n ? t : e
        },
        lerp_boolean_immediate: function(t, e, n) {
            return t
        },
        lerp_string: function(t, e, n) {
            return .5 > n ? t : e
        },
        lerp_string_immediate: function(t, e, n) {
            return t
        },
        getLerpFunc: function(t, e) {
            if (void 0 === t || null === t) throw Error("examplarValue is null");
            switch (typeof t) {
                case "object":
                    if (t.lerp) return THREE.AnimationUtils.lerp_object;
                    if (t.slerp) return THREE.AnimationUtils.slerp_object;
                    break;
                case "number":
                    return THREE.AnimationUtils.lerp_number;
                case "boolean":
                    return e ? THREE.AnimationUtils.lerp_boolean : THREE.AnimationUtils.lerp_boolean_immediate;
                case "string":
                    return e ? THREE.AnimationUtils.lerp_string : THREE.AnimationUtils.lerp_string_immediate
            }
        }
    }, THREE.KeyframeTrack = function(t, e) {
        if (void 0 === t) throw Error("track name is undefined");
        if (void 0 === e || 0 === e.length) throw Error("no keys in track named " + t);
        this.name = t, this.keys = e, this.lastIndex = 0, this.validate(), this.optimize()
    }, THREE.KeyframeTrack.prototype = {
        constructor: THREE.KeyframeTrack,
        getAt: function(t) {
            for (; this.lastIndex < this.keys.length && t >= this.keys[this.lastIndex].time;) this.lastIndex++;
            for (; 0 < this.lastIndex && t < this.keys[this.lastIndex - 1].time;) this.lastIndex--;
            if (this.lastIndex >= this.keys.length) return this.setResult(this.keys[this.keys.length - 1].value), this.result;
            if (0 === this.lastIndex) return this.setResult(this.keys[0].value), this.result;
            var e = this.keys[this.lastIndex - 1];
            if (this.setResult(e.value), e.constantToNext) return this.result;
            var n = this.keys[this.lastIndex];
            return this.result = this.lerpValues(this.result, n.value, (t - e.time) / (n.time - e.time))
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = 0; e < this.keys.length; e++) this.keys[e].time += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = 0; e < this.keys.length; e++) this.keys[e].time *= t;
            return this
        },
        trim: function(t, e) {
            for (var n = 0, r = 1; r < this.keys.length; r++) this.keys[r] <= t && n++;
            var i = 0;
            for (r = this.keys.length - 2; 0 < r && this.keys[r] >= e; r++) i++;
            return 0 < n + i && (this.keys = this.keys.splice(n, this.keys.length - i - n)), this
        },
        validate: function() {
            var t = null;
            if (0 !== this.keys.length) {
                for (var e = 0; e < this.keys.length; e++) {
                    var n = this.keys[e];
                    if (!n) return void console.error("  key is null in track", this, e);
                    if ("number" != typeof n.time || isNaN(n.time)) return void console.error("  key.time is not a valid number", this, e, n);
                    if (void 0 === n.value || null === n.value) return void console.error("  key.value is null in track", this, e, n);
                    if (t && t.time > n.time) return void console.error("  key.time is less than previous key time, out of order keys", this, e, n, t);
                    t = n
                }
                return this
            }
            console.error("  track is empty, no keys", this)
        },
        optimize: function() {
            var t = [],
                e = this.keys[0];
            t.push(e), THREE.AnimationUtils.getEqualsFunc(e.value);
            for (var n = 1; n < this.keys.length - 1; n++) {
                var r = this.keys[n],
                    i = this.keys[n + 1];
                e.time === r.time || this.compareValues(e.value, r.value) && this.compareValues(r.value, i.value) || (e.constantToNext = this.compareValues(e.value, r.value), t.push(r), e = r)
            }
            return t.push(this.keys[this.keys.length - 1]), this.keys = t, this
        }
    }, THREE.KeyframeTrack.keyComparer = function(t, e) {
        return t.time - e.time
    }, THREE.KeyframeTrack.parse = function(t) {
        if (void 0 === t.type) throw Error("track type undefined, can not parse");
        return THREE.KeyframeTrack.GetTrackTypeForTypeName(t.type).parse(t)
    }, THREE.KeyframeTrack.GetTrackTypeForTypeName = function(t) {
        switch (t.toLowerCase()) {
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return THREE.VectorKeyframeTrack;
            case "quaternion":
                return THREE.QuaternionKeyframeTrack;
            case "integer":
            case "scalar":
            case "double":
            case "float":
            case "number":
                return THREE.NumberKeyframeTrack;
            case "bool":
            case "boolean":
                return THREE.BooleanKeyframeTrack;
            case "string":
                return THREE.StringKeyframeTrack
        }
        throw Error("Unsupported typeName: " + t)
    }, THREE.PropertyBinding = function(t, e) {
        this.rootNode = t, this.trackName = e, this.referenceCount = 0, this.originalValue = null;
        var n = THREE.PropertyBinding.parseTrackName(e);
        this.directoryName = n.directoryName, this.nodeName = n.nodeName, this.objectName = n.objectName, this.objectIndex = n.objectIndex, this.propertyName = n.propertyName, this.propertyIndex = n.propertyIndex, this.node = THREE.PropertyBinding.findNode(t, this.nodeName) || t, this.cumulativeValue = null, this.cumulativeWeight = 0
    }, THREE.PropertyBinding.prototype = {
        constructor: THREE.PropertyBinding,
        reset: function() {
            this.cumulativeValue = null, this.cumulativeWeight = 0
        },
        accumulate: function(t, e) {
            this.isBound || this.bind(), 0 === this.cumulativeWeight ? 0 < e && (null === this.cumulativeValue && (this.cumulativeValue = THREE.AnimationUtils.clone(t)), this.cumulativeWeight = e) : (this.cumulativeValue = this.lerpValue(this.cumulativeValue, t, e / (this.cumulativeWeight + e)), this.cumulativeWeight += e)
        },
        unbind: function() {
            this.isBound && (this.setValue(this.originalValue), this.triggerDirty = this.equalsValue = this.lerpValue = this.getValue = this.setValue = null, this.isBound = !1)
        },
        bind: function() {
            if (!this.isBound)
                if (t = this.node) {
                    if (this.objectName) {
                        if ("materials" === this.objectName) {
                            if (!t.material) return void console.error("  can not bind to material as node does not have a material", this);
                            if (!t.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                            t = t.material.materials
                        } else if ("bones" === this.objectName) {
                            if (!t.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                            for (var t = t.skeleton.bones, e = 0; e < t.length; e++)
                                if (t[e].name === this.objectIndex) {
                                    this.objectIndex = e;
                                    break
                                }
                        } else {
                            if (void 0 === t[this.objectName]) return void console.error("  can not bind to objectName of node, undefined", this);
                            t = t[this.objectName]
                        }
                        if (void 0 !== this.objectIndex) {
                            if (void 0 === t[this.objectIndex]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                            t = t[this.objectIndex]
                        }
                    }
                    var n = t[this.propertyName];
                    if (n) {
                        if (void 0 !== this.propertyIndex) {
                            if ("morphTargetInfluences" === this.propertyName)
                                for (t.geometry || console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this), t.geometry.morphTargets || console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this), e = 0; e < this.node.geometry.morphTargets.length; e++)
                                    if (t.geometry.morphTargets[e].name === this.propertyIndex) {
                                        this.propertyIndex = e;
                                        break
                                    }
                            this.setValue = function(t) {
                                return !this.equalsValue(n[this.propertyIndex], t) && (n[this.propertyIndex] = t, !0)
                            }, this.getValue = function() {
                                return n[this.propertyIndex]
                            }
                        } else n.copy ? (this.setValue = function(t) {
                            return !this.equalsValue(n, t) && (n.copy(t), !0)
                        }, this.getValue = function() {
                            return n
                        }) : (this.setValue = function(e) {
                            return !this.equalsValue(t[this.propertyName], e) && (t[this.propertyName] = e, !0)
                        }, this.getValue = function() {
                            return t[this.propertyName]
                        });
                        void 0 !== t.needsUpdate ? this.triggerDirty = function() {
                            this.node.needsUpdate = !0
                        } : void 0 !== t.matrixWorldNeedsUpdate && (this.triggerDirty = function() {
                            t.matrixWorldNeedsUpdate = !0
                        }), this.originalValue = this.getValue(), this.equalsValue = THREE.AnimationUtils.getEqualsFunc(this.originalValue), this.lerpValue = THREE.AnimationUtils.getLerpFunc(this.originalValue, !0), this.isBound = !0
                    } else console.error("  trying to update property for track: " + this.nodeName + "." + this.propertyName + " but it wasn't found.", t)
                } else console.error("  trying to update node for track: " + this.trackName + " but it wasn't found.")
        },
        apply: function() {
            if (this.isBound || this.bind(), 0 < this.cumulativeWeight) {
                if (1 > this.cumulativeWeight) {
                    var t = 1 - this.cumulativeWeight;
                    this.cumulativeValue = this.lerpValue(this.cumulativeValue, this.originalValue, t / (this.cumulativeWeight + t))
                }
                this.setValue(this.cumulativeValue) && this.triggerDirty && this.triggerDirty(), this.cumulativeValue = null, this.cumulativeWeight = 0
            }
        }
    }, THREE.PropertyBinding.parseTrackName = function(t) {
        var e = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
            n = e.exec(t);
        if (!n) throw Error("cannot parse trackName at all: " + t);
        if (n.index === e.lastIndex && e.lastIndex++, null === (e = {
                directoryName: n[1],
                nodeName: n[3],
                objectName: n[5],
                objectIndex: n[7],
                propertyName: n[9],
                propertyIndex: n[11]
            }).propertyName || 0 === e.propertyName.length) throw Error("can not parse propertyName from trackName: " + t);
        return e
    }, THREE.PropertyBinding.findNode = function(t, e) {
        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
            var n = function(t) {
                for (var n = 0; n < t.bones.length; n++) {
                    var r = t.bones[n];
                    if (r.name === e) return r
                }
                return null
            }(t.skeleton);
            if (n) return n
        }
        return t.children && (n = function t(n) {
            for (var r = 0; r < n.length; r++) {
                var i = n[r];
                if (i.name === e || i.uuid === e || (i = t(i.children))) return i
            }
            return null
        }(t.children)) ? n : null
    }, THREE.VectorKeyframeTrack = function(t, e) {
        THREE.KeyframeTrack.call(this, t, e), this.result = this.keys[0].value.clone()
    }, THREE.VectorKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype), THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack, THREE.VectorKeyframeTrack.prototype.setResult = function(t) {
        this.result.copy(t)
    }, THREE.VectorKeyframeTrack.prototype.lerpValues = function(t, e, n) {
        return t.lerp(e, n)
    }, THREE.VectorKeyframeTrack.prototype.compareValues = function(t, e) {
        return t.equals(e)
    }, THREE.VectorKeyframeTrack.prototype.clone = function() {
        for (var t = [], e = 0; e < this.keys.length; e++) {
            var n = this.keys[e];
            t.push({
                time: n.time,
                value: n.value.clone()
            })
        }
        return new THREE.VectorKeyframeTrack(this.name, t)
    }, THREE.VectorKeyframeTrack.parse = function(t) {
        for (var e = THREE["Vector" + t.keys[0].value.length], n = [], r = 0; r < t.keys.length; r++) {
            var i = t.keys[r];
            n.push({
                value: (new e).fromArray(i.value),
                time: i.time
            })
        }
        return new THREE.VectorKeyframeTrack(t.name, n)
    }, THREE.QuaternionKeyframeTrack = function(t, e) {
        THREE.KeyframeTrack.call(this, t, e), this.result = this.keys[0].value.clone()
    }, THREE.QuaternionKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype), THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack, THREE.QuaternionKeyframeTrack.prototype.setResult = function(t) {
        this.result.copy(t)
    }, THREE.QuaternionKeyframeTrack.prototype.lerpValues = function(t, e, n) {
        return t.slerp(e, n)
    }, THREE.QuaternionKeyframeTrack.prototype.compareValues = function(t, e) {
        return t.equals(e)
    }, THREE.QuaternionKeyframeTrack.prototype.multiply = function(t) {
        for (var e = 0; e < this.keys.length; e++) this.keys[e].value.multiply(t);
        return this
    }, THREE.QuaternionKeyframeTrack.prototype.clone = function() {
        for (var t = [], e = 0; e < this.keys.length; e++) {
            var n = this.keys[e];
            t.push({
                time: n.time,
                value: n.value.clone()
            })
        }
        return new THREE.QuaternionKeyframeTrack(this.name, t)
    }, THREE.QuaternionKeyframeTrack.parse = function(t) {
        for (var e = [], n = 0; n < t.keys.length; n++) {
            var r = t.keys[n];
            e.push({
                value: (new THREE.Quaternion).fromArray(r.value),
                time: r.time
            })
        }
        return new THREE.QuaternionKeyframeTrack(t.name, e)
    }, THREE.StringKeyframeTrack = function(t, e) {
        THREE.KeyframeTrack.call(this, t, e), this.result = this.keys[0].value
    }, THREE.StringKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype), THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack, THREE.StringKeyframeTrack.prototype.setResult = function(t) {
        this.result = t
    }, THREE.StringKeyframeTrack.prototype.lerpValues = function(t, e, n) {
        return 1 > n ? t : e
    }, THREE.StringKeyframeTrack.prototype.compareValues = function(t, e) {
        return t === e
    }, THREE.StringKeyframeTrack.prototype.clone = function() {
        for (var t = [], e = 0; e < this.keys.length; e++) {
            var n = this.keys[e];
            t.push({
                time: n.time,
                value: n.value
            })
        }
        return new THREE.StringKeyframeTrack(this.name, t)
    }, THREE.StringKeyframeTrack.parse = function(t) {
        return new THREE.StringKeyframeTrack(t.name, t.keys)
    }, THREE.BooleanKeyframeTrack = function(t, e) {
        THREE.KeyframeTrack.call(this, t, e), this.result = this.keys[0].value
    }, THREE.BooleanKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype), THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack, THREE.BooleanKeyframeTrack.prototype.setResult = function(t) {
        this.result = t
    }, THREE.BooleanKeyframeTrack.prototype.lerpValues = function(t, e, n) {
        return 1 > n ? t : e
    }, THREE.BooleanKeyframeTrack.prototype.compareValues = function(t, e) {
        return t === e
    }, THREE.BooleanKeyframeTrack.prototype.clone = function() {
        for (var t = [], e = 0; e < this.keys.length; e++) {
            var n = this.keys[e];
            t.push({
                time: n.time,
                value: n.value
            })
        }
        return new THREE.BooleanKeyframeTrack(this.name, t)
    }, THREE.BooleanKeyframeTrack.parse = function(t) {
        return new THREE.BooleanKeyframeTrack(t.name, t.keys)
    }, THREE.NumberKeyframeTrack = function(t, e) {
        THREE.KeyframeTrack.call(this, t, e), this.result = this.keys[0].value
    }, THREE.NumberKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype), THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack, THREE.NumberKeyframeTrack.prototype.setResult = function(t) {
        this.result = t
    }, THREE.NumberKeyframeTrack.prototype.lerpValues = function(t, e, n) {
        return t * (1 - n) + e * n
    }, THREE.NumberKeyframeTrack.prototype.compareValues = function(t, e) {
        return t === e
    }, THREE.NumberKeyframeTrack.prototype.clone = function() {
        for (var t = [], e = 0; e < this.keys.length; e++) {
            var n = this.keys[e];
            t.push({
                time: n.time,
                value: n.value
            })
        }
        return new THREE.NumberKeyframeTrack(this.name, t)
    }, THREE.NumberKeyframeTrack.parse = function(t) {
        return new THREE.NumberKeyframeTrack(t.name, t.keys)
    }, THREE.Camera = function() {
        THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
    }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, THREE.Camera.prototype.getWorldDirection = function() {
        var t = new THREE.Quaternion;
        return function(e) {
            return e = e || new THREE.Vector3, this.getWorldQuaternion(t), e.set(0, 0, -1).applyQuaternion(t)
        }
    }(), THREE.Camera.prototype.lookAt = function() {
        var t = new THREE.Matrix4;
        return function(e) {
            t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t)
        }
    }(), THREE.Camera.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, THREE.Camera.prototype.copy = function(t) {
        return THREE.Object3D.prototype.copy.call(this, t), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
    }, THREE.CubeCamera = function(t, e, n) {
        THREE.Object3D.call(this), this.type = "CubeCamera";
        var r = new THREE.PerspectiveCamera(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
        var i = new THREE.PerspectiveCamera(90, 1, t, e);
        i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(i);
        var o = new THREE.PerspectiveCamera(90, 1, t, e);
        o.up.set(0, 0, 1), o.lookAt(new THREE.Vector3(0, 1, 0)), this.add(o);
        var a = new THREE.PerspectiveCamera(90, 1, t, e);
        a.up.set(0, 0, -1), a.lookAt(new THREE.Vector3(0, -1, 0)), this.add(a);
        var s = new THREE.PerspectiveCamera(90, 1, t, e);
        s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(0, 0, 1)), this.add(s);
        var u = new THREE.PerspectiveCamera(90, 1, t, e);
        u.up.set(0, -1, 0), u.lookAt(new THREE.Vector3(0, 0, -1)), this.add(u), this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        }), this.updateCubeMap = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget,
                h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, r, n), n.activeCubeFace = 1, t.render(e, i, n), n.activeCubeFace = 2, t.render(e, o, n), n.activeCubeFace = 3, t.render(e, a, n), n.activeCubeFace = 4, t.render(e, s, n), n.texture.generateMipmaps = h, n.activeCubeFace = 5, t.render(e, u, n), t.setRenderTarget(null)
        }
    }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, THREE.OrthographicCamera = function(t, e, n, r, i, o) {
        THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
        var t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(n - t, n + t, r + e, r - e, this.near, this.far)
    }, THREE.OrthographicCamera.prototype.copy = function(t) {
        return THREE.Camera.prototype.copy.call(this, t), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this
    }, THREE.OrthographicCamera.prototype.toJSON = function(t) {
        return (t = THREE.Object3D.prototype.toJSON.call(this, t)).object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, t
    }, THREE.PerspectiveCamera = function(t, e, n, r) {
        THREE.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== t ? t : 50, this.aspect = void 0 !== e ? e : 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera, THREE.PerspectiveCamera.prototype.setLens = function(t, e) {
        void 0 === e && (e = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(e / (2 * t))), this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.setViewOffset = function(t, e, n, r, i, o) {
        this.fullWidth = t, this.fullHeight = e, this.x = n, this.y = r, this.width = i, this.height = o, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        var t = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
        if (this.fullWidth) {
            var e = (n = this.fullWidth / this.fullHeight) * (r = -(t = Math.tan(THREE.Math.degToRad(.5 * t)) * this.near)),
                n = Math.abs(n * t - e),
                r = Math.abs(t - r);
            this.projectionMatrix.makeFrustum(e + this.x * n / this.fullWidth, e + (this.x + this.width) * n / this.fullWidth, t - (this.y + this.height) * r / this.fullHeight, t - this.y * r / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(t, this.aspect, this.near, this.far)
    }, THREE.PerspectiveCamera.prototype.copy = function(t) {
        return THREE.Camera.prototype.copy.call(this, t), this.fov = t.fov, this.aspect = t.aspect, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this
    }, THREE.PerspectiveCamera.prototype.toJSON = function(t) {
        return (t = THREE.Object3D.prototype.toJSON.call(this, t)).object.zoom = this.zoom, t.object.fov = this.fov, t.object.aspect = this.aspect, t.object.near = this.near, t.object.far = this.far, t
    }, THREE.Light = function(t) {
        THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(t), this.receiveShadow = void 0
    }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, Object.defineProperties(THREE.Light.prototype, {
        onlyShadow: {
            set: function(t) {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function(t) {
                this.shadow.darkness = t
            }
        },
        shadowMapWidth: {
            set: function(t) {
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                this.shadow.mapSize.height = t
            }
        }
    }), THREE.Light.prototype.copy = function(t) {
        return THREE.Object3D.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, THREE.Light.prototype.toJSON = function(t) {
        return (t = THREE.Object3D.prototype.toJSON.call(this, t)).object.color = this.color.getHex(), void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.intensity && (t.object.intensity = this.intensity), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.exponent && (t.object.exponent = this.exponent), t
    }, THREE.LightShadow = function(t) {
        this.camera = t, this.bias = 0, this.darkness = 1, this.mapSize = new THREE.Vector2(512, 512), this.matrix = this.map = null
    }, THREE.LightShadow.prototype = {
        constructor: THREE.LightShadow,
        copy: function(t) {
            this.camera = t.camera.clone(), this.bias = t.bias, this.darkness = t.darkness, this.mapSize.copy(t.mapSize)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }, THREE.AmbientLight = function(t) {
        THREE.Light.call(this, t), this.type = "AmbientLight", this.castShadow = void 0
    }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight, THREE.DirectionalLight = function(t, e) {
        THREE.Light.call(this, t), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-500, 500, 500, -500, 50, 5e3))
    }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, THREE.DirectionalLight.prototype.copy = function(t) {
        return THREE.Light.prototype.copy.call(this, t), this.intensity = t.intensity, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }, THREE.HemisphereLight = function(t, e, n) {
        THREE.Light.call(this, t), this.type = "HemisphereLight", this.castShadow = void 0, this.position.set(0, 1, 0), this.updateMatrix(), this.groundColor = new THREE.Color(e), this.intensity = void 0 !== n ? n : 1
    }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, THREE.HemisphereLight.prototype.copy = function(t) {
        return THREE.Light.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this.intensity = t.intensity, this
    }, THREE.PointLight = function(t, e, n, r) {
        THREE.Light.call(this, t), this.type = "PointLight", this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 1, 500))
    }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, THREE.PointLight.prototype.copy = function(t) {
        return THREE.Light.prototype.copy.call(this, t), this.intensity = t.intensity, this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }, THREE.SpotLight = function(t, e, n, r, i, o) {
        THREE.Light.call(this, t), this.type = "SpotLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== i ? i : 10, this.decay = void 0 !== o ? o : 1, this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, 50, 5e3))
    }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, THREE.SpotLight.prototype.copy = function(t) {
        return THREE.Light.prototype.copy.call(this, t), this.intensity = t.intensity, this.distance = t.distance, this.angle = t.angle, this.exponent = t.exponent, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }, THREE.Cache = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled) return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    }, THREE.Loader = function() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }, THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        extractUrlBase: function(t) {
            return 1 === (t = t.split("/")).length ? "./" : (t.pop(), t.join("/") + "/")
        },
        initMaterials: function(t, e, n) {
            for (var r = [], i = 0; i < t.length; ++i) r[i] = this.createMaterial(t[i], e, n);
            return r
        },
        createMaterial: function() {
            var t, e, n;
            return function(r, i, o) {
                function a(t, n, r, a, s) {
                    t = i + t;
                    var h = THREE.Loader.Handlers.get(t);
                    return null !== h ? t = h.load(t) : (e.setCrossOrigin(o), t = e.load(t)), void 0 !== n && (t.repeat.fromArray(n), 1 !== n[0] && (t.wrapS = THREE.RepeatWrapping), 1 !== n[1] && (t.wrapT = THREE.RepeatWrapping)), void 0 !== r && t.offset.fromArray(r), void 0 !== a && ("repeat" === a[0] && (t.wrapS = THREE.RepeatWrapping), "mirror" === a[0] && (t.wrapS = THREE.MirroredRepeatWrapping), "repeat" === a[1] && (t.wrapT = THREE.RepeatWrapping), "mirror" === a[1] && (t.wrapT = THREE.MirroredRepeatWrapping)), void 0 !== s && (t.anisotropy = s), n = THREE.Math.generateUUID(), u[n] = t, n
                }
                void 0 === t && (t = new THREE.Color), void 0 === e && (e = new THREE.TextureLoader), void 0 === n && (n = new THREE.MaterialLoader);
                var s, u = {},
                    h = {
                        uuid: THREE.Math.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (s in r) {
                    var c = r[s];
                    switch (s) {
                        case "DbgColor":
                            h.color = c;
                            break;
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            h.name = c;
                            break;
                        case "blending":
                            h.blending = THREE[c];
                            break;
                        case "colorDiffuse":
                            h.color = t.fromArray(c).getHex();
                            break;
                        case "colorSpecular":
                            h.specular = t.fromArray(c).getHex();
                            break;
                        case "colorEmissive":
                            h.emissive = t.fromArray(c).getHex();
                            break;
                        case "specularCoef":
                            h.shininess = c;
                            break;
                        case "shading":
                            "basic" === c.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === c.toLowerCase() && (h.type = "MeshPhongMaterial");
                            break;
                        case "mapDiffuse":
                            h.map = a(c, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapLight":
                            h.lightMap = a(c, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            h.aoMap = a(c, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            h.bumpMap = a(c, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            h.bumpScale = c;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            h.normalMap = a(c, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            h.normalScale = [c, c];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            h.specularMap = a(c, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapAlpha":
                            h.alphaMap = a(c, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            h.side = THREE.BackSide;
                            break;
                        case "doubleSided":
                            h.side = THREE.DoubleSide;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader: transparency has been renamed to opacity"), h.opacity = c;
                            break;
                        case "opacity":
                        case "transparent":
                        case "depthTest":
                        case "depthWrite":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            h[s] = c;
                            break;
                        case "vertexColors":
                            !0 === c && (h.vertexColors = THREE.VertexColors), "face" === c && (h.vertexColors = THREE.FaceColors);
                            break;
                        default:
                            console.error("Loader.createMaterial: Unsupported", s, c)
                    }
                }
                return "MeshPhongMaterial" !== h.type && delete h.specular, 1 > h.opacity && (h.transparent = !0), n.setTextures(u), n.parse(h)
            }
        }()
    }, THREE.Loader.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, n = 0, r = e.length; n < r; n += 2) {
                var i = e[n + 1];
                if (e[n].test(t)) return i
            }
            return null
        }
    }, THREE.XHRLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = THREE.Cache.get(t);
            if (void 0 !== o) return e && setTimeout(function() {
                e(o)
            }, 0), o;
            var a = new XMLHttpRequest;
            return a.open("GET", t, !0), a.addEventListener("load", function(n) {
                n = n.target.response, THREE.Cache.add(t, n), e && e(n), i.manager.itemEnd(t)
            }, !1), void 0 !== n && a.addEventListener("progress", function(t) {
                n(t)
            }, !1), a.addEventListener("error", function(e) {
                r && r(e), i.manager.itemError(t)
            }, !1), void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.send(null), i.manager.itemStart(t), a
        },
        setResponseType: function(t) {
            this.responseType = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        setWithCredentials: function(t) {
            this.withCredentials = t
        }
    }, THREE.ImageLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = THREE.Cache.get(t);
            if (void 0 !== o) return i.manager.itemStart(t), e ? setTimeout(function() {
                e(o), i.manager.itemEnd(t)
            }, 0) : i.manager.itemEnd(t), o;
            var a = document.createElement("img");
            return a.addEventListener("load", function(n) {
                THREE.Cache.add(t, this), e && e(this), i.manager.itemEnd(t)
            }, !1), void 0 !== n && a.addEventListener("progress", function(t) {
                n(t)
            }, !1), a.addEventListener("error", function(e) {
                r && r(e), i.manager.itemError(t)
            }, !1), void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.JSONLoader = function(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this.withCredentials = !1
    }, THREE.JSONLoader.prototype = {
        constructor: THREE.JSONLoader,
        get statusDomElement() {
            return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")), console.warn("THREE.JSONLoader: .statusDomElement has been removed."), this._statusDomElement
        },
        load: function(t, e, n, r) {
            var i = this,
                o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : THREE.Loader.prototype.extractUrlBase(t);
            (n = new THREE.XHRLoader(this.manager)).setCrossOrigin(this.crossOrigin), n.setWithCredentials(this.withCredentials), n.load(t, function(n) {
                var r = (n = JSON.parse(n)).metadata;
                if (void 0 !== r) {
                    if ("object" === r.type) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                    if ("scene" === r.type) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                }
                n = i.parse(n, o), e(n.geometry, n.materials)
            })
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        parse: function(t, e) {
            var n = new THREE.Geometry,
                r = void 0 !== t.scale ? 1 / t.scale : 1;
            return function(e) {
                    var r, i, o, a, s, u, h, c, l, p, f, d, E, m = t.faces;
                    u = t.vertices;
                    var g = t.normals,
                        v = t.colors,
                        y = 0;
                    if (void 0 !== t.uvs) {
                        for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && y++;
                        for (r = 0; r < y; r++) n.faceVertexUvs[r] = []
                    }
                    for (a = 0, s = u.length; a < s;)(r = new THREE.Vector3).x = u[a++] * e, r.y = u[a++] * e, r.z = u[a++] * e, n.vertices.push(r);
                    for (a = 0, s = m.length; a < s;)
                        if (l = 1 & (e = m[a++]), o = 2 & e, r = 8 & e, h = 16 & e, p = 32 & e, u = 64 & e, e &= 128, l) {
                            if ((l = new THREE.Face3).a = m[a], l.b = m[a + 1], l.c = m[a + 3], (f = new THREE.Face3).a = m[a + 1], f.b = m[a + 2], f.c = m[a + 3], a += 4, o && (o = m[a++], l.materialIndex = o, f.materialIndex = o), o = n.faces.length, r)
                                for (r = 0; r < y; r++)
                                    for (d = t.uvs[r], n.faceVertexUvs[r][o] = [], n.faceVertexUvs[r][o + 1] = [], i = 0; 4 > i; i++) E = d[2 * (c = m[a++])], c = d[2 * c + 1], E = new THREE.Vector2(E, c), 2 !== i && n.faceVertexUvs[r][o].push(E), 0 !== i && n.faceVertexUvs[r][o + 1].push(E);
                            if (h && (h = 3 * m[a++], l.normal.set(g[h++], g[h++], g[h]), f.normal.copy(l.normal)), p)
                                for (r = 0; 4 > r; r++) h = 3 * m[a++], p = new THREE.Vector3(g[h++], g[h++], g[h]), 2 !== r && l.vertexNormals.push(p), 0 !== r && f.vertexNormals.push(p);
                            if (u && (u = v[u = m[a++]], l.color.setHex(u), f.color.setHex(u)), e)
                                for (r = 0; 4 > r; r++) u = v[u = m[a++]], 2 !== r && l.vertexColors.push(new THREE.Color(u)), 0 !== r && f.vertexColors.push(new THREE.Color(u));
                            n.faces.push(l), n.faces.push(f)
                        } else {
                            if ((l = new THREE.Face3).a = m[a++], l.b = m[a++], l.c = m[a++], o && (o = m[a++], l.materialIndex = o), o = n.faces.length, r)
                                for (r = 0; r < y; r++)
                                    for (d = t.uvs[r], n.faceVertexUvs[r][o] = [], i = 0; 3 > i; i++) E = d[2 * (c = m[a++])], c = d[2 * c + 1], E = new THREE.Vector2(E, c), n.faceVertexUvs[r][o].push(E);
                            if (h && (h = 3 * m[a++], l.normal.set(g[h++], g[h++], g[h])), p)
                                for (r = 0; 3 > r; r++) h = 3 * m[a++], p = new THREE.Vector3(g[h++], g[h++], g[h]), l.vertexNormals.push(p);
                            if (u && (u = m[a++], l.color.setHex(v[u])), e)
                                for (r = 0; 3 > r; r++) u = m[a++], l.vertexColors.push(new THREE.Color(v[u]));
                            n.faces.push(l)
                        }
                }(r),
                function() {
                    var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)
                        for (var r = 0, i = t.skinWeights.length; r < i; r += e) n.skinWeights.push(new THREE.Vector4(t.skinWeights[r], 1 < e ? t.skinWeights[r + 1] : 0, 2 < e ? t.skinWeights[r + 2] : 0, 3 < e ? t.skinWeights[r + 3] : 0));
                    if (t.skinIndices)
                        for (r = 0, i = t.skinIndices.length; r < i; r += e) n.skinIndices.push(new THREE.Vector4(t.skinIndices[r], 1 < e ? t.skinIndices[r + 1] : 0, 2 < e ? t.skinIndices[r + 2] : 0, 3 < e ? t.skinIndices[r + 3] : 0));
                    n.bones = t.bones, n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match.")
                }(),
                function(e) {
                    if (void 0 !== t.morphTargets)
                        for (var r = 0, i = t.morphTargets.length; r < i; r++) {
                            n.morphTargets[r] = {}, n.morphTargets[r].name = t.morphTargets[r].name, n.morphTargets[r].vertices = [];
                            for (var o = n.morphTargets[r].vertices, a = t.morphTargets[r].vertices, s = 0, u = a.length; s < u; s += 3) {
                                var h = new THREE.Vector3;
                                h.x = a[s] * e, h.y = a[s + 1] * e, h.z = a[s + 2] * e, o.push(h)
                            }
                        }
                    if (void 0 !== t.morphColors && 0 < t.morphColors.length)
                        for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), e = n.faces, o = t.morphColors[0].colors, r = 0, i = e.length; r < i; r++) e[r].color.fromArray(o, 3 * r)
                }(r),
                function() {
                    var e = [],
                        r = [];
                    void 0 !== t.animation && r.push(t.animation), void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                    for (var i = 0; i < r.length; i++) {
                        var o = THREE.AnimationClip.parseAnimation(r[i], n.bones);
                        o && e.push(o)
                    }
                    n.morphTargets && (r = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(n.morphTargets, 10), e = e.concat(r)), 0 < e.length && (n.animations = e)
                }(), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                    geometry: n
                } : (r = THREE.Loader.prototype.initMaterials(t.materials, e, this.crossOrigin), {
                    geometry: n,
                    materials: r
                })
        }
    }, THREE.LoadingManager = function(t, e, n) {
        var r = this,
            i = !1,
            o = 0,
            a = 0;
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
            a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), i = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (i = !1, void 0 !== r.onLoad) && r.onLoad()
        }, this.itemError = function(t) {
            void 0 !== r.onError && r.onError(t)
        }
    }, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = new THREE.XHRLoader(i.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, n, r)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t) {
            var e = new THREE.BufferGeometry;
            void 0 !== (o = t.data.index) && (o = new self[o.type](o.array), e.setIndex(new THREE.BufferAttribute(o, 1)));
            var n, r = t.data.attributes;
            for (n in r) {
                var i = r[n],
                    o = new self[i.type](i.array);
                e.addAttribute(n, new THREE.BufferAttribute(o, i.itemSize))
            }
            if (void 0 !== (n = t.data.groups || t.data.drawcalls || t.data.offsets))
                for (o = 0, r = n.length; o !== r; ++o) i = n[o], e.addGroup(i.start, i.count);
            return void 0 !== (t = t.data.boundingSphere) && (n = new THREE.Vector3, void 0 !== t.center && n.fromArray(t.center), e.boundingSphere = new THREE.Sphere(n, t.radius)), e
        }
    }, THREE.MaterialLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this.textures = {}
    }, THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = new THREE.XHRLoader(i.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, n, r)
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        setTextures: function(t) {
            this.textures = t
        },
        getTexture: function(t) {
            var e = this.textures;
            return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
        },
        parse: function(t) {
            var e = new THREE[t.type];
            if (e.uuid = t.uuid, void 0 !== t.name && (e.name = t.name), void 0 !== t.color && e.color.setHex(t.color), void 0 !== t.emissive && e.emissive.setHex(t.emissive), void 0 !== t.specular && e.specular.setHex(t.specular), void 0 !== t.shininess && (e.shininess = t.shininess), void 0 !== t.uniforms && (e.uniforms = t.uniforms), void 0 !== t.vertexShader && (e.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (e.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (e.vertexColors = t.vertexColors), void 0 !== t.shading && (e.shading = t.shading), void 0 !== t.blending && (e.blending = t.blending), void 0 !== t.side && (e.side = t.side), void 0 !== t.opacity && (e.opacity = t.opacity), void 0 !== t.transparent && (e.transparent = t.transparent), void 0 !== t.alphaTest && (e.alphaTest = t.alphaTest), void 0 !== t.depthTest && (e.depthTest = t.depthTest), void 0 !== t.depthWrite && (e.depthWrite = t.depthWrite), void 0 !== t.wireframe && (e.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (e.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.size && (e.size = t.size), void 0 !== t.sizeAttenuation && (e.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (e.map = this.getTexture(t.map)), void 0 !== t.alphaMap && (e.alphaMap = this.getTexture(t.alphaMap), e.transparent = !0), void 0 !== t.bumpMap && (e.bumpMap = this.getTexture(t.bumpMap)), void 0 !== t.bumpScale && (e.bumpScale = t.bumpScale), void 0 !== t.normalMap && (e.normalMap = this.getTexture(t.normalMap)), t.normalScale && (e.normalScale = new THREE.Vector2(t.normalScale, t.normalScale)), void 0 !== t.displacementMap && (e.displacementMap = this.getTexture(t.displacementMap)), void 0 !== t.displacementScale && (e.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (e.displacementBias = t.displacementBias), void 0 !== t.specularMap && (e.specularMap = this.getTexture(t.specularMap)), void 0 !== t.envMap && (e.envMap = this.getTexture(t.envMap), e.combine = THREE.MultiplyOperation), t.reflectivity && (e.reflectivity = t.reflectivity), void 0 !== t.lightMap && (e.lightMap = this.getTexture(t.lightMap)), void 0 !== t.lightMapIntensity && (e.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (e.aoMap = this.getTexture(t.aoMap)), void 0 !== t.aoMapIntensity && (e.aoMapIntensity = t.aoMapIntensity), void 0 !== t.materials)
                for (var n = 0, r = t.materials.length; n < r; n++) e.materials.push(this.parse(t.materials[n]));
            return e
        }
    }, THREE.ObjectLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this.texturePath = ""
    }, THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function(t, e, n, r) {
            "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var i = this,
                o = new THREE.XHRLoader(i.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                i.parse(JSON.parse(t), e)
            }, n, r)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t, e) {
            var n = this.parseGeometries(t.geometries),
                r = this.parseImages(t.images, function() {
                    void 0 !== e && e(i)
                }),
                i = (r = this.parseTextures(t.textures, r), r = this.parseMaterials(t.materials, r), this.parseObject(t.object, n, r));
            return t.animations && (i.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(i), i
        },
        parseGeometries: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = new THREE.JSONLoader, r = new THREE.BufferGeometryLoader, i = 0, o = t.length; i < o; i++) {
                    var a, s = t[i];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new THREE[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            a = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleBufferGeometry":
                            a = new THREE.CircleBufferGeometry(s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CircleGeometry":
                            a = new THREE.CircleGeometry(s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                            a = new THREE.CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                            a = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereBufferGeometry":
                            a = new THREE.SphereBufferGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                            a = new THREE.DodecahedronGeometry(s.radius, s.detail);
                            break;
                        case "IcosahedronGeometry":
                            a = new THREE.IcosahedronGeometry(s.radius, s.detail);
                            break;
                        case "OctahedronGeometry":
                            a = new THREE.OctahedronGeometry(s.radius, s.detail);
                            break;
                        case "TetrahedronGeometry":
                            a = new THREE.TetrahedronGeometry(s.radius, s.detail);
                            break;
                        case "RingGeometry":
                            a = new THREE.RingGeometry(s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                            a = new THREE.TorusGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                            a = new THREE.TorusKnotGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.p, s.q, s.heightScale);
                            break;
                        case "BufferGeometry":
                            a = r.parse(s);
                            break;
                        case "Geometry":
                            a = n.parse(s.data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), e[s.uuid] = a
                }
            return e
        },
        parseMaterials: function(t, e) {
            var n = {};
            if (void 0 !== t) {
                var r = new THREE.MaterialLoader;
                r.setTextures(e);
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = r.parse(t[i]);
                    n[a.uuid] = a
                }
            }
            return n
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var r = THREE.AnimationClip.parse(t[n]);
                e.push(r)
            }
            return e
        },
        parseImages: function(t, e) {
            function n(t) {
                return r.manager.itemStart(t), a.load(t, function() {
                    r.manager.itemEnd(t)
                })
            }
            var r = this,
                i = {};
            if (void 0 !== t && 0 < t.length) {
                var o = new THREE.LoadingManager(e),
                    a = new THREE.ImageLoader(o);
                a.setCrossOrigin(this.crossOrigin);
                o = 0;
                for (var s = t.length; o < s; o++) {
                    var u = t[o],
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u.url) ? u.url : r.texturePath + u.url;
                    i[u.uuid] = n(h)
                }
            }
            return i
        },
        parseTextures: function(t, e) {
            function n(t) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), THREE[t])
            }
            var r = {};
            if (void 0 !== t)
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = t[i];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var s = new THREE.Texture(e[a.image]);
                    s.needsUpdate = !0, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = n(a.mapping)), void 0 !== a.offset && (s.offset = new THREE.Vector2(a.offset[0], a.offset[1])), void 0 !== a.repeat && (s.repeat = new THREE.Vector2(a.repeat[0], a.repeat[1])), void 0 !== a.minFilter && (s.minFilter = n(a.minFilter)), void 0 !== a.magFilter && (s.magFilter = n(a.magFilter)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), Array.isArray(a.wrap) && (s.wrapS = n(a.wrap[0]), s.wrapT = n(a.wrap[1])), r[a.uuid] = s
                }
            return r
        },
        parseObject: function() {
            var t = new THREE.Matrix4;
            return function(e, n, r) {
                function i(t) {
                    return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), n[t]
                }

                function o(t) {
                    if (void 0 !== t) return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined material", t), r[t]
                }
                var a;
                switch (e.type) {
                    case "Scene":
                        a = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        a = new THREE.PerspectiveCamera(e.fov, e.aspect, e.near, e.far);
                        break;
                    case "OrthographicCamera":
                        a = new THREE.OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far);
                        break;
                    case "AmbientLight":
                        a = new THREE.AmbientLight(e.color);
                        break;
                    case "DirectionalLight":
                        a = new THREE.DirectionalLight(e.color, e.intensity);
                        break;
                    case "PointLight":
                        a = new THREE.PointLight(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "SpotLight":
                        a = new THREE.SpotLight(e.color, e.intensity, e.distance, e.angle, e.exponent, e.decay);
                        break;
                    case "HemisphereLight":
                        a = new THREE.HemisphereLight(e.color, e.groundColor, e.intensity);
                        break;
                    case "Mesh":
                        a = new THREE.Mesh(i(e.geometry), o(e.material));
                        break;
                    case "LOD":
                        a = new THREE.LOD;
                        break;
                    case "Line":
                        a = new THREE.Line(i(e.geometry), o(e.material), e.mode);
                        break;
                    case "PointCloud":
                    case "Points":
                        a = new THREE.Points(i(e.geometry), o(e.material));
                        break;
                    case "Sprite":
                        a = new THREE.Sprite(o(e.material));
                        break;
                    case "Group":
                        a = new THREE.Group;
                        break;
                    default:
                        a = new THREE.Object3D
                }
                if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.children)
                    for (var s in e.children) a.add(this.parseObject(e.children[s], n, r));
                if ("LOD" === e.type) {
                    e = e.levels;
                    for (var u = 0; u < e.length; u++) {
                        var h = e[u];
                        void 0 !== (s = a.getObjectByProperty("uuid", h.object)) && a.addLevel(s, h.distance)
                    }
                }
                return a
            }
        }()
    }, THREE.TextureLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function(t, e, n, r) {
            var i = new THREE.Texture,
                o = new THREE.ImageLoader(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.load(t, function(t) {
                i.image = t, i.needsUpdate = !0, void 0 !== e && e(i)
            }, n, r), i
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.CubeTextureLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager
    }, THREE.CubeTextureLoader.prototype = {
        constructor: THREE.CubeTextureLoader,
        load: function(t, e, n, r) {
            function i(n) {
                a.load(t[n], function(t) {
                    o.images[n] = t, 6 === ++s && (o.needsUpdate = !0, e && e(o))
                }, void 0, r)
            }
            var o = new THREE.CubeTexture([]),
                a = new THREE.ImageLoader;
            a.setCrossOrigin(this.crossOrigin);
            var s = 0;
            for (n = 0; n < t.length; ++n) i(n);
            return o
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this._parser = null
    }, THREE.BinaryTextureLoader.prototype = {
        constructor: THREE.BinaryTextureLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = new THREE.DataTexture,
                a = new THREE.XHRLoader(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setResponseType("arraybuffer"), a.load(t, function(t) {
                (t = i._parser(t)) && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : THREE.ClampToEdgeWrapping, o.wrapT = void 0 !== t.wrapT ? t.wrapT : THREE.ClampToEdgeWrapping, o.magFilter = void 0 !== t.magFilter ? t.magFilter : THREE.LinearFilter, o.minFilter = void 0 !== t.minFilter ? t.minFilter : THREE.LinearMipMapLinearFilter, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps), 1 === t.mipmapCount && (o.minFilter = THREE.LinearFilter), o.needsUpdate = !0, e && e(o, t))
            }, n, r), o
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.CompressedTextureLoader = function(t) {
        this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this._parser = null
    }, THREE.CompressedTextureLoader.prototype = {
        constructor: THREE.CompressedTextureLoader,
        load: function(t, e, n, r) {
            var i = this,
                o = [],
                a = new THREE.CompressedTexture;
            a.image = o;
            var s = new THREE.XHRLoader(this.manager);
            if (s.setCrossOrigin(this.crossOrigin), s.setResponseType("arraybuffer"), Array.isArray(t))
                for (var u = 0, h = function(h) {
                        s.load(t[h], function(t) {
                            t = i._parser(t, !0), o[h] = {
                                width: t.width,
                                height: t.height,
                                format: t.format,
                                mipmaps: t.mipmaps
                            }, 6 === (u += 1) && (1 === t.mipmapCount && (a.minFilter = THREE.LinearFilter), a.format = t.format, a.needsUpdate = !0, e && e(a))
                        }, n, r)
                    }, c = 0, l = t.length; c < l; ++c) h(c);
            else s.load(t, function(t) {
                if ((t = i._parser(t, !0)).isCubemap)
                    for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                        o[r] = {
                            mipmaps: []
                        };
                        for (var s = 0; s < t.mipmapCount; s++) o[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + s]), o[r].format = t.format, o[r].width = t.width, o[r].height = t.height
                    } else a.image.width = t.width, a.image.height = t.height, a.mipmaps = t.mipmaps;
                1 === t.mipmapCount && (a.minFilter = THREE.LinearFilter), a.format = t.format, a.needsUpdate = !0, e && e(a)
            }, n, r);
            return a
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        }
    }, THREE.Material = function() {
        Object.defineProperty(this, "id", {
            value: THREE.MaterialIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = THREE.LessEqualDepth, this.colorWrite = this.depthWrite = this.depthTest = !0, this.precision = null, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this._needsUpdate = this.visible = !0
    }, THREE.Material.prototype = {
        constructor: THREE.Material,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(t) {
            !0 === t && this.update(), this._needsUpdate = t
        },
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 === n) console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                    else {
                        var r = this[e];
                        void 0 === r ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : this[e] = "overdraw" === e ? Number(n) : n
                    }
                }
        },
        toJSON: function(t) {
            var e = {
                metadata: {
                    version: 4.4,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), this.color instanceof THREE.Color && (e.color = this.color.getHex()), this.emissive instanceof THREE.Color && (e.emissive = this.emissive.getHex()), this.specular instanceof THREE.Color && (e.specular = this.specular.getHex()), void 0 !== this.shininess && (e.shininess = this.shininess), this.map instanceof THREE.Texture && (e.map = this.map.toJSON(t).uuid), this.alphaMap instanceof THREE.Texture && (e.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap instanceof THREE.Texture && (e.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap instanceof THREE.Texture && (e.bumpMap = this.bumpMap.toJSON(t).uuid, e.bumpScale = this.bumpScale), this.normalMap instanceof THREE.Texture && (e.normalMap = this.normalMap.toJSON(t).uuid, e.normalScale = this.normalScale), this.displacementMap instanceof THREE.Texture && (e.displacementMap = this.displacementMap.toJSON(t).uuid, e.displacementScale = this.displacementScale, e.displacementBias = this.displacementBias), this.specularMap instanceof THREE.Texture && (e.specularMap = this.specularMap.toJSON(t).uuid), this.envMap instanceof THREE.Texture && (e.envMap = this.envMap.toJSON(t).uuid, e.reflectivity = this.reflectivity), void 0 !== this.size && (e.size = this.size), void 0 !== this.sizeAttenuation && (e.sizeAttenuation = this.sizeAttenuation), void 0 !== this.vertexColors && this.vertexColors !== THREE.NoColors && (e.vertexColors = this.vertexColors), void 0 !== this.shading && this.shading !== THREE.SmoothShading && (e.shading = this.shading), void 0 !== this.blending && this.blending !== THREE.NormalBlending && (e.blending = this.blending), void 0 !== this.side && this.side !== THREE.FrontSide && (e.side = this.side), 1 > this.opacity && (e.opacity = this.opacity), !0 === this.transparent && (e.transparent = this.transparent), 0 < this.alphaTest && (e.alphaTest = this.alphaTest), !0 === this.wireframe && (e.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (e.wireframeLinewidth = this.wireframeLinewidth), e
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name, this.side = t.side, this.opacity = t.opacity, this.transparent = t.transparent, this.blending = t.blending, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.alphaTest = t.alphaTest, this.overdraw = t.overdraw, this.visible = t.visible, this
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        get wrapAround() {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
        },
        set wrapAround(t) {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
        },
        get wrapRGB() {
            return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new THREE.Color
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function(t) {
        THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t)
    }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.vertexColors = t.vertexColors, this.fog = t.fog, this
    }, THREE.LineDashedMaterial = function(t) {
        THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(t)
    }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this.vertexColors = t.vertexColors, this.fog = t.fog, this
    }, THREE.MeshBasicMaterial = function(t) {
        THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), this.aoMap = this.map = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(t)
    }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.fog = t.fog, this.shading = t.shading, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.vertexColors = t.vertexColors, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }, THREE.MeshLambertMaterial = function(t) {
        THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.envMap = this.alphaMap = this.specularMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.emissive.copy(t.emissive), this.map = t.map, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.fog = t.fog, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.vertexColors = t.vertexColors, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, THREE.MeshPhongMaterial = function(t) {
        THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.metal = !1, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.emissive.copy(t.emissive), this.specular.copy(t.specular), this.shininess = t.shininess, this.metal = t.metal, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissiveMap = t.emissiveMap, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.fog = t.fog, this.shading = t.shading, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.vertexColors = t.vertexColors, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, THREE.MeshDepthMaterial = function(t) {
        THREE.Material.call(this), this.type = "MeshDepthMaterial", this.wireframe = this.morphTargets = !1, this.wireframeLinewidth = 1, this.setValues(t)
    }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, THREE.MeshNormalMaterial = function(t) {
        THREE.Material.call(this, t), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(t)
    }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, THREE.MultiMaterial = function(t) {
        this.uuid = THREE.Math.generateUUID(), this.type = "MultiMaterial", this.materials = t instanceof Array ? t : [], this.visible = !0
    }, THREE.MultiMaterial.prototype = {
        constructor: THREE.MultiMaterial,
        toJSON: function() {
            for (var t = {
                    metadata: {
                        version: 4.2,
                        type: "material",
                        generator: "MaterialExporter"
                    },
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, e = 0, n = this.materials.length; e < n; e++) t.materials.push(this.materials[e].toJSON());
            return t.visible = this.visible, t
        },
        clone: function() {
            for (var t = new this.constructor, e = 0; e < this.materials.length; e++) t.materials.push(this.materials[e].clone());
            return t.visible = this.visible, t
        }
    }, THREE.MeshFaceMaterial = THREE.MultiMaterial, THREE.PointsMaterial = function(t) {
        THREE.Material.call(this), this.type = "PointsMaterial", this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t)
    }, THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial, THREE.PointsMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.vertexColors = t.vertexColors, this.fog = t.fog, this
    }, THREE.PointCloudMaterial = function(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(t)
    }, THREE.ParticleBasicMaterial = function(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(t)
    }, THREE.ParticleSystemMaterial = function(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new THREE.PointsMaterial(t)
    }, THREE.ShaderMaterial = function(t) {
        THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.derivatives = this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, THREE.ShaderMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = THREE.UniformsUtils.clone(t.uniforms), this.attributes = t.attributes, this.defines = t.defines, this.shading = t.shading, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.vertexColors = t.vertexColors, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.derivatives = t.derivatives, this
    }, THREE.ShaderMaterial.prototype.toJSON = function(t) {
        return (t = THREE.Material.prototype.toJSON.call(this, t)).uniforms = this.uniforms, t.attributes = this.attributes, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
    }, THREE.RawShaderMaterial = function(t) {
        THREE.ShaderMaterial.call(this, t), this.type = "RawShaderMaterial"
    }, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.SpriteMaterial = function(t) {
        THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(t)
    }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, THREE.SpriteMaterial.prototype.copy = function(t) {
        return THREE.Material.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.fog = t.fog, this
    }, THREE.Texture = function(t, e, n, r, i, o, a, s, u) {
        Object.defineProperty(this, "id", {
            value: THREE.TextureIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.sourceFile = this.name = "", this.image = void 0 !== t ? t : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i ? i : THREE.LinearFilter, this.minFilter = void 0 !== o ? o : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== a ? a : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.version = 0, this.onUpdate = null
    }, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, THREE.Texture.prototype = {
        constructor: THREE.Texture,
        set needsUpdate(t) {
            !0 === t && this.version++
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this
        },
        toJSON: function(t) {
            if (void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var e = {
                metadata: {
                    version: 4.4,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = THREE.Math.generateUUID()), void 0 === t.images[n.uuid]) {
                    var r, i = t.images,
                        o = n.uuid,
                        a = n.uuid;
                    void 0 !== n.toDataURL ? r = n : ((r = document.createElement("canvas")).width = n.width, r.height = n.height, r.getContext("2d").drawImage(n, 0, 0, n.width, n.height)), r = 2048 < r.width || 2048 < r.height ? r.toDataURL("image/jpeg", .6) : r.toDataURL("image/png"), i[o] = {
                        uuid: a,
                        url: r
                    }
                }
                e.image = n.uuid
            }
            return t.textures[this.uuid] = e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping === THREE.UVMapping) {
                if (t.multiply(this.repeat), t.add(this.offset), 0 > t.x || 1 < t.x) switch (this.wrapS) {
                    case THREE.RepeatWrapping:
                        t.x -= Math.floor(t.x);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        t.x = 0 > t.x ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x -= Math.floor(t.x)
                }
                if (0 > t.y || 1 < t.y) switch (this.wrapT) {
                    case THREE.RepeatWrapping:
                        t.y -= Math.floor(t.y);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        t.y = 0 > t.y ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y -= Math.floor(t.y)
                }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CanvasTexture = function(t, e, n, r, i, o, a, s, u) {
        THREE.Texture.call(this, t, e, n, r, i, o, a, s, u), this.needsUpdate = !0
    }, THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture, THREE.CubeTexture = function(t, e, n, r, i, o, a, s, u) {
        e = void 0 !== e ? e : THREE.CubeReflectionMapping, THREE.Texture.call(this, t, e, n, r, i, o, a, s, u), this.images = t, this.flipY = !1
    }, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, THREE.CubeTexture.prototype.copy = function(t) {
        return THREE.Texture.prototype.copy.call(this, t), this.images = t.images, this
    }, THREE.CompressedTexture = function(t, e, n, r, i, o, a, s, u, h, c) {
        THREE.Texture.call(this, null, o, a, s, u, h, r, i, c), this.image = {
            width: e,
            height: n
        }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1
    }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, THREE.DataTexture = function(t, e, n, r, i, o, a, s, u, h, c) {
        THREE.Texture.call(this, null, o, a, s, u, h, r, i, c), this.image = {
            data: t,
            width: e,
            height: n
        }, this.magFilter = void 0 !== u ? u : THREE.NearestFilter, this.minFilter = void 0 !== h ? h : THREE.NearestFilter, this.generateMipmaps = this.flipY = !1
    }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, THREE.VideoTexture = function(t, e, n, r, i, o, a, s, u) {
        THREE.Texture.call(this, t, e, n, r, i, o, a, s, u), this.generateMipmaps = !1;
        var h = this;
        ! function e() {
            requestAnimationFrame(e), t.readyState === t.HAVE_ENOUGH_DATA && (h.needsUpdate = !0)
        }()
    }, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, THREE.Group = function() {
        THREE.Object3D.call(this), this.type = "Group"
    }, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group, THREE.Points = function(t, e) {
        THREE.Object3D.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.PointsMaterial({
            color: 16777215 * Math.random()
        })
    }, THREE.Points.prototype = Object.create(THREE.Object3D.prototype), THREE.Points.prototype.constructor = THREE.Points, THREE.Points.prototype.raycast = function() {
        var t = new THREE.Matrix4,
            e = new THREE.Ray;
        return function(n, r) {
            function i(t, i) {
                var a = e.distanceSqToPoint(t);
                if (a < u) {
                    var s = e.closestPointToPoint(t);
                    s.applyMatrix4(o.matrixWorld);
                    var h = n.ray.origin.distanceTo(s);
                    h < n.near || h > n.far || r.push({
                        distance: h,
                        distanceToRay: Math.sqrt(a),
                        point: s.clone(),
                        index: i,
                        face: null,
                        object: o
                    })
                }
            }
            var o = this,
                a = o.geometry,
                s = n.params.Points.threshold;
            if (t.getInverse(this.matrixWorld), e.copy(n.ray).applyMatrix4(t), null === a.boundingBox || !1 !== e.isIntersectionBox(a.boundingBox)) {
                var u = (s = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)) * s;
                s = new THREE.Vector3;
                if (a instanceof THREE.BufferGeometry) {
                    var h = a.index;
                    a = a.attributes.position.array;
                    if (null !== h)
                        for (var c = h.array, l = (h = 0, c.length); h < l; h++) {
                            var p = c[h];
                            s.fromArray(a, 3 * p), i(s, p)
                        } else
                            for (h = 0, c = a.length / 3; h < c; h++) s.fromArray(a, 3 * h), i(s, h)
                } else
                    for (h = 0, c = (s = a.vertices).length; h < c; h++) i(s[h], h)
            }
        }
    }(), THREE.Points.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    }, THREE.PointCloud = function(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new THREE.Points(t, e)
    }, THREE.ParticleSystem = function(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new THREE.Points(t, e)
    }, THREE.Line = function(t, e, n) {
        if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new THREE.LineSegments(t, e);
        THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.LineBasicMaterial({
            color: 16777215 * Math.random()
        })
    }, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function() {
        var t = new THREE.Matrix4,
            e = new THREE.Ray,
            n = new THREE.Sphere;
        return function(r, i) {
            var o = (o = r.linePrecision) * o;
            if (null === (f = this.geometry).boundingSphere && f.computeBoundingSphere(), n.copy(f.boundingSphere), n.applyMatrix4(this.matrixWorld), !1 !== r.ray.isIntersectionSphere(n)) {
                t.getInverse(this.matrixWorld), e.copy(r.ray).applyMatrix4(t);
                var a = new THREE.Vector3,
                    s = new THREE.Vector3,
                    u = new THREE.Vector3,
                    h = new THREE.Vector3,
                    c = this instanceof THREE.LineSegments ? 2 : 1;
                if (f instanceof THREE.BufferGeometry) {
                    var l = f.index,
                        p = f.attributes;
                    if (null !== l)
                        for (var f = l.array, d = (p = p.position.array, l = 0, f.length - 1); l < d; l += c) {
                            var E = f[l + 1];
                            a.fromArray(p, 3 * f[l]), s.fromArray(p, 3 * E), (E = e.distanceSqToSegment(a, s, h, u)) > o || (h.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(h)) < r.near || E > r.far || i.push({
                                distance: E,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: l,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        } else
                            for (l = 0, d = (p = p.position.array).length / 3 - 1; l < d; l += c) a.fromArray(p, 3 * l), s.fromArray(p, 3 * l + 3), (E = e.distanceSqToSegment(a, s, h, u)) > o || (h.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(h)) < r.near || E > r.far || i.push({
                                distance: E,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: l,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                } else if (f instanceof THREE.Geometry)
                    for (s = (a = f.vertices).length, l = 0; l < s - 1; l += c)(E = e.distanceSqToSegment(a[l], a[l + 1], h, u)) > o || (h.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(h)) < r.near || E > r.far || i.push({
                        distance: E,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: l,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
            }
        }
    }(), THREE.Line.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    }, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.LineSegments = function(t, e) {
        THREE.Line.call(this, t, e), this.type = "LineSegments"
    }, THREE.LineSegments.prototype = Object.create(THREE.Line.prototype), THREE.LineSegments.prototype.constructor = THREE.LineSegments, THREE.Mesh = function(t, e) {
        THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.updateMorphTargets()
    }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, THREE.Mesh.prototype.updateMorphTargets = function() {
        if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
            this.morphTargetBase = -1, this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t
        }
    }, THREE.Mesh.prototype.getMorphTargetIndexByName = function(t) {
        return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."), 0)
    }, THREE.Mesh.prototype.raycast = function() {
        function t(t, e, n, r, i, o, a) {
            return THREE.Triangle.barycoordFromPoint(t, e, n, r, E), i.multiplyScalar(E.x), o.multiplyScalar(E.y), a.multiplyScalar(E.z), i.add(o).add(a), i.clone()
        }

        function e(t, e, n, r, i, o, a) {
            var s = t.material;
            return null === (s.side === THREE.BackSide ? n.intersectTriangle(o, i, r, !0, a) : n.intersectTriangle(r, i, o, s.side !== THREE.DoubleSide, a)) ? null : (g.copy(a), g.applyMatrix4(t.matrixWorld), (n = e.ray.origin.distanceTo(g)) < e.near || n > e.far ? null : {
                distance: n,
                point: g.clone(),
                object: t
            })
        }

        function n(n, r, i, o, h, c, l, E) {
            return a.fromArray(o, 3 * c), s.fromArray(o, 3 * l), u.fromArray(o, 3 * E), (n = e(n, r, i, a, s, u, m)) && (h && (p.fromArray(h, 2 * c), f.fromArray(h, 2 * l), d.fromArray(h, 2 * E), n.uv = t(m, a, s, u, p, f, d)), n.face = new THREE.Face3(c, l, E, THREE.Triangle.normal(a, s, u)), n.faceIndex = c), n
        }
        var r = new THREE.Matrix4,
            i = new THREE.Ray,
            o = new THREE.Sphere,
            a = new THREE.Vector3,
            s = new THREE.Vector3,
            u = new THREE.Vector3,
            h = new THREE.Vector3,
            c = new THREE.Vector3,
            l = new THREE.Vector3,
            p = new THREE.Vector2,
            f = new THREE.Vector2,
            d = new THREE.Vector2,
            E = new THREE.Vector3,
            m = new THREE.Vector3,
            g = new THREE.Vector3;
        return function(E, g) {
            var v = this.geometry;
            if (void 0 !== (H = this.material)) {
                null === v.boundingSphere && v.computeBoundingSphere();
                var y, T, R = this.matrixWorld;
                if (o.copy(v.boundingSphere), o.applyMatrix4(R), !1 !== E.ray.isIntersectionSphere(o) && (r.getInverse(R), i.copy(E.ray).applyMatrix4(r), null === v.boundingBox || !1 !== i.isIntersectionBox(v.boundingBox)))
                    if (v instanceof THREE.BufferGeometry) {
                        var x, b, H = v.index;
                        v = (R = v.attributes).position.array;
                        if (void 0 !== R.uv && (y = R.uv.array), null !== H)
                            for (var _ = 0, w = (R = H.array).length; _ < w; _ += 3) H = R[_], x = R[_ + 1], b = R[_ + 2], (T = n(this, E, i, v, y, H, x, b)) && (T.faceIndex = Math.floor(_ / 3), g.push(T));
                        else
                            for (_ = 0, w = v.length; _ < w; _ += 9)(T = n(this, E, i, v, y, H = _ / 3, x = H + 1, b = H + 2)) && (T.index = H, g.push(T))
                    } else if (v instanceof THREE.Geometry) {
                    var M, S;
                    _ = !0 === (R = H instanceof THREE.MeshFaceMaterial) ? H.materials : null, w = v.vertices;
                    x = v.faces, 0 < (b = v.faceVertexUvs[0]).length && (y = b);
                    for (var A = 0, C = x.length; A < C; A++) {
                        var L = x[A];
                        if (void 0 !== (T = !0 === R ? _[L.materialIndex] : H)) {
                            if (b = w[L.a], M = w[L.b], S = w[L.c], !0 === T.morphTargets) {
                                T = v.morphTargets;
                                var k = this.morphTargetInfluences;
                                a.set(0, 0, 0), s.set(0, 0, 0), u.set(0, 0, 0);
                                for (var P = 0, D = T.length; P < D; P++) {
                                    var N = k[P];
                                    if (0 !== N) {
                                        var F = T[P].vertices;
                                        a.addScaledVector(h.subVectors(F[L.a], b), N), s.addScaledVector(c.subVectors(F[L.b], M), N), u.addScaledVector(l.subVectors(F[L.c], S), N)
                                    }
                                }
                                a.add(b), s.add(M), u.add(S), b = a, M = s, S = u
                            }(T = e(this, E, i, b, M, S, m)) && (y && (k = y[A], p.copy(k[0]), f.copy(k[1]), d.copy(k[2]), T.uv = t(m, b, M, S, p, f, d)), T.face = L, T.faceIndex = A, g.push(T))
                        }
                    }
                }
            }
        }
    }(), THREE.Mesh.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material).copy(this)
    }, THREE.Bone = function(t) {
        THREE.Object3D.call(this), this.type = "Bone", this.skin = t
    }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, THREE.Bone.prototype.copy = function(t) {
        return THREE.Object3D.prototype.copy.call(this, t), this.skin = t.skin, this
    }, THREE.Skeleton = function(t, e, n) {
        if (this.useVertexTexture = void 0 === n || n, this.identityMatrix = new THREE.Matrix4, t = t || [], this.bones = t.slice(0), this.useVertexTexture ? (t = Math.sqrt(4 * this.bones.length), t = THREE.Math.nextPowerOfTwo(Math.ceil(t)), this.boneTextureHeight = this.boneTextureWidth = t = Math.max(t, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)) : this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else
            for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new THREE.Matrix4)
    }, THREE.Skeleton.prototype.calculateInverses = function() {
        this.boneInverses = [];
        for (var t = 0, e = this.bones.length; t < e; t++) {
            var n = new THREE.Matrix4;
            this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
        }
    }, THREE.Skeleton.prototype.pose = function() {
        for (var t, e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
    }, THREE.Skeleton.prototype.update = function() {
        var t = new THREE.Matrix4;
        return function() {
            for (var e = 0, n = this.bones.length; e < n; e++) t.multiplyMatrices(this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix, this.boneInverses[e]), t.flattenToArrayOffset(this.boneMatrices, 16 * e);
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
        }
    }(), THREE.Skeleton.prototype.clone = function() {
        return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture)
    }, THREE.SkinnedMesh = function(t, e, n) {
        if (THREE.Mesh.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4, t = [], this.geometry && void 0 !== this.geometry.bones) {
            for (var r, i = 0, o = this.geometry.bones.length; i < o; ++i) r = this.geometry.bones[i], e = new THREE.Bone(this), t.push(e), e.name = r.name, e.position.fromArray(r.pos), e.quaternion.fromArray(r.rotq), void 0 !== r.scl && e.scale.fromArray(r.scl);
            for (i = 0, o = this.geometry.bones.length; i < o; ++i) - 1 !== (r = this.geometry.bones[i]).parent && null !== r.parent ? t[r.parent].add(t[i]) : this.add(t[i])
        }
        this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(t, void 0, n), this.matrixWorld)
    }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, THREE.SkinnedMesh.prototype.bind = function(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
    }, THREE.SkinnedMesh.prototype.pose = function() {
        this.skeleton.pose()
    }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
        if (this.geometry instanceof THREE.Geometry)
            for (var t = 0; t < this.geometry.skinIndices.length; t++) {
                var e = this.geometry.skinWeights[t],
                    n = 1 / e.lengthManhattan();
                1 / 0 !== n ? e.multiplyScalar(n) : e.set(1)
            }
    }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function(t) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
    }, THREE.SkinnedMesh.prototype.clone = function() {
        return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this)
    }, THREE.LOD = function() {
        THREE.Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        })
    }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, THREE.LOD.prototype.addLevel = function(t, e) {
        void 0 === e && (e = 0), e = Math.abs(e);
        for (var n = this.levels, r = 0; r < n.length && !(e < n[r].distance); r++);
        n.splice(r, 0, {
            distance: e,
            object: t
        }), this.add(t)
    }, THREE.LOD.prototype.getObjectForDistance = function(t) {
        for (var e = this.levels, n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
        return e[n - 1].object
    }, THREE.LOD.prototype.raycast = function() {
        var t = new THREE.Vector3;
        return function(e, n) {
            t.setFromMatrixPosition(this.matrixWorld);
            var r = e.ray.origin.distanceTo(t);
            this.getObjectForDistance(r).raycast(e, n)
        }
    }(), THREE.LOD.prototype.update = function() {
        var t = new THREE.Vector3,
            e = new THREE.Vector3;
        return function(n) {
            var r = this.levels;
            if (1 < r.length) {
                t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), n = t.distanceTo(e), r[0].object.visible = !0;
                for (var i = 1, o = r.length; i < o && n >= r[i].distance; i++) r[i - 1].object.visible = !1, r[i].object.visible = !0;
                for (; i < o; i++) r[i].object.visible = !1
            }
        }
    }(), THREE.LOD.prototype.copy = function(t) {
        THREE.Object3D.prototype.copy.call(this, t, !1);
        for (var e = 0, n = (t = t.levels).length; e < n; e++) {
            var r = t[e];
            this.addLevel(r.object.clone(), r.distance)
        }
        return this
    }, THREE.LOD.prototype.toJSON = function(t) {
        (t = THREE.Object3D.prototype.toJSON.call(this, t)).object.levels = [];
        for (var e = this.levels, n = 0, r = e.length; n < r; n++) {
            var i = e[n];
            t.object.levels.push({
                object: i.object.uuid,
                distance: i.distance
            })
        }
        return t
    }, THREE.Sprite = function() {
        var t = new Uint16Array([0, 1, 2, 0, 2, 3]),
            e = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
            n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            r = new THREE.BufferGeometry;
        return r.setIndex(new THREE.BufferAttribute(t, 1)), r.addAttribute("position", new THREE.BufferAttribute(e, 3)), r.addAttribute("uv", new THREE.BufferAttribute(n, 2)),
            function(t) {
                THREE.Object3D.call(this), this.type = "Sprite", this.geometry = r, this.material = void 0 !== t ? t : new THREE.SpriteMaterial
            }
    }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, THREE.Sprite.prototype.raycast = function() {
        var t = new THREE.Vector3;
        return function(e, n) {
            t.setFromMatrixPosition(this.matrixWorld);
            var r = e.ray.distanceSqToPoint(t);
            r > this.scale.x * this.scale.y || n.push({
                distance: Math.sqrt(r),
                point: this.position,
                face: null,
                object: this
            })
        }
    }(), THREE.Sprite.prototype.clone = function() {
        return new this.constructor(this.material).copy(this)
    }, THREE.Particle = THREE.Sprite, THREE.LensFlare = function(t, e, n, r, i) {
        THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, n, r, i)
    }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare, THREE.LensFlare.prototype.add = function(t, e, n, r, i, o) {
        void 0 === e && (e = -1), void 0 === n && (n = 0), void 0 === o && (o = 1), void 0 === i && (i = new THREE.Color(16777215)), void 0 === r && (r = THREE.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
            texture: t,
            size: e,
            distance: n,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 0,
            opacity: o,
            color: i,
            blending: r
        })
    }, THREE.LensFlare.prototype.updateLensFlares = function() {
        var t, e, n = this.lensFlares.length,
            r = 2 * -this.positionScreen.x,
            i = 2 * -this.positionScreen.y;
        for (t = 0; t < n; t++)(e = this.lensFlares[t]).x = this.positionScreen.x + r * e.distance, e.y = this.positionScreen.y + i * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
    }, THREE.LensFlare.prototype.copy = function(t) {
        THREE.Object3D.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
        for (var e = 0, n = t.lensFlares.length; e < n; e++) this.lensFlares.push(t.lensFlares[e]);
        return this
    }, THREE.Scene = function() {
        THREE.Object3D.call(this), this.type = "Scene", this.overrideMaterial = this.fog = null, this.autoUpdate = !0
    }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, THREE.Scene.prototype.copy = function(t) {
        return THREE.Object3D.prototype.copy.call(this, t), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }, THREE.Fog = function(t, e, n) {
        this.name = "", this.color = new THREE.Color(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
    }, THREE.Fog.prototype.clone = function() {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    }, THREE.FogExp2 = function(t, e) {
        this.name = "", this.color = new THREE.Color(t), this.density = void 0 !== e ? e : 25e-5
    }, THREE.FogExp2.prototype.clone = function() {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    }, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n", THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\n\ttotalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n", THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif", THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n", THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif", THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n\tif ( decayExponent > 0.0 ) {\n\n\t  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n\tfloat fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n\treturn ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( lightDir, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n\t#ifdef GAMMA_INPUT\n\n\t\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n\t#else\n\n\t\treturn a;\n\n\t#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n\t#ifdef GAMMA_OUTPUT\n\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n\t#else\n\n\t\treturn a;\n\n\t#endif\n\n}\n", THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n", THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n", THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n\ttotalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n", THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif", THREE.ShaderChunk.hemilight_fragment = "#if MAX_HEMI_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lightDir = hemisphereLightDirection[ i ];\n\n\t\tfloat dotProduct = dot( normal, lightDir );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\ttotalAmbientLight += lightColor;\n\n\t}\n\n#endif\n\n", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n\ttotalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = pointLightColor[ i ];\n\n\t\tvec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n\t\tvec3 lightDir = normalize( lVector );\n\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n\t\tfloat dotProduct = dot( normal, lightDir );\n\n\t\tvLightFront += lightColor * attenuation * saturate( dotProduct );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = spotLightColor[ i ];\n\n\t\tvec3 lightPosition = spotLightPosition[ i ];\n\t\tvec3 lVector = lightPosition - mvPosition.xyz;\n\t\tvec3 lightDir = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\t\tattenuation *= spotEffect;\n\n\n\t\t\tfloat dotProduct = dot( normal, lightDir );\n\n\t\t\tvLightFront += lightColor * attenuation * saturate( dotProduct );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = directionalLightColor[ i ];\n\n\t\tvec3 lightDir = directionalLightDirection[ i ];\n\n\n\t\tfloat dotProduct = dot( normal, lightDir );\n\n\t\tvLightFront += lightColor * saturate( dotProduct );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += lightColor * saturate( - dotProduct );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lightDir = hemisphereLightDirection[ i ];\n\n\n\t\tfloat dotProduct = dot( normal, lightDir );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tfloat hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n", THREE.ShaderChunk.lights_phong_fragment = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = pointLightColor[ i ];\n\n\t\tvec3 lightPosition = pointLightPosition[ i ];\n\t\tvec3 lVector = lightPosition + vViewPosition.xyz;\n\t\tvec3 lightDir = normalize( lVector );\n\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\n\n\t\ttotalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n\t\ttotalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = spotLightColor[ i ];\n\n\t\tvec3 lightPosition = spotLightPosition[ i ];\n\t\tvec3 lVector = lightPosition + vViewPosition.xyz;\n\t\tvec3 lightDir = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\t\tattenuation *= spotEffect;\n\n\n\t\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\n\n\t\t\ttotalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n\t\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n\t\t\ttotalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec3 lightColor = directionalLightColor[ i ];\n\n\t\tvec3 lightDir = directionalLightDirection[ i ];\n\n\n\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\n\n\t\ttotalDiffuseLight += lightColor * cosineTerm;\n\n\n\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n\t\ttotalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n\t}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "\n\toutgoingLight = linearToOutput( outgoingLight );\n", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\n\tdiffuseColor *= texelColor;\n\n#endif\n", THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.normal_phong_fragment = "#ifndef FLAT_SHADED\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n\t#endif\n\n#else\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n", THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n\tfor ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tfloat texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n\t\tfloat shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n\t\tbool isPointLight = shadowDarkness[ i ] < 0.0;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tfloat realShadowDarkness = abs( shadowDarkness[ i ] );\n\n\t\t\tvec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tfloat dp = length( lightToPosition );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tconst float Dr = 1.25;\n\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tconst float Dr = 2.25;\n\t#endif\n\n\t\t\tfloat os = Dr *  2.0 * texelSizeY;\n\n\t\t\tconst vec3 Gsd = vec3( - 1, 0, 1 );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tshadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n\t#else \n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tfloat dp = length( lightToPosition );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tshadow *= realShadowDarkness;\n\n\t#endif\n\n\t\t} else {\n\n#endif \n\t\t\tfloat texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n\t\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t\tbool frustumTest = all( frustumTestVec );\n\n\t\t\tif ( frustumTest ) {\n\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\n\t\t\t\t/*\n\t\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\t\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\t\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\t\tshadow += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tshadow /= 9.0;\n\t\t\t\t*/\n\n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tconst float ShadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = texelSizeX;\n\t\t\t\tfloat yPixelOffset = texelSizeY;\n\n\t\t\t\tfloat dx0 = - 1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = - 1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfloat fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tshadow *= shadowDarkness[ i ];\n\n\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tfloat xPixelOffset = texelSizeX;\n\t\t\t\tfloat yPixelOffset = texelSizeY;\n\n\t\t\t\tfloat dx0 = - 1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = - 1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 0 ] *= vec3( 0.25 );\n\n\t\t\t\tshadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 1 ] *= vec3( 0.25 );\n\n\t\t\t\tshadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 2 ] *= vec3( 0.25 );\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n\t\t\t\tshadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n\t\t\t\tshadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n\t#else \n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\tshadow = shadowDarkness[ i ];\n\n\t#endif\n\n\t\t\t}\n\n#ifdef SHADOWMAP_DEBUG\n\n\t\t\tif ( inFrustum ) {\n\n\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\toutgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n\t\t\t\t} else if ( i == 1 ) {\n\n\t\t\t\t\toutgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toutgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n\t\t}\n\n#endif\n\n\t\tshadowMask = shadowMask * vec3( 1.0 - shadow );\n\n\t}\n\n#endif\n", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n\t#if defined(POINT_LIGHT_SHADOWS)\n\n\n\t\tvoid adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n\t\t\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\t\tif ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n\t\t\t\tshadowValue += 1.0;\n\n\t\t}\n\n\n\t\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n\t\t\tvec3 absV = abs( v );\n\n\n\t\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\t\tabsV *= scaleToCube;\n\n\n\t\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n\t\t\tvec2 planar = v.xy;\n\n\t\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\t\tif ( absV.z >= almostOne ) {\n\n\t\t\t\tif ( v.z > 0.0 )\n\t\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\t\tfloat signX = sign( v.x );\n\t\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\t\tfloat signY = sign( v.y );\n\t\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t\t}\n\n\n\t\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t\t}\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n\tfor ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif", THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n\tvarying vec2 vUv;\n\n#endif", THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n\t#endif\n\n#endif\n", THREE.UniformsUtils = {
        merge: function(t) {
            for (var e = {}, n = 0; n < t.length; n++) {
                var r, i = this.clone(t[n]);
                for (r in i) e[r] = i[r]
            }
            return e
        },
        clone: function(t) {
            var e, n = {};
            for (e in t)
                for (var r in n[e] = {}, t[e]) {
                    var i = t[e][r];
                    i instanceof THREE.Color || i instanceof THREE.Vector2 || i instanceof THREE.Vector3 || i instanceof THREE.Vector4 || i instanceof THREE.Matrix3 || i instanceof THREE.Matrix4 || i instanceof THREE.Texture ? n[e][r] = i.clone() : Array.isArray(i) ? n[e][r] = i.slice() : n[e][r] = i
                }
            return n
        }
    }, THREE.UniformsLib = {
        common: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            specularMap: {
                type: "t",
                value: null
            },
            alphaMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            }
        },
        aomap: {
            aoMap: {
                type: "t",
                value: null
            },
            aoMapIntensity: {
                type: "f",
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                type: "t",
                value: null
            },
            lightMapIntensity: {
                type: "f",
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                type: "t",
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                type: "t",
                value: null
            },
            displacementScale: {
                type: "f",
                value: 1
            },
            displacementBias: {
                type: "f",
                value: 0
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                type: "fv",
                value: []
            },
            directionalLightDirection: {
                type: "fv",
                value: []
            },
            directionalLightColor: {
                type: "fv",
                value: []
            },
            hemisphereLightDirection: {
                type: "fv",
                value: []
            },
            hemisphereLightSkyColor: {
                type: "fv",
                value: []
            },
            hemisphereLightGroundColor: {
                type: "fv",
                value: []
            },
            pointLightColor: {
                type: "fv",
                value: []
            },
            pointLightPosition: {
                type: "fv",
                value: []
            },
            pointLightDistance: {
                type: "fv1",
                value: []
            },
            pointLightDecay: {
                type: "fv1",
                value: []
            },
            spotLightColor: {
                type: "fv",
                value: []
            },
            spotLightPosition: {
                type: "fv",
                value: []
            },
            spotLightDirection: {
                type: "fv",
                value: []
            },
            spotLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightAngleCos: {
                type: "fv1",
                value: []
            },
            spotLightExponent: {
                type: "fv1",
                value: []
            },
            spotLightDecay: {
                type: "fv1",
                value: []
            }
        },
        points: {
            psColor: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        shadowmap: {
            shadowMap: {
                type: "tv",
                value: []
            },
            shadowMapSize: {
                type: "v2v",
                value: []
            },
            shadowBias: {
                type: "fv1",
                value: []
            },
            shadowDarkness: {
                type: "fv1",
                value: []
            },
            shadowMatrix: {
                type: "m4v",
                value: []
            }
        }
    }, THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tvec3 totalAmbientLight = vec3( 1.0 );\n\tvec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.aomap_fragment, THREE.ShaderChunk.shadowmap_fragment, "\toutgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                }
            }]),
            vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nuniform vec3 ambientLightColor;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tvec3 totalAmbientLight = ambientLightColor;\n\tvec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.shadowmap_fragment, "\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\toutgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;\n\t\telse\n\t\t\toutgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;\n\t#else\n\t\toutgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;\n\t#endif", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                }
            }]),
            vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.uv_pars_vertex, THREE.ShaderChunk.uv2_pars_vertex, THREE.ShaderChunk.displacementmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.uv_vertex, THREE.ShaderChunk.uv2_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.beginnormal_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.displacementmap_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = - mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.emissivemap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tvec3 totalAmbientLight = ambientLightColor;\n\tvec3 totalEmissiveLight = emissive;\n\tvec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.normal_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.hemilight_fragment, THREE.ShaderChunk.aomap_fragment, THREE.ShaderChunk.emissivemap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.shadowmap_fragment, "totalDiffuseLight *= shadowMask;\ntotalSpecularLight *= shadowMask;\n#ifdef METAL\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n#else\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n#endif", THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        points: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.points, THREE.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( psColor, opacity );\n\tvec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.shadowmap_fragment, "\toutgoingLight = diffuseColor.rgb * shadowMask;", THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")
        },
        distanceRGBA: {
            uniforms: {
                lightPos: {
                    type: "v3",
                    value: new THREE.Vector3(0, 0, 0)
                }
            },
            vertexShader: ["varying vec4 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.begin_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.project_vertex, THREE.ShaderChunk.worldpos_vertex, "vWorldPosition = worldPosition;\n}"].join("\n"),
            fragmentShader: ["uniform vec3 lightPos;\nvarying vec4 vWorldPosition;", THREE.ShaderChunk.common, "vec4 pack1K ( float depth ) {\n   depth /= 1000.0;\n   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = fract( depth * bitSh );\n\tres -= res.xxyz * bitMsk;\n\treturn res; \n}\nfloat unpack1K ( vec4 color ) {\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\treturn dot( color, bitSh ) * 1000.0;\n}\nvoid main () {\n\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\n}"].join("\n")
        }
    }, THREE.WebGLRenderer = function(t) {
        function e(t, e, n, r) {
            !0 === O && (t *= r, e *= r, n *= r), K.clearColor(t, e, n, r)
        }

        function n() {
            yt.init(), K.viewport(rt, it, ot, at), e(U.r, U.g, U.b, B)
        }

        function r() {
            et = Q = null, tt = "", $ = -1, ft = !0, yt.reset()
        }

        function i(t) {
            t.preventDefault(), r(), n(), Tt.clear()
        }

        function o(t) {
            (t = t.target).removeEventListener("dispose", o);
            t: {
                var e = Tt.get(t);
                if (t.image && e.__image__webglTextureCube) K.deleteTexture(e.__image__webglTextureCube);
                else {
                    if (void 0 === e.__webglInit) break t;
                    K.deleteTexture(e.__webglTexture)
                }
                Tt.delete(t)
            }
            Et.textures--
        }

        function a(t) {
            (t = t.target).removeEventListener("dispose", a);
            var e = Tt.get(t),
                n = Tt.get(t.texture);
            if (t && void 0 !== n.__webglTexture) {
                if (K.deleteTexture(n.__webglTexture), t instanceof THREE.WebGLRenderTargetCube)
                    for (n = 0; 6 > n; n++) K.deleteFramebuffer(e.__webglFramebuffer[n]), K.deleteRenderbuffer(e.__webglRenderbuffer[n]);
                else K.deleteFramebuffer(e.__webglFramebuffer), K.deleteRenderbuffer(e.__webglRenderbuffer);
                Tt.delete(t.texture), Tt.delete(t)
            }
            Et.textures--
        }

        function s(t) {
            (t = t.target).removeEventListener("dispose", s), u(t), Tt.delete(t)
        }

        function u(t) {
            var e = Tt.get(t).program;
            t.program = void 0, void 0 !== e && xt.releaseProgram(e)
        }

        function h(t, e) {
            return e[0] - t[0]
        }

        function c(t, e) {
            return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function l(t, e) {
            return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function p(t, e, n, r, i) {
            var o;
            n.transparent ? (r = j, o = ++W) : (r = z, o = ++G), void 0 !== (o = r[o]) ? (o.id = t.id, o.object = t, o.geometry = e, o.material = n, o.z = lt.z, o.group = i) : (o = {
                id: t.id,
                object: t,
                geometry: e,
                material: n,
                z: lt.z,
                group: i
            }, r.push(o))
        }

        function f(t, e, n, r, i) {
            for (var o = 0, a = t.length; o < a; o++) {
                var s = (c = t[o]).object,
                    u = c.geometry,
                    h = void 0 === i ? c.material : i,
                    c = c.group;
                if (s.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, s.matrixWorld), s.normalMatrix.getNormalMatrix(s.modelViewMatrix), s instanceof THREE.ImmediateRenderObject) {
                    d(h);
                    var l = E(e, n, r, h, s);
                    tt = "", s.render(function(t) {
                        Z.renderBufferImmediate(t, l, h)
                    })
                } else Z.renderBufferDirect(e, n, r, u, h, s, c)
            }
        }

        function d(t) {
            t.side !== THREE.DoubleSide ? yt.enable(K.CULL_FACE) : yt.disable(K.CULL_FACE), yt.setFlipSided(t.side === THREE.BackSide), !0 === t.transparent ? yt.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha) : yt.setBlending(THREE.NoBlending), yt.setDepthFunc(t.depthFunc), yt.setDepthTest(t.depthTest), yt.setDepthWrite(t.depthWrite), yt.setColorWrite(t.colorWrite), yt.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
        }

        function E(t, e, n, r, i) {
            nt = 0;
            var o = Tt.get(r);
            if (r.needsUpdate || !o.program) {
                t: {
                    var a = Tt.get(r),
                        h = xt.getParameters(r, e, n, i),
                        c = xt.getProgramCode(r, h),
                        l = a.program,
                        p = !0;
                    if (void 0 === l) r.addEventListener("dispose", s);
                    else if (l.code !== c) u(r);
                    else {
                        if (void 0 !== h.shaderID) break t;
                        p = !1
                    }
                    if (p && (h.shaderID ? (l = THREE.ShaderLib[h.shaderID], a.__webglShader = {
                            name: r.type,
                            uniforms: THREE.UniformsUtils.clone(l.uniforms),
                            vertexShader: l.vertexShader,
                            fragmentShader: l.fragmentShader
                        }) : a.__webglShader = {
                            name: r.type,
                            uniforms: r.uniforms,
                            vertexShader: r.vertexShader,
                            fragmentShader: r.fragmentShader
                        }, r.__webglShader = a.__webglShader, l = xt.acquireProgram(r, h, c), a.program = l, r.program = l), h = l.getAttributes(), r.morphTargets)
                        for (c = r.numSupportedMorphTargets = 0; c < Z.maxMorphTargets; c++) 0 <= h["morphTarget" + c] && r.numSupportedMorphTargets++;
                    if (r.morphNormals)
                        for (c = r.numSupportedMorphNormals = 0; c < Z.maxMorphNormals; c++) 0 <= h["morphNormal" + c] && r.numSupportedMorphNormals++;a.uniformsList = [];
                    var f;h = a.program.getUniforms();
                    for (f in a.__webglShader.uniforms)(c = h[f]) && a.uniformsList.push([a.__webglShader.uniforms[f], c])
                }
                r.needsUpdate = !1
            }
            if (c = l = p = !1, f = (a = o.program).getUniforms(), h = o.__webglShader.uniforms, a.id !== Q && (K.useProgram(a.program), Q = a.id, c = l = p = !0), r.id !== $ && (-1 === $ && (c = !0), $ = r.id, l = !0), (p || t !== et) && (K.uniformMatrix4fv(f.projectionMatrix, !1, t.projectionMatrix.elements), vt.logarithmicDepthBuffer && K.uniform1f(f.logDepthBufFC, 2 / (Math.log(t.far + 1) / Math.LN2)), t !== et && (et = t), (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && void 0 !== f.cameraPosition && (lt.setFromMatrixPosition(t.matrixWorld), K.uniform3f(f.cameraPosition, lt.x, lt.y, lt.z)), (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshBasicMaterial || r instanceof THREE.ShaderMaterial || r.skinning) && void 0 !== f.viewMatrix && K.uniformMatrix4fv(f.viewMatrix, !1, t.matrixWorldInverse.elements)), r.skinning && (i.bindMatrix && void 0 !== f.bindMatrix && K.uniformMatrix4fv(f.bindMatrix, !1, i.bindMatrix.elements), i.bindMatrixInverse && void 0 !== f.bindMatrixInverse && K.uniformMatrix4fv(f.bindMatrixInverse, !1, i.bindMatrixInverse.elements), vt.floatVertexTextures && i.skeleton && i.skeleton.useVertexTexture ? (void 0 !== f.boneTexture && (p = g(), K.uniform1i(f.boneTexture, p), Z.setTexture(i.skeleton.boneTexture, p)), void 0 !== f.boneTextureWidth && K.uniform1i(f.boneTextureWidth, i.skeleton.boneTextureWidth), void 0 !== f.boneTextureHeight && K.uniform1i(f.boneTextureHeight, i.skeleton.boneTextureHeight)) : i.skeleton && i.skeleton.boneMatrices && void 0 !== f.boneGlobalMatrices && K.uniformMatrix4fv(f.boneGlobalMatrices, !1, i.skeleton.boneMatrices)), l) {
                if (n && r.fog && (h.fogColor.value = n.color, n instanceof THREE.Fog ? (h.fogNear.value = n.near, h.fogFar.value = n.far) : n instanceof THREE.FogExp2 && (h.fogDensity.value = n.density)), r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) {
                    if (ft) {
                        c = !0;
                        var d, E, y, T, R = p = 0,
                            H = 0,
                            _ = dt,
                            w = t.matrixWorldInverse,
                            M = _.directional.colors,
                            A = _.directional.positions,
                            C = _.point.colors,
                            L = _.point.positions,
                            k = _.point.distances,
                            P = _.point.decays,
                            D = _.spot.colors,
                            N = _.spot.positions,
                            F = _.spot.distances,
                            O = _.spot.directions,
                            V = _.spot.anglesCos,
                            U = _.spot.exponents,
                            B = _.spot.decays,
                            I = _.hemi.skyColors,
                            z = _.hemi.groundColors,
                            G = _.hemi.positions,
                            j = 0,
                            W = 0,
                            X = 0,
                            q = 0,
                            Y = 0,
                            J = 0,
                            tt = 0,
                            rt = 0,
                            it = d = 0;
                        for (n = T = it = 0, l = e.length; n < l; n++) E = (d = e[n]).color, y = d.intensity, T = d.distance, d instanceof THREE.AmbientLight ? d.visible && (p += E.r, R += E.g, H += E.b) : d instanceof THREE.DirectionalLight ? (Y += 1, d.visible && (pt.setFromMatrixPosition(d.matrixWorld), lt.setFromMatrixPosition(d.target.matrixWorld), pt.sub(lt), pt.transformDirection(w), A[(d = 3 * j) + 0] = pt.x, A[d + 1] = pt.y, A[d + 2] = pt.z, v(M, d, E, y), j += 1)) : d instanceof THREE.PointLight ? (J += 1, d.visible && (v(C, it = 3 * W, E, y), lt.setFromMatrixPosition(d.matrixWorld), lt.applyMatrix4(w), L[it + 0] = lt.x, L[it + 1] = lt.y, L[it + 2] = lt.z, k[W] = T, P[W] = 0 === d.distance ? 0 : d.decay, W += 1)) : d instanceof THREE.SpotLight ? (tt += 1, d.visible && (v(D, it = 3 * X, E, y), pt.setFromMatrixPosition(d.matrixWorld), lt.copy(pt).applyMatrix4(w), N[it + 0] = lt.x, N[it + 1] = lt.y, N[it + 2] = lt.z, F[X] = T, lt.setFromMatrixPosition(d.target.matrixWorld), pt.sub(lt), pt.transformDirection(w), O[it + 0] = pt.x, O[it + 1] = pt.y, O[it + 2] = pt.z, V[X] = Math.cos(d.angle), U[X] = d.exponent, B[X] = 0 === d.distance ? 0 : d.decay, X += 1)) : d instanceof THREE.HemisphereLight && (rt += 1, d.visible && (pt.setFromMatrixPosition(d.matrixWorld), pt.transformDirection(w), G[(T = 3 * q) + 0] = pt.x, G[T + 1] = pt.y, G[T + 2] = pt.z, E = d.color, d = d.groundColor, v(I, T, E, y), v(z, T, d, y), q += 1));
                        for (n = 3 * j, l = Math.max(M.length, 3 * Y); n < l; n++) M[n] = 0;
                        for (n = 3 * W, l = Math.max(C.length, 3 * J); n < l; n++) C[n] = 0;
                        for (n = 3 * X, l = Math.max(D.length, 3 * tt); n < l; n++) D[n] = 0;
                        for (n = 3 * q, l = Math.max(I.length, 3 * rt); n < l; n++) I[n] = 0;
                        for (n = 3 * q, l = Math.max(z.length, 3 * rt); n < l; n++) z[n] = 0;
                        _.directional.length = j, _.point.length = W, _.spot.length = X, _.hemi.length = q, _.ambient[0] = p, _.ambient[1] = R, _.ambient[2] = H, ft = !1
                    }
                    c ? (c = dt, h.ambientLightColor.value = c.ambient, h.directionalLightColor.value = c.directional.colors, h.directionalLightDirection.value = c.directional.positions, h.pointLightColor.value = c.point.colors, h.pointLightPosition.value = c.point.positions, h.pointLightDistance.value = c.point.distances, h.pointLightDecay.value = c.point.decays, h.spotLightColor.value = c.spot.colors, h.spotLightPosition.value = c.spot.positions, h.spotLightDistance.value = c.spot.distances, h.spotLightDirection.value = c.spot.directions, h.spotLightAngleCos.value = c.spot.anglesCos, h.spotLightExponent.value = c.spot.exponents, h.spotLightDecay.value = c.spot.decays, h.hemisphereLightSkyColor.value = c.hemi.skyColors, h.hemisphereLightGroundColor.value = c.hemi.groundColors, h.hemisphereLightDirection.value = c.hemi.positions, m(h, !0)) : m(h, !1)
                }
                var ot;
                if (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) h.opacity.value = r.opacity, h.diffuse.value = r.color, r.emissive && (h.emissive.value = r.emissive), h.map.value = r.map, h.specularMap.value = r.specularMap, h.alphaMap.value = r.alphaMap, r.aoMap && (h.aoMap.value = r.aoMap, h.aoMapIntensity.value = r.aoMapIntensity), r.map ? ot = r.map : r.specularMap ? ot = r.specularMap : r.displacementMap ? ot = r.displacementMap : r.normalMap ? ot = r.normalMap : r.bumpMap ? ot = r.bumpMap : r.alphaMap ? ot = r.alphaMap : r.emissiveMap && (ot = r.emissiveMap), void 0 !== ot && (ot instanceof THREE.WebGLRenderTarget && (ot = ot.texture), c = ot.offset, ot = ot.repeat, h.offsetRepeat.value.set(c.x, c.y, ot.x, ot.y)), h.envMap.value = r.envMap, h.flipEnvMap.value = r.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, h.reflectivity.value = r.reflectivity, h.refractionRatio.value = r.refractionRatio;
                if (r instanceof THREE.LineBasicMaterial ? (h.diffuse.value = r.color, h.opacity.value = r.opacity) : r instanceof THREE.LineDashedMaterial ? (h.diffuse.value = r.color, h.opacity.value = r.opacity, h.dashSize.value = r.dashSize, h.totalSize.value = r.dashSize + r.gapSize, h.scale.value = r.scale) : r instanceof THREE.PointsMaterial ? (h.psColor.value = r.color, h.opacity.value = r.opacity, h.size.value = r.size, h.scale.value = S.height / 2, h.map.value = r.map, null !== r.map && (t = r.map.offset, ot = r.map.repeat, h.offsetRepeat.value.set(t.x, t.y, ot.x, ot.y))) : r instanceof THREE.MeshPhongMaterial ? (h.specular.value = r.specular, h.shininess.value = Math.max(r.shininess, 1e-4), r.lightMap && (h.lightMap.value = r.lightMap, h.lightMapIntensity.value = r.lightMapIntensity), r.emissiveMap && (h.emissiveMap.value = r.emissiveMap), r.bumpMap && (h.bumpMap.value = r.bumpMap, h.bumpScale.value = r.bumpScale), r.normalMap && (h.normalMap.value = r.normalMap, h.normalScale.value.copy(r.normalScale)), r.displacementMap && (h.displacementMap.value = r.displacementMap, h.displacementScale.value = r.displacementScale, h.displacementBias.value = r.displacementBias)) : r instanceof THREE.MeshDepthMaterial ? (h.mNear.value = t.near, h.mFar.value = t.far, h.opacity.value = r.opacity) : r instanceof THREE.MeshNormalMaterial && (h.opacity.value = r.opacity), i.receiveShadow && !r._shadowPass && h.shadowMatrix)
                    for (t = r = 0, ot = e.length; t < ot; t++) !0 === (c = e[t]).castShadow && (c instanceof THREE.PointLight || c instanceof THREE.SpotLight || c instanceof THREE.DirectionalLight) && (n = c.shadow, c instanceof THREE.PointLight ? (lt.setFromMatrixPosition(c.matrixWorld).negate(), n.matrix.identity().setPosition(lt), h.shadowDarkness.value[r] = -n.darkness) : h.shadowDarkness.value[r] = n.darkness, h.shadowMatrix.value[r] = n.matrix, h.shadowMap.value[r] = n.map, h.shadowMapSize.value[r] = n.mapSize, h.shadowBias.value[r] = n.bias, r++);
                for (e = o.uniformsList, o = 0, r = e.length; o < r; o++)
                    if (!1 !== (t = e[o][0]).needsUpdate) switch (h = t.type, n = t.value, ot = e[o][1], h) {
                        case "1i":
                            K.uniform1i(ot, n);
                            break;
                        case "1f":
                            K.uniform1f(ot, n);
                            break;
                        case "2f":
                            K.uniform2f(ot, n[0], n[1]);
                            break;
                        case "3f":
                            K.uniform3f(ot, n[0], n[1], n[2]);
                            break;
                        case "4f":
                            K.uniform4f(ot, n[0], n[1], n[2], n[3]);
                            break;
                        case "1iv":
                            K.uniform1iv(ot, n);
                            break;
                        case "3iv":
                            K.uniform3iv(ot, n);
                            break;
                        case "1fv":
                            K.uniform1fv(ot, n);
                            break;
                        case "2fv":
                            K.uniform2fv(ot, n);
                            break;
                        case "3fv":
                            K.uniform3fv(ot, n);
                            break;
                        case "4fv":
                            K.uniform4fv(ot, n);
                            break;
                        case "Matrix3fv":
                            K.uniformMatrix3fv(ot, !1, n);
                            break;
                        case "Matrix4fv":
                            K.uniformMatrix4fv(ot, !1, n);
                            break;
                        case "i":
                            K.uniform1i(ot, n);
                            break;
                        case "f":
                            K.uniform1f(ot, n);
                            break;
                        case "v2":
                            K.uniform2f(ot, n.x, n.y);
                            break;
                        case "v3":
                            K.uniform3f(ot, n.x, n.y, n.z);
                            break;
                        case "v4":
                            K.uniform4f(ot, n.x, n.y, n.z, n.w);
                            break;
                        case "c":
                            K.uniform3f(ot, n.r, n.g, n.b);
                            break;
                        case "iv1":
                            K.uniform1iv(ot, n);
                            break;
                        case "iv":
                            K.uniform3iv(ot, n);
                            break;
                        case "fv1":
                            K.uniform1fv(ot, n);
                            break;
                        case "fv":
                            K.uniform3fv(ot, n);
                            break;
                        case "v2v":
                            for (void 0 === t._array && (t._array = new Float32Array(2 * n.length)), l = h = 0, c = n.length; h < c; h++, l += 2) t._array[l + 0] = n[h].x, t._array[l + 1] = n[h].y;
                            K.uniform2fv(ot, t._array);
                            break;
                        case "v3v":
                            for (void 0 === t._array && (t._array = new Float32Array(3 * n.length)), l = h = 0, c = n.length; h < c; h++, l += 3) t._array[l + 0] = n[h].x, t._array[l + 1] = n[h].y, t._array[l + 2] = n[h].z;
                            K.uniform3fv(ot, t._array);
                            break;
                        case "v4v":
                            for (void 0 === t._array && (t._array = new Float32Array(4 * n.length)), l = h = 0, c = n.length; h < c; h++, l += 4) t._array[l + 0] = n[h].x, t._array[l + 1] = n[h].y, t._array[l + 2] = n[h].z, t._array[l + 3] = n[h].w;
                            K.uniform4fv(ot, t._array);
                            break;
                        case "m3":
                            K.uniformMatrix3fv(ot, !1, n.elements);
                            break;
                        case "m3v":
                            for (void 0 === t._array && (t._array = new Float32Array(9 * n.length)), h = 0, c = n.length; h < c; h++) n[h].flattenToArrayOffset(t._array, 9 * h);
                            K.uniformMatrix3fv(ot, !1, t._array);
                            break;
                        case "m4":
                            K.uniformMatrix4fv(ot, !1, n.elements);
                            break;
                        case "m4v":
                            for (void 0 === t._array && (t._array = new Float32Array(16 * n.length)), h = 0, c = n.length; h < c; h++) n[h].flattenToArrayOffset(t._array, 16 * h);
                            K.uniformMatrix4fv(ot, !1, t._array);
                            break;
                        case "t":
                            if (l = g(), K.uniform1i(ot, l), !n) continue;
                            n instanceof THREE.CubeTexture || Array.isArray(n.image) && 6 === n.image.length ? x(n, l) : n instanceof THREE.WebGLRenderTargetCube ? b(n.texture, l) : n instanceof THREE.WebGLRenderTarget ? Z.setTexture(n.texture, l) : Z.setTexture(n, l);
                            break;
                        case "tv":
                            for (void 0 === t._array && (t._array = []), h = 0, c = t.value.length; h < c; h++) t._array[h] = g();
                            for (K.uniform1iv(ot, t._array), h = 0, c = t.value.length; h < c; h++) n = t.value[h], l = t._array[h], n && (n instanceof THREE.CubeTexture || n.image instanceof Array && 6 === n.image.length ? x(n, l) : n instanceof THREE.WebGLRenderTarget ? Z.setTexture(n.texture, l) : n instanceof THREE.WebGLRenderTargetCube ? b(n.texture, l) : Z.setTexture(n, l));
                            break;
                        default:
                            console.warn("THREE.WebGLRenderer: Unknown uniform type: " + h)
                    }
            }
            return K.uniformMatrix4fv(f.modelViewMatrix, !1, i.modelViewMatrix.elements), f.normalMatrix && K.uniformMatrix3fv(f.normalMatrix, !1, i.normalMatrix.elements), void 0 !== f.modelMatrix && K.uniformMatrix4fv(f.modelMatrix, !1, i.matrixWorld.elements), a
        }

        function m(t, e) {
            t.ambientLightColor.needsUpdate = e, t.directionalLightColor.needsUpdate = e, t.directionalLightDirection.needsUpdate = e, t.pointLightColor.needsUpdate = e, t.pointLightPosition.needsUpdate = e, t.pointLightDistance.needsUpdate = e, t.pointLightDecay.needsUpdate = e, t.spotLightColor.needsUpdate = e, t.spotLightPosition.needsUpdate = e, t.spotLightDistance.needsUpdate = e, t.spotLightDirection.needsUpdate = e, t.spotLightAngleCos.needsUpdate = e, t.spotLightExponent.needsUpdate = e, t.spotLightDecay.needsUpdate = e, t.hemisphereLightSkyColor.needsUpdate = e, t.hemisphereLightGroundColor.needsUpdate = e, t.hemisphereLightDirection.needsUpdate = e
        }

        function g() {
            var t = nt;
            return t >= vt.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + vt.maxTextures), nt += 1, t
        }

        function v(t, e, n, r) {
            t[e + 0] = n.r * r, t[e + 1] = n.g * r, t[e + 2] = n.b * r
        }

        function y(t, e, n) {
            n ? (K.texParameteri(t, K.TEXTURE_WRAP_S, M(e.wrapS)), K.texParameteri(t, K.TEXTURE_WRAP_T, M(e.wrapT)), K.texParameteri(t, K.TEXTURE_MAG_FILTER, M(e.magFilter)), K.texParameteri(t, K.TEXTURE_MIN_FILTER, M(e.minFilter))) : (K.texParameteri(t, K.TEXTURE_WRAP_S, K.CLAMP_TO_EDGE), K.texParameteri(t, K.TEXTURE_WRAP_T, K.CLAMP_TO_EDGE), e.wrapS === THREE.ClampToEdgeWrapping && e.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", e), K.texParameteri(t, K.TEXTURE_MAG_FILTER, w(e.magFilter)), K.texParameteri(t, K.TEXTURE_MIN_FILTER, w(e.minFilter)), e.minFilter !== THREE.NearestFilter && e.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", e)), !(n = gt.get("EXT_texture_filter_anisotropic")) || e.type === THREE.FloatType && null === gt.get("OES_texture_float_linear") || e.type === THREE.HalfFloatType && null === gt.get("OES_texture_half_float_linear") || !(1 < e.anisotropy || Tt.get(e).__currentAnisotropy) || (K.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, Z.getMaxAnisotropy())), Tt.get(e).__currentAnisotropy = e.anisotropy)
        }

        function T(t, e) {
            if (t.width > e || t.height > e) {
                var n = e / Math.max(t.width, t.height),
                    r = document.createElement("canvas");
                return r.width = Math.floor(t.width * n), r.height = Math.floor(t.height * n), r.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + r.width + "x" + r.height, t), r
            }
            return t
        }

        function R(t) {
            return THREE.Math.isPowerOfTwo(t.width) && THREE.Math.isPowerOfTwo(t.height)
        }

        function x(t, e) {
            var n = Tt.get(t);
            if (6 === t.image.length)
                if (0 < t.version && n.__version !== t.version) {
                    n.__image__webglTextureCube || (t.addEventListener("dispose", o), n.__image__webglTextureCube = K.createTexture(), Et.textures++), yt.activeTexture(K.TEXTURE0 + e), yt.bindTexture(K.TEXTURE_CUBE_MAP, n.__image__webglTextureCube), K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, t.flipY);
                    for (var r = t instanceof THREE.CompressedTexture, i = t.image[0] instanceof THREE.DataTexture, a = [], s = 0; 6 > s; s++) a[s] = !Z.autoScaleCubemaps || r || i ? i ? t.image[s].image : t.image[s] : T(t.image[s], vt.maxCubemapSize);
                    var u = R(a[0]),
                        h = M(t.format),
                        c = M(t.type);
                    for (y(K.TEXTURE_CUBE_MAP, t, u), s = 0; 6 > s; s++)
                        if (r)
                            for (var l, p = a[s].mipmaps, f = 0, d = p.length; f < d; f++) l = p[f], t.format !== THREE.RGBAFormat && t.format !== THREE.RGBFormat ? -1 < yt.getCompressedTextureFormats().indexOf(h) ? yt.compressedTexImage2D(K.TEXTURE_CUBE_MAP_POSITIVE_X + s, f, h, l.width, l.height, 0, l.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : yt.texImage2D(K.TEXTURE_CUBE_MAP_POSITIVE_X + s, f, h, l.width, l.height, 0, h, c, l.data);
                        else i ? yt.texImage2D(K.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, h, a[s].width, a[s].height, 0, h, c, a[s].data) : yt.texImage2D(K.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, h, h, c, a[s]);
                    t.generateMipmaps && u && K.generateMipmap(K.TEXTURE_CUBE_MAP), n.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else yt.activeTexture(K.TEXTURE0 + e), yt.bindTexture(K.TEXTURE_CUBE_MAP, n.__image__webglTextureCube)
        }

        function b(t, e) {
            yt.activeTexture(K.TEXTURE0 + e), yt.bindTexture(K.TEXTURE_CUBE_MAP, Tt.get(t).__webglTexture)
        }

        function H(t, e, n) {
            K.bindFramebuffer(K.FRAMEBUFFER, t), K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, n, Tt.get(e.texture).__webglTexture, 0)
        }

        function _(t, e) {
            K.bindRenderbuffer(K.RENDERBUFFER, t), e.depthBuffer && !e.stencilBuffer ? (K.renderbufferStorage(K.RENDERBUFFER, K.DEPTH_COMPONENT16, e.width, e.height), K.framebufferRenderbuffer(K.FRAMEBUFFER, K.DEPTH_ATTACHMENT, K.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (K.renderbufferStorage(K.RENDERBUFFER, K.DEPTH_STENCIL, e.width, e.height), K.framebufferRenderbuffer(K.FRAMEBUFFER, K.DEPTH_STENCIL_ATTACHMENT, K.RENDERBUFFER, t)) : K.renderbufferStorage(K.RENDERBUFFER, K.RGBA4, e.width, e.height)
        }

        function w(t) {
            return t === THREE.NearestFilter || t === THREE.NearestMipMapNearestFilter || t === THREE.NearestMipMapLinearFilter ? K.NEAREST : K.LINEAR
        }

        function M(t) {
            var e;
            if (t === THREE.RepeatWrapping) return K.REPEAT;
            if (t === THREE.ClampToEdgeWrapping) return K.CLAMP_TO_EDGE;
            if (t === THREE.MirroredRepeatWrapping) return K.MIRRORED_REPEAT;
            if (t === THREE.NearestFilter) return K.NEAREST;
            if (t === THREE.NearestMipMapNearestFilter) return K.NEAREST_MIPMAP_NEAREST;
            if (t === THREE.NearestMipMapLinearFilter) return K.NEAREST_MIPMAP_LINEAR;
            if (t === THREE.LinearFilter) return K.LINEAR;
            if (t === THREE.LinearMipMapNearestFilter) return K.LINEAR_MIPMAP_NEAREST;
            if (t === THREE.LinearMipMapLinearFilter) return K.LINEAR_MIPMAP_LINEAR;
            if (t === THREE.UnsignedByteType) return K.UNSIGNED_BYTE;
            if (t === THREE.UnsignedShort4444Type) return K.UNSIGNED_SHORT_4_4_4_4;
            if (t === THREE.UnsignedShort5551Type) return K.UNSIGNED_SHORT_5_5_5_1;
            if (t === THREE.UnsignedShort565Type) return K.UNSIGNED_SHORT_5_6_5;
            if (t === THREE.ByteType) return K.BYTE;
            if (t === THREE.ShortType) return K.SHORT;
            if (t === THREE.UnsignedShortType) return K.UNSIGNED_SHORT;
            if (t === THREE.IntType) return K.INT;
            if (t === THREE.UnsignedIntType) return K.UNSIGNED_INT;
            if (t === THREE.FloatType) return K.FLOAT;
            if (null !== (e = gt.get("OES_texture_half_float")) && t === THREE.HalfFloatType) return e.HALF_FLOAT_OES;
            if (t === THREE.AlphaFormat) return K.ALPHA;
            if (t === THREE.RGBFormat) return K.RGB;
            if (t === THREE.RGBAFormat) return K.RGBA;
            if (t === THREE.LuminanceFormat) return K.LUMINANCE;
            if (t === THREE.LuminanceAlphaFormat) return K.LUMINANCE_ALPHA;
            if (t === THREE.AddEquation) return K.FUNC_ADD;
            if (t === THREE.SubtractEquation) return K.FUNC_SUBTRACT;
            if (t === THREE.ReverseSubtractEquation) return K.FUNC_REVERSE_SUBTRACT;
            if (t === THREE.ZeroFactor) return K.ZERO;
            if (t === THREE.OneFactor) return K.ONE;
            if (t === THREE.SrcColorFactor) return K.SRC_COLOR;
            if (t === THREE.OneMinusSrcColorFactor) return K.ONE_MINUS_SRC_COLOR;
            if (t === THREE.SrcAlphaFactor) return K.SRC_ALPHA;
            if (t === THREE.OneMinusSrcAlphaFactor) return K.ONE_MINUS_SRC_ALPHA;
            if (t === THREE.DstAlphaFactor) return K.DST_ALPHA;
            if (t === THREE.OneMinusDstAlphaFactor) return K.ONE_MINUS_DST_ALPHA;
            if (t === THREE.DstColorFactor) return K.DST_COLOR;
            if (t === THREE.OneMinusDstColorFactor) return K.ONE_MINUS_DST_COLOR;
            if (t === THREE.SrcAlphaSaturateFactor) return K.SRC_ALPHA_SATURATE;
            if (null !== (e = gt.get("WEBGL_compressed_texture_s3tc"))) {
                if (t === THREE.RGB_S3TC_DXT1_Format) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === THREE.RGBA_S3TC_DXT1_Format) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === THREE.RGBA_S3TC_DXT3_Format) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === THREE.RGBA_S3TC_DXT5_Format) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (null !== (e = gt.get("WEBGL_compressed_texture_pvrtc"))) {
                if (t === THREE.RGB_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (t === THREE.RGB_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (t === THREE.RGBA_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (t === THREE.RGBA_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (null !== (e = gt.get("EXT_blend_minmax"))) {
                if (t === THREE.MinEquation) return e.MIN_EXT;
                if (t === THREE.MaxEquation) return e.MAX_EXT
            }
            return 0
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION);
        var S = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElement("canvas"),
            A = void 0 !== t.context ? t.context : null,
            C = S.width,
            L = S.height,
            k = 1,
            P = void 0 !== t.alpha && t.alpha,
            D = void 0 === t.depth || t.depth,
            N = void 0 === t.stencil || t.stencil,
            F = void 0 !== t.antialias && t.antialias,
            O = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            V = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            U = new THREE.Color(0),
            B = 0,
            I = [],
            z = [],
            G = -1,
            j = [],
            W = -1,
            X = new Float32Array(8),
            q = [],
            Y = [];
        this.domElement = S, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.gammaFactor = 2, this.gammaOutput = this.gammaInput = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0;
        var K, Z = this,
            Q = null,
            J = null,
            $ = -1,
            tt = "",
            et = null,
            nt = 0,
            rt = 0,
            it = 0,
            ot = S.width,
            at = S.height,
            st = 0,
            ut = 0,
            ht = new THREE.Frustum,
            ct = new THREE.Matrix4,
            lt = new THREE.Vector3,
            pt = new THREE.Vector3,
            ft = !0,
            dt = {
                ambient: [0, 0, 0],
                directional: {
                    length: 0,
                    colors: [],
                    positions: []
                },
                point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    decays: []
                },
                spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: [],
                    decays: []
                },
                hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                }
            },
            Et = {
                geometries: 0,
                textures: 0
            },
            mt = {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: mt,
            memory: Et,
            programs: null
        };
        try {
            if (P = {
                    alpha: P,
                    depth: D,
                    stencil: N,
                    antialias: F,
                    premultipliedAlpha: O,
                    preserveDrawingBuffer: V
                }, null === (K = A || S.getContext("webgl", P) || S.getContext("experimental-webgl", P))) {
                if (null !== S.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                throw "Error creating WebGL context."
            }
            S.addEventListener("webglcontextlost", i, !1)
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t)
        }
        var gt = new THREE.WebGLExtensions(K);
        gt.get("OES_texture_float"), gt.get("OES_texture_float_linear"), gt.get("OES_texture_half_float"), gt.get("OES_texture_half_float_linear"), gt.get("OES_standard_derivatives"), gt.get("ANGLE_instanced_arrays"), gt.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
        var vt = new THREE.WebGLCapabilities(K, gt, t),
            yt = new THREE.WebGLState(K, gt, M),
            Tt = new THREE.WebGLProperties,
            Rt = new THREE.WebGLObjects(K, Tt, this.info),
            xt = new THREE.WebGLPrograms(this, vt);
        this.info.programs = xt.programs;
        var bt = new THREE.WebGLBufferRenderer(K, gt, mt),
            Ht = new THREE.WebGLIndexedBufferRenderer(K, gt, mt);
        n(), this.context = K, this.capabilities = vt, this.extensions = gt, this.state = yt;
        var _t = new THREE.WebGLShadowMap(this, I, Rt);
        this.shadowMap = _t;
        var wt = new THREE.SpritePlugin(this, q),
            Mt = new THREE.LensFlarePlugin(this, Y);
        this.getContext = function() {
            return K
        }, this.getContextAttributes = function() {
            return K.getContextAttributes()
        }, this.forceContextLoss = function() {
            gt.get("WEBGL_lose_context").loseContext()
        }, this.getMaxAnisotropy = function() {
            var t;
            return function() {
                if (void 0 !== t) return t;
                var e = gt.get("EXT_texture_filter_anisotropic");
                return t = null !== e ? K.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }
        }(), this.getPrecision = function() {
            return vt.precision
        }, this.getPixelRatio = function() {
            return k
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (k = t)
        }, this.getSize = function() {
            return {
                width: C,
                height: L
            }
        }, this.setSize = function(t, e, n) {
            C = t, L = e, S.width = t * k, S.height = e * k, !1 !== n && (S.style.width = t + "px", S.style.height = e + "px"), this.setViewport(0, 0, t, e)
        }, this.setViewport = function(t, e, n, r) {
            rt = t * k, it = e * k, ot = n * k, at = r * k, K.viewport(rt, it, ot, at)
        }, this.getViewport = function(t) {
            t.x = rt / k, t.y = it / k, t.z = ot / k, t.w = at / k
        }, this.setScissor = function(t, e, n, r) {
            K.scissor(t * k, e * k, n * k, r * k)
        }, this.enableScissorTest = function(t) {
            yt.setScissorTest(t)
        }, this.getClearColor = function() {
            return U
        }, this.setClearColor = function(t, n) {
            U.set(t), B = void 0 !== n ? n : 1, e(U.r, U.g, U.b, B)
        }, this.getClearAlpha = function() {
            return B
        }, this.setClearAlpha = function(t) {
            B = t, e(U.r, U.g, U.b, B)
        }, this.clear = function(t, e, n) {
            var r = 0;
            (void 0 === t || t) && (r |= K.COLOR_BUFFER_BIT), (void 0 === e || e) && (r |= K.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= K.STENCIL_BUFFER_BIT), K.clear(r)
        }, this.clearColor = function() {
            K.clear(K.COLOR_BUFFER_BIT)
        }, this.clearDepth = function() {
            K.clear(K.DEPTH_BUFFER_BIT)
        }, this.clearStencil = function() {
            K.clear(K.STENCIL_BUFFER_BIT)
        }, this.clearTarget = function(t, e, n, r) {
            this.setRenderTarget(t), this.clear(e, n, r)
        }, this.resetGLState = r, this.dispose = function() {
            S.removeEventListener("webglcontextlost", i, !1)
        }, this.renderBufferImmediate = function(t, e, n) {
            yt.initAttributes();
            var r = Tt.get(t);
            if (t.hasPositions && !r.position && (r.position = K.createBuffer()), t.hasNormals && !r.normal && (r.normal = K.createBuffer()), t.hasUvs && !r.uv && (r.uv = K.createBuffer()), t.hasColors && !r.color && (r.color = K.createBuffer()), e = e.getAttributes(), t.hasPositions && (K.bindBuffer(K.ARRAY_BUFFER, r.position), K.bufferData(K.ARRAY_BUFFER, t.positionArray, K.DYNAMIC_DRAW), yt.enableAttribute(e.position), K.vertexAttribPointer(e.position, 3, K.FLOAT, !1, 0, 0)), t.hasNormals) {
                if (K.bindBuffer(K.ARRAY_BUFFER, r.normal), "MeshPhongMaterial" !== n.type && n.shading === THREE.FlatShading)
                    for (var i = 0, o = 3 * t.count; i < o; i += 9) {
                        var a = t.normalArray,
                            s = (a[i + 0] + a[i + 3] + a[i + 6]) / 3,
                            u = (a[i + 1] + a[i + 4] + a[i + 7]) / 3,
                            h = (a[i + 2] + a[i + 5] + a[i + 8]) / 3;
                        a[i + 0] = s, a[i + 1] = u, a[i + 2] = h, a[i + 3] = s, a[i + 4] = u, a[i + 5] = h, a[i + 6] = s, a[i + 7] = u, a[i + 8] = h
                    }
                K.bufferData(K.ARRAY_BUFFER, t.normalArray, K.DYNAMIC_DRAW), yt.enableAttribute(e.normal), K.vertexAttribPointer(e.normal, 3, K.FLOAT, !1, 0, 0)
            }
            t.hasUvs && n.map && (K.bindBuffer(K.ARRAY_BUFFER, r.uv), K.bufferData(K.ARRAY_BUFFER, t.uvArray, K.DYNAMIC_DRAW), yt.enableAttribute(e.uv), K.vertexAttribPointer(e.uv, 2, K.FLOAT, !1, 0, 0)), t.hasColors && n.vertexColors !== THREE.NoColors && (K.bindBuffer(K.ARRAY_BUFFER, r.color), K.bufferData(K.ARRAY_BUFFER, t.colorArray, K.DYNAMIC_DRAW), yt.enableAttribute(e.color), K.vertexAttribPointer(e.color, 3, K.FLOAT, !1, 0, 0)), yt.disableUnusedAttributes(), K.drawArrays(K.TRIANGLES, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, n, r, i, o, a) {
            d(i);
            var s = E(t, e, n, i, o),
                u = !1;
            if ((t = r.id + "_" + s.id + "_" + i.wireframe) !== tt && (tt = t, u = !0), void 0 !== (e = o.morphTargetInfluences)) {
                for (t = [], n = 0, u = e.length; n < u; n++) {
                    var c = e[n];
                    t.push([c, n])
                }
                t.sort(h), 8 < t.length && (t.length = 8);
                var l = r.morphAttributes;
                for (n = 0, u = t.length; n < u; n++) c = t[n], X[n] = c[0], 0 !== c[0] ? (e = c[1], !0 === i.morphTargets && l.position && r.addAttribute("morphTarget" + n, l.position[e]), !0 === i.morphNormals && l.normal && r.addAttribute("morphNormal" + n, l.normal[e])) : (!0 === i.morphTargets && r.removeAttribute("morphTarget" + n), !0 === i.morphNormals && r.removeAttribute("morphNormal" + n));
                null !== (t = s.getUniforms()).morphTargetInfluences && K.uniform1fv(t.morphTargetInfluences, X), u = !0
            }
            if (e = r.index, n = r.attributes.position, !0 === i.wireframe && (e = Rt.getWireframeAttribute(r)), null !== e ? (t = Ht).setIndex(e) : t = bt, u) {
                var p;
                u = void 0;
                if (r instanceof THREE.InstancedBufferGeometry && null === (p = gt.get("ANGLE_instanced_arrays"))) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    void 0 === u && (u = 0), yt.initAttributes();
                    var f;
                    c = r.attributes, s = s.getAttributes(), l = i.defaultAttributeValues;
                    for (f in s) {
                        var m = s[f];
                        if (0 <= m)
                            if (void 0 !== (R = c[f])) {
                                var g = R.itemSize,
                                    v = Rt.getAttributeBuffer(R);
                                if (R instanceof THREE.InterleavedBufferAttribute) {
                                    var y = R.data,
                                        T = y.stride,
                                        R = R.offset;
                                    y instanceof THREE.InstancedInterleavedBuffer ? (yt.enableAttributeAndDivisor(m, y.meshPerAttribute, p), void 0 === r.maxInstancedCount && (r.maxInstancedCount = y.meshPerAttribute * y.count)) : yt.enableAttribute(m), K.bindBuffer(K.ARRAY_BUFFER, v), K.vertexAttribPointer(m, g, K.FLOAT, !1, T * y.array.BYTES_PER_ELEMENT, (u * T + R) * y.array.BYTES_PER_ELEMENT)
                                } else R instanceof THREE.InstancedBufferAttribute ? (yt.enableAttributeAndDivisor(m, R.meshPerAttribute, p), void 0 === r.maxInstancedCount && (r.maxInstancedCount = R.meshPerAttribute * R.count)) : yt.enableAttribute(m), K.bindBuffer(K.ARRAY_BUFFER, v), K.vertexAttribPointer(m, g, K.FLOAT, !1, 0, u * g * 4)
                            } else if (void 0 !== l && void 0 !== (g = l[f])) switch (g.length) {
                            case 2:
                                K.vertexAttrib2fv(m, g);
                                break;
                            case 3:
                                K.vertexAttrib3fv(m, g);
                                break;
                            case 4:
                                K.vertexAttrib4fv(m, g);
                                break;
                            default:
                                K.vertexAttrib1fv(m, g)
                        }
                    }
                    yt.disableUnusedAttributes()
                }
                null !== e && K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, Rt.getAttributeBuffer(e))
            }
            p = 1 / 0, null !== e ? p = e.count : void 0 !== n && (p = n.count), f = r.drawRange.start, e = r.drawRange.count, n = null !== a ? a.start : 0, u = null !== a ? a.count : 1 / 0, a = Math.max(0, f, n), p = Math.min(0 + p, f + e, n + u) - 1, p = Math.max(0, p - a + 1), o instanceof THREE.Mesh ? (!0 === i.wireframe ? (yt.setLineWidth(i.wireframeLinewidth * k), t.setMode(K.LINES)) : t.setMode(K.TRIANGLES), r instanceof THREE.InstancedBufferGeometry && 0 < r.maxInstancedCount ? t.renderInstances(r) : t.render(a, p)) : o instanceof THREE.Line ? (void 0 === (r = i.linewidth) && (r = 1), yt.setLineWidth(r * k), o instanceof THREE.LineSegments ? t.setMode(K.LINES) : t.setMode(K.LINE_STRIP), t.render(a, p)) : o instanceof THREE.Points && (t.setMode(K.POINTS), t.render(a, p))
        }, this.render = function(t, e, n, r) {
            if (!1 == e instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            else {
                var i = t.fog;
                tt = "", $ = -1, et = null, ft = !0, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), e.matrixWorldInverse.getInverse(e.matrixWorld), ct.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), ht.setFromMatrix(ct), I.length = 0, W = G = -1, q.length = 0, Y.length = 0,
                    function t(e, n) {
                        if (!1 !== e.visible) {
                            if (0 != (e.channels.mask & n.channels.mask))
                                if (e instanceof THREE.Light) I.push(e);
                                else if (e instanceof THREE.Sprite) q.push(e);
                            else if (e instanceof THREE.LensFlare) Y.push(e);
                            else if (e instanceof THREE.ImmediateRenderObject) !0 === Z.sortObjects && (lt.setFromMatrixPosition(e.matrixWorld), lt.applyProjection(ct)), p(e, null, e.material, lt.z, null);
                            else if ((e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Points) && (e instanceof THREE.SkinnedMesh && e.skeleton.update(), !1 === e.frustumCulled || !0 === ht.intersectsObject(e)) && !0 === (a = e.material).visible) {
                                !0 === Z.sortObjects && (lt.setFromMatrixPosition(e.matrixWorld), lt.applyProjection(ct));
                                var r = Rt.update(e);
                                if (a instanceof THREE.MeshFaceMaterial)
                                    for (var i = r.groups, o = a.materials, a = 0, s = i.length; a < s; a++) {
                                        var u = i[a],
                                            h = o[u.materialIndex];
                                        !0 === h.visible && p(e, r, h, lt.z, u)
                                    } else p(e, r, a, lt.z, null)
                            }
                            for (a = 0, s = (r = e.children).length; a < s; a++) t(r[a], n)
                        }
                    }(t, e), z.length = G + 1, j.length = W + 1, !0 === Z.sortObjects && (z.sort(c), j.sort(l)), _t.render(t), mt.calls = 0, mt.vertices = 0, mt.faces = 0, mt.points = 0, this.setRenderTarget(n), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), t.overrideMaterial ? (r = t.overrideMaterial, f(z, e, I, i, r), f(j, e, I, i, r)) : (yt.setBlending(THREE.NoBlending), f(z, e, I, i), f(j, e, I, i)), wt.render(t, e), Mt.render(t, e, st, ut), n && (t = n.texture, e = R(n), t.generateMipmaps && e && t.minFilter !== THREE.NearestFilter && t.minFilter !== THREE.LinearFilter && (t = n instanceof THREE.WebGLRenderTargetCube ? K.TEXTURE_CUBE_MAP : K.TEXTURE_2D, n = Tt.get(n.texture).__webglTexture, yt.bindTexture(t, n), K.generateMipmap(t), yt.bindTexture(t, null))), yt.setDepthTest(!0), yt.setDepthWrite(!0), yt.setColorWrite(!0)
            }
        }, this.setFaceCulling = function(t, e) {
            t === THREE.CullFaceNone ? yt.disable(K.CULL_FACE) : (e === THREE.FrontFaceDirectionCW ? K.frontFace(K.CW) : K.frontFace(K.CCW), t === THREE.CullFaceBack ? K.cullFace(K.BACK) : t === THREE.CullFaceFront ? K.cullFace(K.FRONT) : K.cullFace(K.FRONT_AND_BACK), yt.enable(K.CULL_FACE))
        }, this.setTexture = function(t, e) {
            var n = Tt.get(t);
            if (0 < t.version && n.__version !== t.version)
                if (void 0 === (i = t.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                else if (!1 === i.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t);
            else {
                if (void 0 === n.__webglInit && (n.__webglInit = !0, t.addEventListener("dispose", o), n.__webglTexture = K.createTexture(), Et.textures++), yt.activeTexture(K.TEXTURE0 + e), yt.bindTexture(K.TEXTURE_2D, n.__webglTexture), K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, t.flipY), K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), K.pixelStorei(K.UNPACK_ALIGNMENT, t.unpackAlignment), t.image = T(t.image, vt.maxTextureSize), (t.wrapS !== THREE.ClampToEdgeWrapping || t.wrapT !== THREE.ClampToEdgeWrapping || t.minFilter !== THREE.NearestFilter && t.minFilter !== THREE.LinearFilter) && !1 === R(t.image)) {
                    if ((i = t.image) instanceof HTMLImageElement || i instanceof HTMLCanvasElement)(a = document.createElement("canvas")).width = THREE.Math.nearestPowerOfTwo(i.width), a.height = THREE.Math.nearestPowerOfTwo(i.height), a.getContext("2d").drawImage(i, 0, 0, a.width, a.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + i.width + "x" + i.height + "). Resized to " + a.width + "x" + a.height, i), i = a;
                    t.image = i
                }
                var r = t.image,
                    i = R(r),
                    a = M(t.format),
                    s = M(t.type);
                y(K.TEXTURE_2D, t, i);
                var u = t.mipmaps;
                if (t instanceof THREE.DataTexture)
                    if (0 < u.length && i) {
                        for (var h = 0, c = u.length; h < c; h++) r = u[h], yt.texImage2D(K.TEXTURE_2D, h, a, r.width, r.height, 0, a, s, r.data);
                        t.generateMipmaps = !1
                    } else yt.texImage2D(K.TEXTURE_2D, 0, a, r.width, r.height, 0, a, s, r.data);
                else if (t instanceof THREE.CompressedTexture)
                    for (h = 0, c = u.length; h < c; h++) r = u[h], t.format !== THREE.RGBAFormat && t.format !== THREE.RGBFormat ? -1 < yt.getCompressedTextureFormats().indexOf(a) ? yt.compressedTexImage2D(K.TEXTURE_2D, h, a, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt.texImage2D(K.TEXTURE_2D, h, a, r.width, r.height, 0, a, s, r.data);
                else if (0 < u.length && i) {
                    for (h = 0, c = u.length; h < c; h++) r = u[h], yt.texImage2D(K.TEXTURE_2D, h, a, a, s, r);
                    t.generateMipmaps = !1
                } else yt.texImage2D(K.TEXTURE_2D, 0, a, a, s, t.image);
                t.generateMipmaps && i && K.generateMipmap(K.TEXTURE_2D), n.__version = t.version, t.onUpdate && t.onUpdate(t)
            } else yt.activeTexture(K.TEXTURE0 + e), yt.bindTexture(K.TEXTURE_2D, n.__webglTexture)
        }, this.setRenderTarget = function(t) {
            var e = t instanceof THREE.WebGLRenderTargetCube;
            if (t && void 0 === Tt.get(t).__webglFramebuffer) {
                var n = Tt.get(t),
                    r = Tt.get(t.texture);
                void 0 === t.depthBuffer && (t.depthBuffer = !0), void 0 === t.stencilBuffer && (t.stencilBuffer = !0), t.addEventListener("dispose", a), r.__webglTexture = K.createTexture(), Et.textures++;
                var i = R(t),
                    o = M(t.texture.format),
                    s = M(t.texture.type);
                if (e) {
                    for (n.__webglFramebuffer = [], n.__webglRenderbuffer = [], yt.bindTexture(K.TEXTURE_CUBE_MAP, r.__webglTexture), y(K.TEXTURE_CUBE_MAP, t.texture, i), r = 0; 6 > r; r++) n.__webglFramebuffer[r] = K.createFramebuffer(), n.__webglRenderbuffer[r] = K.createRenderbuffer(), yt.texImage2D(K.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, o, t.width, t.height, 0, o, s, null), H(n.__webglFramebuffer[r], t, K.TEXTURE_CUBE_MAP_POSITIVE_X + r), _(n.__webglRenderbuffer[r], t);
                    t.texture.generateMipmaps && i && K.generateMipmap(K.TEXTURE_CUBE_MAP)
                } else n.__webglFramebuffer = K.createFramebuffer(), n.__webglRenderbuffer = t.shareDepthFrom ? t.shareDepthFrom.__webglRenderbuffer : K.createRenderbuffer(), yt.bindTexture(K.TEXTURE_2D, r.__webglTexture), y(K.TEXTURE_2D, t.texture, i), yt.texImage2D(K.TEXTURE_2D, 0, o, t.width, t.height, 0, o, s, null), H(n.__webglFramebuffer, t, K.TEXTURE_2D), t.shareDepthFrom ? t.depthBuffer && !t.stencilBuffer ? K.framebufferRenderbuffer(K.FRAMEBUFFER, K.DEPTH_ATTACHMENT, K.RENDERBUFFER, n.__webglRenderbuffer) : t.depthBuffer && t.stencilBuffer && K.framebufferRenderbuffer(K.FRAMEBUFFER, K.DEPTH_STENCIL_ATTACHMENT, K.RENDERBUFFER, n.__webglRenderbuffer) : _(n.__webglRenderbuffer, t), t.texture.generateMipmaps && i && K.generateMipmap(K.TEXTURE_2D);
                e ? yt.bindTexture(K.TEXTURE_CUBE_MAP, null) : yt.bindTexture(K.TEXTURE_2D, null), K.bindRenderbuffer(K.RENDERBUFFER, null), K.bindFramebuffer(K.FRAMEBUFFER, null)
            }
            t ? (n = Tt.get(t), r = e ? n.__webglFramebuffer[t.activeCubeFace] : n.__webglFramebuffer, n = t.width, i = t.height, s = o = 0) : (r = null, n = ot, i = at, o = rt, s = it), r !== J && (K.bindFramebuffer(K.FRAMEBUFFER, r), K.viewport(o, s, n, i), J = r), e && (r = Tt.get(t.texture), K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, 0)), st = n, ut = i
        }, this.readRenderTargetPixels = function(t, e, n, r, i, o) {
            if (!1 == t instanceof THREE.WebGLRenderTarget) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            else {
                var a = Tt.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== J && (K.bindFramebuffer(K.FRAMEBUFFER, a), s = !0);
                    try {
                        var u = t.texture;
                        u.format !== THREE.RGBAFormat && M(u.format) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : u.type === THREE.UnsignedByteType || M(u.type) === K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) || u.type === THREE.FloatType && gt.get("WEBGL_color_buffer_float") || u.type === THREE.HalfFloatType && gt.get("EXT_color_buffer_half_float") ? K.checkFramebufferStatus(K.FRAMEBUFFER) === K.FRAMEBUFFER_COMPLETE ? K.readPixels(e, n, r, i, M(u.format), M(u.type), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && K.bindFramebuffer(K.FRAMEBUFFER, J)
                    }
                }
            }
        }, this.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), gt.get("OES_texture_float")
        }, this.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), gt.get("OES_texture_half_float")
        }, this.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), gt.get("OES_standard_derivatives")
        }, this.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), gt.get("WEBGL_compressed_texture_s3tc")
        }, this.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), gt.get("WEBGL_compressed_texture_pvrtc")
        }, this.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), gt.get("EXT_blend_minmax")
        }, this.supportsVertexTextures = function() {
            return vt.vertexTextures
        }, this.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), gt.get("ANGLE_instanced_arrays")
        }, this.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, this.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, this.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, this.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, Object.defineProperties(this, {
            shadowMapEnabled: {
                get: function() {
                    return _t.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), _t.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return _t.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), _t.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    return _t.cullFace
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), _t.cullFace = t
                }
            },
            shadowMapDebug: {
                get: function() {
                    return _t.debug
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug."), _t.debug = t
                }
            }
        })
    }, THREE.WebGLRenderTarget = function(t, e, n) {
        this.uuid = THREE.Math.generateUUID(), this.width = t, this.height = e, void 0 === (n = n || {}).minFilter && (n.minFilter = THREE.LinearFilter), this.texture = new THREE.Texture(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.shareDepthFrom = void 0 !== n.shareDepthFrom ? n.shareDepthFrom : null
    }, THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        get wrapS() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
        },
        set wrapS(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
        },
        get wrapT() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
        },
        set wrapT(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
        },
        get magFilter() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
        },
        set magFilter(t) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
        },
        get minFilter() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
        },
        set minFilter(t) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
        },
        get anisotropy() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
        },
        set anisotropy(t) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
        },
        get offset() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
        },
        set offset(t) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
        },
        get repeat() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
        },
        set repeat(t) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
        },
        get format() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
        },
        set format(t) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
        },
        get type() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
        },
        set type(t) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
        },
        get generateMipmaps() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
        },
        set generateMipmaps(t) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
        },
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose())
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width, this.height = t.height, this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.shareDepthFrom = t.shareDepthFrom, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(t, e, n) {
        THREE.WebGLRenderTarget.call(this, t, e, n), this.activeCubeFace = 0
    }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, THREE.WebGLBufferRenderer = function(t, e, n) {
        var r;
        this.setMode = function(t) {
            r = t
        }, this.render = function(e, i) {
            t.drawArrays(r, e, i), n.calls++, n.vertices += i, r === t.TRIANGLES && (n.faces += i / 3)
        }, this.renderInstances = function(t) {
            var n = e.get("ANGLE_instanced_arrays");
            if (null === n) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            else {
                var i = t.attributes.position;
                i instanceof THREE.InterleavedBufferAttribute ? n.drawArraysInstancedANGLE(r, 0, i.data.count, t.maxInstancedCount) : n.drawArraysInstancedANGLE(r, 0, i.count, t.maxInstancedCount)
            }
        }
    }, THREE.WebGLIndexedBufferRenderer = function(t, e, n) {
        var r, i, o;
        this.setMode = function(t) {
            r = t
        }, this.setIndex = function(n) {
            n.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (i = t.UNSIGNED_INT, o = 4) : (i = t.UNSIGNED_SHORT, o = 2)
        }, this.render = function(e, a) {
            t.drawElements(r, a, i, e * o), n.calls++, n.vertices += a, r === t.TRIANGLES && (n.faces += a / 3)
        }, this.renderInstances = function(t) {
            var n = e.get("ANGLE_instanced_arrays");
            null === n ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : n.drawElementsInstancedANGLE(r, t.index.array.length, i, 0, t.maxInstancedCount)
        }
    }, THREE.WebGLExtensions = function(t) {
        var e = {};
        this.get = function(n) {
            if (void 0 !== e[n]) return e[n];
            var r;
            switch (n) {
                case "EXT_texture_filter_anisotropic":
                    r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    r = t.getExtension(n)
            }
            return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = r
        }
    }, THREE.WebGLCapabilities = function(t, e, n) {
        function r(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision) return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }
        this.getMaxPrecision = r, this.precision = void 0 !== n.precision ? n.precision : "highp", this.logarithmicDepthBuffer = void 0 !== n.logarithmicDepthBuffer && n.logarithmicDepthBuffer, this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxCubemapSize = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), this.maxAttributes = t.getParameter(t.MAX_VERTEX_ATTRIBS), this.maxVertexUniforms = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), this.maxVaryings = t.getParameter(t.MAX_VARYING_VECTORS), this.maxFragmentUniforms = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), this.vertexTextures = 0 < this.maxVertexTextures, this.floatFragmentTextures = !!e.get("OES_texture_float"), this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures, (n = r(this.precision)) !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", n, "instead."), this.precision = n), this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!e.get("EXT_frag_depth"))
    }, THREE.WebGLGeometries = function(t, e, n) {
        function r(t) {
            t = t.target;
            var a, s = o[t.id].attributes;
            for (a in s) i(s[a]);
            t.removeEventListener("dispose", r), delete o[t.id], (a = e.get(t)).wireframe && i(a.wireframe), n.memory.geometries--
        }

        function i(n) {
            var r;
            void 0 !== (r = n instanceof THREE.InterleavedBufferAttribute ? e.get(n.data).__webglBuffer : e.get(n).__webglBuffer) && (t.deleteBuffer(r), n instanceof THREE.InterleavedBufferAttribute ? e.delete(n.data) : e.delete(n))
        }
        var o = {};
        this.get = function(t) {
            var e, i = t.geometry;
            return void 0 !== o[i.id] ? o[i.id] : (i.addEventListener("dispose", r), i instanceof THREE.BufferGeometry ? e = i : i instanceof THREE.Geometry && (void 0 === i._bufferGeometry && (i._bufferGeometry = (new THREE.BufferGeometry).setFromObject(t)), e = i._bufferGeometry), o[i.id] = e, n.memory.geometries++, e)
        }
    }, THREE.WebGLObjects = function(t, e, n) {
        function r(n, r) {
            var i = n instanceof THREE.InterleavedBufferAttribute ? n.data : n,
                o = e.get(i);
            void 0 === o.__webglBuffer ? (o.__webglBuffer = t.createBuffer(), t.bindBuffer(r, o.__webglBuffer), t.bufferData(r, i.array, i.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW), o.version = i.version) : o.version !== i.version && (t.bindBuffer(r, o.__webglBuffer), !1 === i.dynamic || -1 === i.updateRange.count ? t.bufferSubData(r, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)), i.updateRange.count = 0), o.version = i.version)
        }

        function i(t, e, n) {
            if (e > n) {
                var r = e;
                e = n, n = r
            }
            return void 0 === (r = t[e]) ? (t[e] = [n], !0) : -1 === r.indexOf(n) && (r.push(n), !0)
        }
        var o = new THREE.WebGLGeometries(t, e, n);
        this.getAttributeBuffer = function(t) {
            return t instanceof THREE.InterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
        }, this.getWireframeAttribute = function(n) {
            var o = e.get(n);
            if (void 0 !== o.wireframe) return o.wireframe;
            var a = [],
                s = n.index;
            if (n = (u = n.attributes).position, null !== s)
                for (var u = {}, h = 0, c = (s = s.array).length; h < c; h += 3) {
                    var l = s[h + 0],
                        p = s[h + 1],
                        f = s[h + 2];
                    i(u, l, p) && a.push(l, p), i(u, p, f) && a.push(p, f), i(u, f, l) && a.push(f, l)
                } else
                    for (h = 0, c = (s = u.position.array).length / 3 - 1; h < c; h += 3) l = h + 0, p = h + 1, f = h + 2, a.push(l, p, p, f, f, l);
            return r(a = new THREE.BufferAttribute(new(65535 < n.count ? Uint32Array : Uint16Array)(a), 1), t.ELEMENT_ARRAY_BUFFER), o.wireframe = a
        }, this.update = function(e) {
            var n = o.get(e);
            e.geometry instanceof THREE.Geometry && n.updateFromObject(e), e = n.index;
            var i = n.attributes;
            for (var a in null !== e && r(e, t.ELEMENT_ARRAY_BUFFER), i) r(i[a], t.ARRAY_BUFFER);
            for (a in e = n.morphAttributes)
                for (var s = 0, u = (i = e[a]).length; s < u; s++) r(i[s], t.ARRAY_BUFFER);
            return n
        }
    }, THREE.WebGLProgram = function() {
        function t(t) {
            return "" !== t
        }
        var e = 0;
        return function(n, r, i, o) {
            var a = n.context,
                s = i.defines,
                u = i.__webglShader.vertexShader,
                h = i.__webglShader.fragmentShader,
                c = "SHADOWMAP_TYPE_BASIC";
            o.shadowMapType === THREE.PCFShadowMap ? c = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === THREE.PCFSoftShadowMap && (c = "SHADOWMAP_TYPE_PCF_SOFT");
            var l = "ENVMAP_TYPE_CUBE",
                p = "ENVMAP_MODE_REFLECTION",
                f = "ENVMAP_BLENDING_MULTIPLY";
            if (o.envMap) {
                switch (i.envMap.mapping) {
                    case THREE.CubeReflectionMapping:
                    case THREE.CubeRefractionMapping:
                        l = "ENVMAP_TYPE_CUBE";
                        break;
                    case THREE.EquirectangularReflectionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        l = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case THREE.SphericalReflectionMapping:
                        l = "ENVMAP_TYPE_SPHERE"
                }
                switch (i.envMap.mapping) {
                    case THREE.CubeRefractionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        p = "ENVMAP_MODE_REFRACTION"
                }
                switch (i.combine) {
                    case THREE.MultiplyOperation:
                        f = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case THREE.MixOperation:
                        f = "ENVMAP_BLENDING_MIX";
                        break;
                    case THREE.AddOperation:
                        f = "ENVMAP_BLENDING_ADD"
                }
            }
            var d, E, m = 0 < n.gammaFactor ? n.gammaFactor : 1,
                g = function(t) {
                    var e, n = [];
                    for (e in t) {
                        var r = t[e];
                        !1 !== r && n.push("#define " + e + " " + r)
                    }
                    return n.join("\n")
                }(s),
                v = a.createProgram();
            return i instanceof THREE.RawShaderMaterial ? n = s = "" : (s = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, g, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.gammaInput ? "#define GAMMA_INPUT" : "", n.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + m, "#define MAX_DIR_LIGHTS " + o.maxDirLights, "#define MAX_POINT_LIGHTS " + o.maxPointLights, "#define MAX_SPOT_LIGHTS " + o.maxSpotLights, "#define MAX_HEMI_LIGHTS " + o.maxHemiLights, "#define MAX_SHADOWS " + o.maxShadows, "#define MAX_BONES " + o.maxBones, o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", 0 < o.pointLightShadows ? "#define POINT_LIGHT_SHADOWS" : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && n.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(t).join("\n"), n = [o.bumpMap || o.normalMap || o.flatShading || i.derivatives ? "#extension GL_OES_standard_derivatives : enable" : "", o.logarithmicDepthBuffer && n.extensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, g, "#define MAX_DIR_LIGHTS " + o.maxDirLights, "#define MAX_POINT_LIGHTS " + o.maxPointLights, "#define MAX_SPOT_LIGHTS " + o.maxSpotLights, "#define MAX_HEMI_LIGHTS " + o.maxHemiLights, "#define MAX_SHADOWS " + o.maxShadows, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", n.gammaInput ? "#define GAMMA_INPUT" : "", n.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + m, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + l : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.metal ? "#define METAL" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", 0 < o.pointLightShadows ? "#define POINT_LIGHT_SHADOWS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && n.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "\n"].filter(t).join("\n")), h = n + h, u = THREE.WebGLShader(a, a.VERTEX_SHADER, s + u), h = THREE.WebGLShader(a, a.FRAGMENT_SHADER, h), a.attachShader(v, u), a.attachShader(v, h), void 0 !== i.index0AttributeName ? a.bindAttribLocation(v, 0, i.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(v, 0, "position"), a.linkProgram(v), o = a.getProgramInfoLog(v), c = a.getShaderInfoLog(u), l = a.getShaderInfoLog(h), f = p = !0, !1 === a.getProgramParameter(v, a.LINK_STATUS) ? (p = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(v, a.VALIDATE_STATUS), "gl.getProgramInfoLog", o, c, l)) : "" !== o ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", o) : "" !== c && "" !== l || (f = !1), f && (this.diagnostics = {
                runnable: p,
                material: i,
                programLog: o,
                vertexShader: {
                    log: c,
                    prefix: s
                },
                fragmentShader: {
                    log: l,
                    prefix: n
                }
            }), a.deleteShader(u), a.deleteShader(h), this.getUniforms = function() {
                if (void 0 === d) {
                    for (var t = {}, e = a.getProgramParameter(v, a.ACTIVE_UNIFORMS), n = 0; n < e; n++) {
                        var r = a.getActiveUniform(v, n).name,
                            i = a.getUniformLocation(v, r),
                            o = r.lastIndexOf("[0]"); - 1 !== o && o === r.length - 3 && (t[r.substr(0, o)] = i), t[r] = i
                    }
                    d = t
                }
                return d
            }, this.getAttributes = function() {
                if (void 0 === E) {
                    for (var t = {}, e = a.getProgramParameter(v, a.ACTIVE_ATTRIBUTES), n = 0; n < e; n++) {
                        var r = a.getActiveAttrib(v, n).name;
                        t[r] = a.getAttribLocation(v, r)
                    }
                    E = t
                }
                return E
            }, this.destroy = function() {
                a.deleteProgram(v), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = e++, this.code = r, this.usedTimes = 1, this.program = v, this.vertexShader = u, this.fragmentShader = h, this
        }
    }(), THREE.WebGLPrograms = function(t, e) {
        var n = [],
            r = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            },
            i = "precision supportsVertexTextures map envMap envMapMode lightMap aoMap emissiveMap bumpMap normalMap displacementMap specularMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals maxDirLights maxPointLights maxSpotLights maxHemiLights maxShadows shadowMapEnabled pointLightShadows shadowMapType shadowMapDebug alphaTest metal doubleSided flipSided".split(" ");
        this.getParameters = function(n, i, o, a) {
            var s, u, h, c, l, p = r[n.type];
            s = l = c = h = u = 0;
            for (var f = i.length; s < f; s++) {
                !1 !== (d = i[s]).visible && (d instanceof THREE.DirectionalLight && u++, d instanceof THREE.PointLight && h++, d instanceof THREE.SpotLight && c++, d instanceof THREE.HemisphereLight && l++)
            }
            for (var d = s = f = 0, E = i.length; d < E; d++) {
                var m = i[d];
                m.castShadow && ((m instanceof THREE.SpotLight || m instanceof THREE.DirectionalLight) && f++, m instanceof THREE.PointLight && (f++, s++))
            }
            return i = f, e.floatVertexTextures && a && a.skeleton && a.skeleton.useVertexTexture ? f = 1024 : (f = Math.floor((e.maxVertexUniforms - 20) / 4), void 0 !== a && a instanceof THREE.SkinnedMesh && ((f = Math.min(a.skeleton.bones.length, f)) < a.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + a.skeleton.bones.length + ", this GPU supports just " + f + " (try OpenGL instead of ANGLE)"))), d = t.getPrecision(), null !== n.precision && ((d = e.getMaxPrecision(n.precision)) !== n.precision && console.warn("THREE.WebGLRenderer.initMaterial:", n.precision, "not supported, using", d, "instead.")), {
                shaderID: p,
                precision: d,
                supportsVertexTextures: e.vertexTextures,
                map: !!n.map,
                envMap: !!n.envMap,
                envMapMode: n.envMap && n.envMap.mapping,
                lightMap: !!n.lightMap,
                aoMap: !!n.aoMap,
                emissiveMap: !!n.emissiveMap,
                bumpMap: !!n.bumpMap,
                normalMap: !!n.normalMap,
                displacementMap: !!n.displacementMap,
                specularMap: !!n.specularMap,
                alphaMap: !!n.alphaMap,
                combine: n.combine,
                vertexColors: n.vertexColors,
                fog: o,
                useFog: n.fog,
                fogExp: o instanceof THREE.FogExp2,
                flatShading: n.shading === THREE.FlatShading,
                sizeAttenuation: n.sizeAttenuation,
                logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                skinning: n.skinning,
                maxBones: f,
                useVertexTexture: e.floatVertexTextures && a && a.skeleton && a.skeleton.useVertexTexture,
                morphTargets: n.morphTargets,
                morphNormals: n.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                maxDirLights: u,
                maxPointLights: h,
                maxSpotLights: c,
                maxHemiLights: l,
                maxShadows: i,
                pointLightShadows: s,
                shadowMapEnabled: t.shadowMap.enabled && a.receiveShadow && 0 < i,
                shadowMapType: t.shadowMap.type,
                shadowMapDebug: t.shadowMap.debug,
                alphaTest: n.alphaTest,
                metal: n.metal,
                doubleSided: n.side === THREE.DoubleSide,
                flipSided: n.side === THREE.BackSide
            }
        }, this.getProgramCode = function(t, e) {
            var n = [];
            if (e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            for (r = 0; r < i.length; r++) {
                var o = i[r];
                n.push(o), n.push(e[o])
            }
            return n.join()
        }, this.acquireProgram = function(e, r, i) {
            for (var o, a = 0, s = n.length; a < s; a++) {
                var u = n[a];
                if (u.code === i) {
                    ++(o = u).usedTimes;
                    break
                }
            }
            return void 0 === o && (o = new THREE.WebGLProgram(t, i, e, r), n.push(o)), o
        }, this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = n.indexOf(t);
                n[e] = n[n.length - 1], n.pop(), t.destroy()
            }
        }, this.programs = n
    }, THREE.WebGLProperties = function() {
        var t = {};
        this.get = function(e) {
            e = e.uuid;
            var n = t[e];
            return void 0 === n && (n = {}, t[e] = n), n
        }, this.delete = function(e) {
            delete t[e.uuid]
        }, this.clear = function() {
            t = {}
        }
    }, THREE.WebGLShader = function() {
        return function(t, e, n) {
            var r = t.createShader(e);
            return t.shaderSource(r, n), t.compileShader(r), !1 === t.getShaderParameter(r, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(r), function(t) {
                t = t.split("\n");
                for (var e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                return t.join("\n")
            }(n)), r
        }
    }(), THREE.WebGLShadowMap = function(t, e, n) {
        function r(t, e, n, r) {
            var i = t.geometry,
                o = null,
                a = (o = p, t.customDepthMaterial);
            return n && (o = f, a = t.customDistanceMaterial), a ? o = a : (t = t instanceof THREE.SkinnedMesh && e.skinning, a = 0, void 0 !== i.morphTargets && 0 < i.morphTargets.length && e.morphTargets && (a |= 1), t && (a |= 2), o = o[a]), o.visible = e.visible, o.wireframe = e.wireframe, o.wireframeLinewidth = e.wireframeLinewidth, n && void 0 !== o.uniforms.lightPos && o.uniforms.lightPos.value.copy(r), o
        }

        function i(t, e) {
            if (!1 !== t.visible) {
                (t instanceof THREE.Mesh || t instanceof THREE.Line || t instanceof THREE.Points) && t.castShadow && (!1 === t.frustumCulled || !0 === s.intersectsObject(t)) && !0 === t.material.visible && (t.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, t.matrixWorld), l.push(t));
                for (var n = t.children, r = 0, o = n.length; r < o; r++) i(n[r], e)
            }
        }
        var o = t.context,
            a = t.state,
            s = new THREE.Frustum,
            u = new THREE.Matrix4;
        new THREE.Vector3, new THREE.Vector3;
        for (var h = new THREE.Vector3, c = new THREE.Vector3, l = [], p = Array(4), f = Array(4), d = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)], E = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)], m = [new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4], g = new THREE.Vector4, v = THREE.ShaderLib.depthRGBA, y = THREE.UniformsUtils.clone(v.uniforms), T = THREE.ShaderLib.distanceRGBA, R = THREE.UniformsUtils.clone(T.uniforms), x = 0; 4 !== x; ++x) {
            var b = 0 != (1 & x),
                H = 0 != (2 & x),
                _ = new THREE.ShaderMaterial({
                    uniforms: y,
                    vertexShader: v.vertexShader,
                    fragmentShader: v.fragmentShader,
                    morphTargets: b,
                    skinning: H
                });
            _._shadowPass = !0, p[x] = _, (b = new THREE.ShaderMaterial({
                uniforms: R,
                vertexShader: T.vertexShader,
                fragmentShader: T.fragmentShader,
                morphTargets: b,
                skinning: H
            }))._shadowPass = !0, f[x] = b
        }
        var w = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = THREE.PCFShadowMap, this.cullFace = THREE.CullFaceFront, this.render = function(p) {
            var f, v;
            if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate)) {
                o.clearColor(1, 1, 1, 1), a.disable(o.BLEND), a.enable(o.CULL_FACE), o.frontFace(o.CCW), o.cullFace(w.cullFace === THREE.CullFaceFront ? o.FRONT : o.BACK), a.setDepthTest(!0), t.getViewport(g);
                for (var y = 0, T = e.length; y < T; y++) {
                    var R = e[y];
                    if (!0 === R.castShadow) {
                        var x = R.shadow,
                            b = x.camera,
                            H = x.mapSize;
                        if (R instanceof THREE.PointLight) {
                            f = 6, v = !0;
                            var _ = H.x / 4,
                                M = H.y / 2;
                            m[0].set(2 * _, M, _, M), m[1].set(0, M, _, M), m[2].set(3 * _, M, _, M), m[3].set(_, M, _, M), m[4].set(3 * _, 0, _, M), m[5].set(_, 0, _, M)
                        } else f = 1, v = !1;
                        for (null === x.map && (_ = THREE.LinearFilter, w.type === THREE.PCFSoftShadowMap && (_ = THREE.NearestFilter), x.map = new THREE.WebGLRenderTarget(H.x, H.y, {
                                minFilter: _,
                                magFilter: _,
                                format: THREE.RGBAFormat
                            }), x.matrix = new THREE.Matrix4, R instanceof THREE.SpotLight && (b.aspect = H.x / H.y), b.updateProjectionMatrix()), H = x.map, x = x.matrix, c.setFromMatrixPosition(R.matrixWorld), b.position.copy(c), t.setRenderTarget(H), t.clear(), H = 0; H < f; H++)
                            for (v ? (h.copy(b.position), h.add(d[H]), b.up.copy(E[H]), b.lookAt(h), _ = m[H], t.setViewport(_.x, _.y, _.z, _.w)) : (h.setFromMatrixPosition(R.target.matrixWorld), b.lookAt(h)), b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(b.projectionMatrix), x.multiply(b.matrixWorldInverse), u.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), s.setFromMatrix(u), l.length = 0, i(p, b), _ = 0, M = l.length; _ < M; _++) {
                                var S = l[_],
                                    A = n.update(S);
                                if ((L = S.material) instanceof THREE.MeshFaceMaterial)
                                    for (var C = A.groups, L = L.materials, k = 0, P = C.length; k < P; k++) {
                                        var D = C[k],
                                            N = L[D.materialIndex];
                                        !0 === N.visible && (N = r(S, N, v, c), t.renderBufferDirect(b, e, null, A, N, S, D))
                                    } else N = r(S, L, v, c), t.renderBufferDirect(b, e, null, A, N, S, null)
                            }
                        t.resetGLState()
                    }
                }
                t.setViewport(g.x, g.y, g.z, g.w), p = t.getClearColor(), f = t.getClearAlpha(), t.setClearColor(p, f), a.enable(o.BLEND), w.cullFace === THREE.CullFaceFront && o.cullFace(o.BACK), t.resetGLState(), w.needsUpdate = !1
            }
        }
    }, THREE.WebGLState = function(t, e, n) {
        var r = this,
            i = new Uint8Array(16),
            o = new Uint8Array(16),
            a = new Uint8Array(16),
            s = {},
            u = null,
            h = null,
            c = null,
            l = null,
            p = null,
            f = null,
            d = null,
            E = null,
            m = null,
            g = null,
            v = null,
            y = null,
            T = null,
            R = null,
            x = null,
            b = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            H = void 0,
            _ = {};
        this.init = function() {
            t.clearColor(0, 0, 0, 1), t.clearDepth(1), t.clearStencil(0), this.enable(t.DEPTH_TEST), t.depthFunc(t.LEQUAL), t.frontFace(t.CCW), t.cullFace(t.BACK), this.enable(t.CULL_FACE), this.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA)
        }, this.initAttributes = function() {
            for (var t = 0, e = i.length; t < e; t++) i[t] = 0
        }, this.enableAttribute = function(n) {
            i[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), 0 !== a[n] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0), a[n] = 0)
        }, this.enableAttributeAndDivisor = function(e, n, r) {
            i[e] = 1, 0 === o[e] && (t.enableVertexAttribArray(e), o[e] = 1), a[e] !== n && (r.vertexAttribDivisorANGLE(e, n), a[e] = n)
        }, this.disableUnusedAttributes = function() {
            for (var e = 0, n = o.length; e < n; e++) o[e] !== i[e] && (t.disableVertexAttribArray(e), o[e] = 0)
        }, this.enable = function(e) {
            !0 !== s[e] && (t.enable(e), s[e] = !0)
        }, this.disable = function(e) {
            !1 !== s[e] && (t.disable(e), s[e] = !1)
        }, this.getCompressedTextureFormats = function() {
            if (null === u && (u = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc")))
                for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++) u.push(n[r]);
            return u
        }, this.setBlending = function(e, r, i, o, a, s, u) {
            e !== h && (e === THREE.NoBlending ? this.disable(t.BLEND) : e === THREE.AdditiveBlending ? (this.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === THREE.SubtractiveBlending ? (this.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === THREE.MultiplyBlending ? (this.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : e === THREE.CustomBlending ? this.enable(t.BLEND) : (this.enable(t.BLEND), t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), h = e), e === THREE.CustomBlending ? (a = a || r, s = s || i, u = u || o, r === c && a === f || (t.blendEquationSeparate(n(r), n(a)), c = r, f = a), i === l && o === p && s === d && u === E || (t.blendFuncSeparate(n(i), n(o), n(s), n(u)), l = i, p = o, d = s, E = u)) : E = d = f = p = l = c = null
        }, this.setDepthFunc = function(e) {
            if (m !== e) {
                if (e) switch (e) {
                    case THREE.NeverDepth:
                        t.depthFunc(t.NEVER);
                        break;
                    case THREE.AlwaysDepth:
                        t.depthFunc(t.ALWAYS);
                        break;
                    case THREE.LessDepth:
                        t.depthFunc(t.LESS);
                        break;
                    case THREE.LessEqualDepth:
                        t.depthFunc(t.LEQUAL);
                        break;
                    case THREE.EqualDepth:
                        t.depthFunc(t.EQUAL);
                        break;
                    case THREE.GreaterEqualDepth:
                        t.depthFunc(t.GEQUAL);
                        break;
                    case THREE.GreaterDepth:
                        t.depthFunc(t.GREATER);
                        break;
                    case THREE.NotEqualDepth:
                        t.depthFunc(t.NOTEQUAL);
                        break;
                    default:
                        t.depthFunc(t.LEQUAL)
                } else t.depthFunc(t.LEQUAL);
                m = e
            }
        }, this.setDepthTest = function(e) {
            e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST)
        }, this.setDepthWrite = function(e) {
            g !== e && (t.depthMask(e), g = e)
        }, this.setColorWrite = function(e) {
            v !== e && (t.colorMask(e, e, e, e), v = e)
        }, this.setFlipSided = function(e) {
            y !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), y = e)
        }, this.setLineWidth = function(e) {
            e !== T && (t.lineWidth(e), T = e)
        }, this.setPolygonOffset = function(e, n, r) {
            e ? this.enable(t.POLYGON_OFFSET_FILL) : this.disable(t.POLYGON_OFFSET_FILL), !e || R === n && x === r || (t.polygonOffset(n, r), R = n, x = r)
        }, this.setScissorTest = function(e) {
            e ? this.enable(t.SCISSOR_TEST) : this.disable(t.SCISSOR_TEST)
        }, this.activeTexture = function(e) {
            void 0 === e && (e = t.TEXTURE0 + b - 1), H !== e && (t.activeTexture(e), H = e)
        }, this.bindTexture = function(e, n) {
            void 0 === H && r.activeTexture();
            var i = _[H];
            void 0 === i && (i = {
                type: void 0,
                texture: void 0
            }, _[H] = i), i.type === e && i.texture === n || (t.bindTexture(e, n), i.type = e, i.texture = n)
        }, this.compressedTexImage2D = function() {
            try {
                t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {
                console.error(t)
            }
        }, this.texImage2D = function() {
            try {
                t.texImage2D.apply(t, arguments)
            } catch (t) {
                console.error(t)
            }
        }, this.reset = function() {
            for (var e = 0; e < o.length; e++) 1 === o[e] && (t.disableVertexAttribArray(e), o[e] = 0);
            s = {}, y = v = g = h = u = null
        }
    }, THREE.LensFlarePlugin = function(t, e) {
        var n, r, i, o, a, s, u, h, c, l, p, f, d, E, m, g, v = t.context,
            y = t.state;
        this.render = function(T, R, x, b) {
            if (0 !== e.length) {
                T = new THREE.Vector3;
                var H = b / x,
                    _ = .5 * x,
                    w = .5 * b,
                    M = 16 / b,
                    S = new THREE.Vector2(M * H, M),
                    A = new THREE.Vector3(1, 1, 0),
                    C = new THREE.Vector2(1, 1);
                if (void 0 === d) {
                    M = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
                    var L = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    p = v.createBuffer(), f = v.createBuffer(), v.bindBuffer(v.ARRAY_BUFFER, p), v.bufferData(v.ARRAY_BUFFER, M, v.STATIC_DRAW), v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, f), v.bufferData(v.ELEMENT_ARRAY_BUFFER, L, v.STATIC_DRAW), m = v.createTexture(), g = v.createTexture(), y.bindTexture(v.TEXTURE_2D, m), v.texImage2D(v.TEXTURE_2D, 0, v.RGB, 16, 16, 0, v.RGB, v.UNSIGNED_BYTE, null), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, v.CLAMP_TO_EDGE), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, v.CLAMP_TO_EDGE), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, v.NEAREST), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, v.NEAREST), y.bindTexture(v.TEXTURE_2D, g), v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, 16, 16, 0, v.RGBA, v.UNSIGNED_BYTE, null), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, v.CLAMP_TO_EDGE), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, v.CLAMP_TO_EDGE), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, v.NEAREST), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, v.NEAREST);
                    M = (E = 0 < v.getParameter(v.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                        vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                        fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                    } : {
                        vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                        fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                    }, L = v.createProgram();
                    var k = v.createShader(v.FRAGMENT_SHADER),
                        P = v.createShader(v.VERTEX_SHADER),
                        D = "precision " + t.getPrecision() + " float;\n";
                    v.shaderSource(k, D + M.fragmentShader), v.shaderSource(P, D + M.vertexShader), v.compileShader(k), v.compileShader(P), v.attachShader(L, k), v.attachShader(L, P), v.linkProgram(L), d = L, c = v.getAttribLocation(d, "position"), l = v.getAttribLocation(d, "uv"), n = v.getUniformLocation(d, "renderType"), r = v.getUniformLocation(d, "map"), i = v.getUniformLocation(d, "occlusionMap"), o = v.getUniformLocation(d, "opacity"), a = v.getUniformLocation(d, "color"), s = v.getUniformLocation(d, "scale"), u = v.getUniformLocation(d, "rotation"), h = v.getUniformLocation(d, "screenPosition")
                }
                for (v.useProgram(d), y.initAttributes(), y.enableAttribute(c), y.enableAttribute(l), y.disableUnusedAttributes(), v.uniform1i(i, 0), v.uniform1i(r, 1), v.bindBuffer(v.ARRAY_BUFFER, p), v.vertexAttribPointer(c, 2, v.FLOAT, !1, 16, 0), v.vertexAttribPointer(l, 2, v.FLOAT, !1, 16, 8), v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, f), y.disable(v.CULL_FACE), v.depthMask(!1), L = 0, k = e.length; L < k; L++)
                    if (M = 16 / b, S.set(M * H, M), P = e[L], T.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), T.applyMatrix4(R.matrixWorldInverse), T.applyProjection(R.projectionMatrix), A.copy(T), C.x = A.x * _ + _, C.y = A.y * w + w, E || 0 < C.x && C.x < x && 0 < C.y && C.y < b) {
                        y.activeTexture(v.TEXTURE0), y.bindTexture(v.TEXTURE_2D, null), y.activeTexture(v.TEXTURE1), y.bindTexture(v.TEXTURE_2D, m), v.copyTexImage2D(v.TEXTURE_2D, 0, v.RGB, C.x - 8, C.y - 8, 16, 16, 0), v.uniform1i(n, 0), v.uniform2f(s, S.x, S.y), v.uniform3f(h, A.x, A.y, A.z), y.disable(v.BLEND), y.enable(v.DEPTH_TEST), v.drawElements(v.TRIANGLES, 6, v.UNSIGNED_SHORT, 0), y.activeTexture(v.TEXTURE0), y.bindTexture(v.TEXTURE_2D, g), v.copyTexImage2D(v.TEXTURE_2D, 0, v.RGBA, C.x - 8, C.y - 8, 16, 16, 0), v.uniform1i(n, 1), y.disable(v.DEPTH_TEST), y.activeTexture(v.TEXTURE1), y.bindTexture(v.TEXTURE_2D, m), v.drawElements(v.TRIANGLES, 6, v.UNSIGNED_SHORT, 0), P.positionScreen.copy(A), P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares(), v.uniform1i(n, 2), y.enable(v.BLEND);
                        D = 0;
                        for (var N = P.lensFlares.length; D < N; D++) {
                            var F = P.lensFlares[D];
                            .001 < F.opacity && .001 < F.scale && (A.x = F.x, A.y = F.y, A.z = F.z, M = F.size * F.scale / b, S.x = M * H, S.y = M, v.uniform3f(h, A.x, A.y, A.z), v.uniform2f(s, S.x, S.y), v.uniform1f(u, F.rotation), v.uniform1f(o, F.opacity), v.uniform3f(a, F.color.r, F.color.g, F.color.b), y.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), t.setTexture(F.texture, 1), v.drawElements(v.TRIANGLES, 6, v.UNSIGNED_SHORT, 0))
                        }
                    }
                y.enable(v.CULL_FACE), y.enable(v.DEPTH_TEST), v.depthMask(!0), t.resetGLState()
            }
        }
    }, THREE.SpritePlugin = function(t, e) {
        var n, r, i, o, a, s, u, h, c, l, p, f, d, E, m, g, v;

        function y(t, e) {
            return t.z !== e.z ? e.z - t.z : e.id - t.id
        }
        var T, R, x, b, H = t.context,
            _ = t.state,
            w = new THREE.Vector3,
            M = new THREE.Quaternion,
            S = new THREE.Vector3;
        this.render = function(A, C) {
            if (0 !== e.length) {
                if (void 0 === x) {
                    var L = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        k = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    T = H.createBuffer(), R = H.createBuffer(), H.bindBuffer(H.ARRAY_BUFFER, T), H.bufferData(H.ARRAY_BUFFER, L, H.STATIC_DRAW), H.bindBuffer(H.ELEMENT_ARRAY_BUFFER, R), H.bufferData(H.ELEMENT_ARRAY_BUFFER, k, H.STATIC_DRAW);
                    L = H.createProgram(), k = H.createShader(H.VERTEX_SHADER);
                    var P = H.createShader(H.FRAGMENT_SHADER);
                    H.shaderSource(k, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), H.shaderSource(P, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), H.compileShader(k), H.compileShader(P), H.attachShader(L, k), H.attachShader(L, P), H.linkProgram(L), x = L, g = H.getAttribLocation(x, "position"), v = H.getAttribLocation(x, "uv"), n = H.getUniformLocation(x, "uvOffset"), r = H.getUniformLocation(x, "uvScale"), i = H.getUniformLocation(x, "rotation"), o = H.getUniformLocation(x, "scale"), a = H.getUniformLocation(x, "color"), s = H.getUniformLocation(x, "map"), u = H.getUniformLocation(x, "opacity"), h = H.getUniformLocation(x, "modelViewMatrix"), c = H.getUniformLocation(x, "projectionMatrix"), l = H.getUniformLocation(x, "fogType"), p = H.getUniformLocation(x, "fogDensity"), f = H.getUniformLocation(x, "fogNear"), d = H.getUniformLocation(x, "fogFar"), E = H.getUniformLocation(x, "fogColor"), m = H.getUniformLocation(x, "alphaTest"), (L = document.createElement("canvas")).width = 8, L.height = 8, (k = L.getContext("2d")).fillStyle = "white", k.fillRect(0, 0, 8, 8), (b = new THREE.Texture(L)).needsUpdate = !0
                }
                H.useProgram(x), _.initAttributes(), _.enableAttribute(g), _.enableAttribute(v), _.disableUnusedAttributes(), _.disable(H.CULL_FACE), _.enable(H.BLEND), H.bindBuffer(H.ARRAY_BUFFER, T), H.vertexAttribPointer(g, 2, H.FLOAT, !1, 16, 0), H.vertexAttribPointer(v, 2, H.FLOAT, !1, 16, 8), H.bindBuffer(H.ELEMENT_ARRAY_BUFFER, R), H.uniformMatrix4fv(c, !1, C.projectionMatrix.elements), _.activeTexture(H.TEXTURE0), H.uniform1i(s, 0), k = L = 0, (P = A.fog) ? (H.uniform3f(E, P.color.r, P.color.g, P.color.b), P instanceof THREE.Fog ? (H.uniform1f(f, P.near), H.uniform1f(d, P.far), H.uniform1i(l, 1), k = L = 1) : P instanceof THREE.FogExp2 && (H.uniform1f(p, P.density), H.uniform1i(l, 2), k = L = 2)) : (H.uniform1i(l, 0), k = L = 0);
                P = 0;
                for (var D = e.length; P < D; P++) {
                    (F = e[P]).modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, F.matrixWorld), F.z = -F.modelViewMatrix.elements[14]
                }
                e.sort(y);
                var N = [];
                for (P = 0, D = e.length; P < D; P++) {
                    var F, O = (F = e[P]).material;
                    H.uniform1f(m, O.alphaTest), H.uniformMatrix4fv(h, !1, F.modelViewMatrix.elements), F.matrixWorld.decompose(w, M, S), N[0] = S.x, N[1] = S.y, F = 0, A.fog && O.fog && (F = k), L !== F && (H.uniform1i(l, F), L = F), null !== O.map ? (H.uniform2f(n, O.map.offset.x, O.map.offset.y), H.uniform2f(r, O.map.repeat.x, O.map.repeat.y)) : (H.uniform2f(n, 0, 0), H.uniform2f(r, 1, 1)), H.uniform1f(u, O.opacity), H.uniform3f(a, O.color.r, O.color.g, O.color.b), H.uniform1f(i, O.rotation), H.uniform2fv(o, N), _.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst), _.setDepthTest(O.depthTest), _.setDepthWrite(O.depthWrite), O.map && O.map.image && O.map.image.width ? t.setTexture(O.map, 0) : t.setTexture(b, 0), H.drawElements(H.TRIANGLES, 6, H.UNSIGNED_SHORT, 0)
                }
                _.enable(H.CULL_FACE), t.resetGLState()
            }
        }
    }, THREE.CurveUtils = {
        tangentQuadraticBezier: function(t, e, n, r) {
            return 2 * (1 - t) * (n - e) + 2 * t * (r - n)
        },
        tangentCubicBezier: function(t, e, n, r, i) {
            return -3 * e * (1 - t) * (1 - t) + 3 * n * (1 - t) * (1 - t) - 6 * t * n * (1 - t) + 6 * t * r * (1 - t) - 3 * t * t * r + 3 * t * t * i
        },
        tangentSpline: function(t, e, n, r, i) {
            return 6 * t * t - 6 * t + (3 * t * t - 4 * t + 1) + (-6 * t * t + 6 * t) + (3 * t * t - 2 * t)
        },
        interpolate: function(t, e, n, r, i) {
            var o = i * i;
            return (2 * e - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - e))) * i * o + (-3 * e + 3 * n - 2 * t - r) * o + t * i + e
        }
    }, THREE.GeometryUtils = {
        merge: function(t, e, n) {
            var r;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e instanceof THREE.Mesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, n)
        },
        center: function(t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
        }
    }, THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.");
            var i = new THREE.TextureLoader;
            return i.setCrossOrigin(this.crossOrigin), t = i.load(t, n, void 0, r), e && (t.mapping = e), t
        },
        loadTextureCube: function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.");
            var i = new THREE.CubeTextureLoader;
            return i.setCrossOrigin(this.crossOrigin), t = i.load(t, n, void 0, r), e && (t.mapping = e), t
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    }, THREE.SceneUtils = {
        createMultiMaterialObject: function(t, e) {
            for (var n = new THREE.Group, r = 0, i = e.length; r < i; r++) n.add(new THREE.Mesh(t, e[r]));
            return n
        },
        detach: function(t, e, n) {
            t.applyMatrix(e.matrixWorld), e.remove(t), n.add(t)
        },
        attach: function(t, e, n) {
            var r = new THREE.Matrix4;
            r.getInverse(n.matrixWorld), t.applyMatrix(r), e.remove(t), n.add(t)
        }
    }, THREE.ShapeUtils = {
        area: function(t) {
            for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
            return .5 * n
        },
        triangulate: function(t, e) {
            var n = t.length;
            if (3 > n) return null;
            var r, i, o, a = [],
                s = [],
                u = [];
            if (0 < THREE.ShapeUtils.area(t))
                for (i = 0; i < n; i++) s[i] = i;
            else
                for (i = 0; i < n; i++) s[i] = n - 1 - i;
            var h = 2 * n;
            for (i = n - 1; 2 < n;) {
                if (0 >= h--) {
                    console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                    break
                }
                var c;
                n <= (r = i) && (r = 0), n <= (i = r + 1) && (i = 0), n <= (o = i + 1) && (o = 0);
                t: {
                    var l = c = void 0,
                        p = void 0,
                        f = void 0,
                        d = (l = t[s[r]].x, t[s[r]].y),
                        E = t[s[i]].x,
                        m = t[s[i]].y,
                        g = t[s[o]].x,
                        v = t[s[o]].y;
                    if (Number.EPSILON > (E - l) * (v - d) - (m - d) * (g - l)) c = !1;
                    else {
                        var y = void 0,
                            T = void 0,
                            R = void 0,
                            x = void 0,
                            b = (R = T = y = f = p = void 0, g - E),
                            H = v - m,
                            _ = l - g,
                            w = d - v,
                            M = E - l,
                            S = m - d;
                        for (c = 0; c < n; c++)
                            if (p = t[s[c]].x, f = t[s[c]].y, !(p === l && f === d || p === E && f === m || p === g && f === v) && (R = p - E, x = f - m, y = M * (T = f - d) - S * (y = p - l), T = _ * (f -= v) - w * (p -= g), (R = b * x - H * R) >= -Number.EPSILON && T >= -Number.EPSILON && y >= -Number.EPSILON)) {
                                c = !1;
                                break t
                            }
                        c = !0
                    }
                }
                if (c) {
                    for (a.push([t[s[r]], t[s[i]], t[s[o]]]), u.push([s[r], s[i], s[o]]), r = i, o = i + 1; o < n; r++, o++) s[r] = s[o];
                    h = 2 * --n
                }
            }
            return e ? u : a
        },
        triangulateShape: function(t, e) {
            function n(t, e, n) {
                return t.x !== e.x ? t.x < e.x ? t.x <= n.x && n.x <= e.x : e.x <= n.x && n.x <= t.x : t.y < e.y ? t.y <= n.y && n.y <= e.y : e.y <= n.y && n.y <= t.y
            }

            function r(t, e, r, i, o) {
                var a = e.x - t.x,
                    s = e.y - t.y,
                    u = i.x - r.x,
                    h = i.y - r.y,
                    c = t.x - r.x,
                    l = t.y - r.y,
                    p = s * u - a * h,
                    f = s * c - a * l;
                if (Math.abs(p) > Number.EPSILON) {
                    if (0 < p) {
                        if (0 > f || f > p) return [];
                        if (0 > (u = h * c - u * l) || u > p) return []
                    } else {
                        if (0 < f || f < p) return [];
                        if (0 < (u = h * c - u * l) || u < p) return []
                    }
                    return 0 === u ? !o || 0 !== f && f !== p ? [t] : [] : u === p ? !o || 0 !== f && f !== p ? [e] : [] : 0 === f ? [r] : f === p ? [i] : (o = u / p, [{
                        x: t.x + o * a,
                        y: t.y + o * s
                    }])
                }
                return 0 !== f || h * c != u * l ? [] : (s = 0 === a && 0 === s, u = 0 === u && 0 === h, s && u ? t.x !== r.x || t.y !== r.y ? [] : [t] : s ? n(r, i, t) ? [t] : [] : u ? n(t, e, r) ? [r] : [] : (0 !== a ? (t.x < e.x ? (a = t, u = t.x, s = e, t = e.x) : (a = e, u = e.x, s = t, t = t.x), r.x < i.x ? (e = r, p = r.x, h = i, r = i.x) : (e = i, p = i.x, h = r, r = r.x)) : (t.y < e.y ? (a = t, u = t.y, s = e, t = e.y) : (a = e, u = e.y, s = t, t = t.y), r.y < i.y ? (e = r, p = r.y, h = i, r = i.y) : (e = i, p = i.y, h = r, r = r.y)), u <= p ? t < p ? [] : t === p ? o ? [] : [e] : t <= r ? [e, s] : [e, h] : u > r ? [] : u === r ? o ? [] : [a] : t <= r ? [a, s] : [a, h]))
            }

            function i(t, e, n, r) {
                var i = e.x - t.x,
                    o = e.y - t.y;
                e = n.x - t.x, n = n.y - t.y;
                var a = r.x - t.x;
                return r = r.y - t.y, t = i * n - o * e, i = i * r - o * a, Math.abs(t) > Number.EPSILON ? (e = a * n - r * e, 0 < t ? 0 <= i && 0 <= e : 0 <= i || 0 <= e) : 0 < i
            }
            var o, a, s, u, h, c = {};
            for (s = t.concat(), o = 0, a = e.length; o < a; o++) Array.prototype.push.apply(s, e[o]);
            for (o = 0, a = s.length; o < a; o++) void 0 !== c[h = s[o].x + ":" + s[o].y] && console.warn("THREE.Shape: Duplicate point", h), c[h] = o;
            o = function(t, e) {
                function n(t, e) {
                    var n = m.length - 1,
                        r = t - 1;
                    0 > r && (r = n);
                    var o = t + 1;
                    return o > n && (o = 0), !!(n = i(m[t], m[r], m[o], s[e])) && (n = s.length - 1, 0 > (r = e - 1) && (r = n), (o = e + 1) > n && (o = 0), !!(n = i(s[e], s[r], s[o], m[t])))
                }

                function o(t, e) {
                    var n, i;
                    for (n = 0; n < m.length; n++)
                        if (i = n + 1, i %= m.length, 0 < (i = r(t, e, m[n], m[i], !0)).length) return !0;
                    return !1
                }

                function a(t, n) {
                    var i, o, a, s;
                    for (i = 0; i < g.length; i++)
                        for (o = e[g[i]], a = 0; a < o.length; a++)
                            if (s = a + 1, s %= o.length, 0 < (s = r(t, n, o[a], o[s], !0)).length) return !0;
                    return !1
                }
                var s, u, h, c, l, p, f, d, E, m = t.concat(),
                    g = [],
                    v = [],
                    y = 0;
                for (u = e.length; y < u; y++) g.push(y);
                f = 0;
                for (var T = 2 * g.length; 0 < g.length;) {
                    if (0 > --T) {
                        console.log("Infinite Loop! Holes left:" + g.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (h = f; h < m.length; h++) {
                        for (c = m[h], u = -1, y = 0; y < g.length; y++)
                            if (l = g[y], void 0 === v[p = c.x + ":" + c.y + ":" + l]) {
                                for (s = e[l], d = 0; d < s.length; d++)
                                    if (l = s[d], n(h, d) && !o(c, l) && !a(c, l)) {
                                        u = d, g.splice(y, 1), f = m.slice(0, h + 1), l = m.slice(h), d = s.slice(u), E = s.slice(0, u + 1), m = f.concat(d).concat(E).concat(l), f = h;
                                        break
                                    }
                                if (0 <= u) break;
                                v[p] = !0
                            }
                        if (0 <= u) break
                    }
                }
                return m
            }(t, e);
            var l = THREE.ShapeUtils.triangulate(o, !1);
            for (o = 0, a = l.length; o < a; o++)
                for (u = l[o], s = 0; 3 > s; s++) void 0 !== (h = c[h = u[s].x + ":" + u[s].y]) && (u[s] = h);
            return l.concat()
        },
        isClockWise: function(t) {
            return 0 > THREE.ShapeUtils.area(t)
        },
        b2: function(t, e, n, r) {
            var i = 1 - t;
            return i * i * e + 2 * (1 - t) * t * n + t * t * r
        },
        b3: function(t, e, n, r, i) {
            var o = 1 - t,
                a = 1 - t;
            return o * o * o * e + 3 * a * a * t * n + 3 * (1 - t) * t * t * r + t * t * t * i
        }
    }, THREE.Audio = function(t) {
        THREE.Object3D.call(this), this.type = "Audio", this.context = t.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.panner = this.context.createPanner(), this.panner.connect(this.gain), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1
    }, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, THREE.Audio.prototype.load = function(t) {
        var e = this,
            n = new XMLHttpRequest;
        return n.open("GET", t, !0), n.responseType = "arraybuffer", n.onload = function(t) {
            e.context.decodeAudioData(this.response, function(t) {
                e.source.buffer = t, e.autoplay && e.play()
            })
        }, n.send(), this
    }, THREE.Audio.prototype.play = function() {
        if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
        else {
            var t = this.context.createBufferSource();
            t.buffer = this.source.buffer, t.loop = this.source.loop, t.onended = this.source.onended, t.start(0, this.startTime), t.playbackRate.value = this.playbackRate, this.isPlaying = !0, this.source = t, this.connect()
        }
    }, THREE.Audio.prototype.pause = function() {
        this.source.stop(), this.startTime = this.context.currentTime
    }, THREE.Audio.prototype.stop = function() {
        this.source.stop(), this.startTime = 0
    }, THREE.Audio.prototype.connect = function() {
        void 0 !== this.filter ? (this.source.connect(this.filter), this.filter.connect(this.panner)) : this.source.connect(this.panner)
    }, THREE.Audio.prototype.disconnect = function() {
        void 0 !== this.filter ? (this.source.disconnect(this.filter), this.filter.disconnect(this.panner)) : this.source.disconnect(this.panner)
    }, THREE.Audio.prototype.setFilter = function(t) {
        !0 === this.isPlaying ? (this.disconnect(), this.filter = t, this.connect()) : this.filter = t
    }, THREE.Audio.prototype.getFilter = function() {
        return this.filter
    }, THREE.Audio.prototype.setPlaybackRate = function(t) {
        this.playbackRate = t, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate)
    }, THREE.Audio.prototype.getPlaybackRate = function() {
        return this.playbackRate
    }, THREE.Audio.prototype.onEnded = function() {
        this.isPlaying = !1
    }, THREE.Audio.prototype.setLoop = function(t) {
        this.source.loop = t
    }, THREE.Audio.prototype.getLoop = function() {
        return this.source.loop
    }, THREE.Audio.prototype.setRefDistance = function(t) {
        this.panner.refDistance = t
    }, THREE.Audio.prototype.getRefDistance = function() {
        return this.panner.refDistance
    }, THREE.Audio.prototype.setRolloffFactor = function(t) {
        this.panner.rolloffFactor = t
    }, THREE.Audio.prototype.getRolloffFactor = function() {
        return this.panner.rolloffFactor
    }, THREE.Audio.prototype.setVolume = function(t) {
        this.gain.gain.value = t
    }, THREE.Audio.prototype.getVolume = function() {
        return this.gain.gain.value
    }, THREE.Audio.prototype.updateMatrixWorld = function() {
        var t = new THREE.Vector3;
        return function(e) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
        }
    }(), THREE.AudioListener = function() {
        THREE.Object3D.call(this), this.type = "AudioListener", this.context = new(window.AudioContext || window.webkitAudioContext)
    }, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, THREE.AudioListener.prototype.updateMatrixWorld = function() {
        var t = new THREE.Vector3,
            e = new THREE.Quaternion,
            n = new THREE.Vector3,
            r = new THREE.Vector3;
        return function(i) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, i), i = this.context.listener;
            var o = this.up;
            this.matrixWorld.decompose(t, e, n), r.set(0, 0, -1).applyQuaternion(e), i.setPosition(t.x, t.y, t.z), i.setOrientation(r.x, r.y, r.z, o.x, o.y, o.z)
        }
    }(), THREE.Curve = function() {}, THREE.Curve.prototype = {
        constructor: THREE.Curve,
        getPoint: function(t) {
            return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
        },
        getPointAt: function(t) {
            return t = this.getUtoTmapping(t), this.getPoint(t)
        },
        getPoints: function(t) {
            t || (t = 5);
            var e, n = [];
            for (e = 0; e <= t; e++) n.push(this.getPoint(e / t));
            return n
        },
        getSpacedPoints: function(t) {
            t || (t = 5);
            var e, n = [];
            for (e = 0; e <= t; e++) n.push(this.getPointAt(e / t));
            return n
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n, r = [],
                i = this.getPoint(0),
                o = 0;
            for (r.push(0), n = 1; n <= t; n++) o += (e = this.getPoint(n / t)).distanceTo(i), r.push(o), i = e;
            return this.cacheArcLengths = r
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var n, r = this.getLengths(),
                i = 0,
                o = r.length;
            n = e || t * r[o - 1];
            for (var a, s = 0, u = o - 1; s <= u;)
                if (0 > (a = r[i = Math.floor(s + (u - s) / 2)] - n)) s = i + 1;
                else {
                    if (!(0 < a)) {
                        u = i;
                        break
                    }
                    u = i - 1
                }
            return r[i = u] === n ? i / (o - 1) : (i + (n - (s = r[i])) / (r[i + 1] - s)) / (o - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4;
            return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize()
        },
        getTangentAt: function(t) {
            return t = this.getUtoTmapping(t), this.getTangent(t)
        }
    }, THREE.Curve.Utils = THREE.CurveUtils, THREE.Curve.create = function(t, e) {
        return t.prototype = Object.create(THREE.Curve.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, THREE.CurvePath = function() {
        this.curves = [], this.autoClose = !1
    }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, THREE.CurvePath.prototype.add = function(t) {
        this.curves.push(t)
    }, THREE.CurvePath.prototype.closePath = function() {
        var t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new THREE.LineCurve(e, t))
    }, THREE.CurvePath.prototype.getPoint = function(t) {
        for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
            if (n[r] >= e) return t = this.curves[r], e = 1 - (n[r] - e) / t.getLength(), t.getPointAt(e);
            r++
        }
        return null
    }, THREE.CurvePath.prototype.getLength = function() {
        var t = this.getCurveLengths();
        return t[t.length - 1]
    }, THREE.CurvePath.prototype.getCurveLengths = function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
        return this.cacheLengths = t
    }, THREE.CurvePath.prototype.createPointsGeometry = function(t) {
        return t = this.getPoints(t, !0), this.createGeometry(t)
    }, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(t) {
        return t = this.getSpacedPoints(t, !0), this.createGeometry(t)
    }, THREE.CurvePath.prototype.createGeometry = function(t) {
        for (var e = new THREE.Geometry, n = 0, r = t.length; n < r; n++) {
            var i = t[n];
            e.vertices.push(new THREE.Vector3(i.x, i.y, i.z || 0))
        }
        return e
    }, THREE.Path = function(t) {
        THREE.CurvePath.call(this), this.actions = [], t && this.fromPoints(t)
    }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path, THREE.Path.prototype.fromPoints = function(t) {
        this.moveTo(t[0].x, t[0].y);
        for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
    }, THREE.Path.prototype.moveTo = function(t, e) {
        this.actions.push({
            action: "moveTo",
            args: [t, e]
        })
    }, THREE.Path.prototype.lineTo = function(t, e) {
        var n = this.actions[this.actions.length - 1].args;
        n = new THREE.LineCurve(new THREE.Vector2(n[n.length - 2], n[n.length - 1]), new THREE.Vector2(t, e));
        this.curves.push(n), this.actions.push({
            action: "lineTo",
            args: [t, e]
        })
    }, THREE.Path.prototype.quadraticCurveTo = function(t, e, n, r) {
        var i = this.actions[this.actions.length - 1].args;
        i = new THREE.QuadraticBezierCurve(new THREE.Vector2(i[i.length - 2], i[i.length - 1]), new THREE.Vector2(t, e), new THREE.Vector2(n, r));
        this.curves.push(i), this.actions.push({
            action: "quadraticCurveTo",
            args: [t, e, n, r]
        })
    }, THREE.Path.prototype.bezierCurveTo = function(t, e, n, r, i, o) {
        var a = this.actions[this.actions.length - 1].args;
        a = new THREE.CubicBezierCurve(new THREE.Vector2(a[a.length - 2], a[a.length - 1]), new THREE.Vector2(t, e), new THREE.Vector2(n, r), new THREE.Vector2(i, o));
        this.curves.push(a), this.actions.push({
            action: "bezierCurveTo",
            args: [t, e, n, r, i, o]
        })
    }, THREE.Path.prototype.splineThru = function(t) {
        var e = Array.prototype.slice.call(arguments),
            n = this.actions[this.actions.length - 1].args;
        n = [new THREE.Vector2(n[n.length - 2], n[n.length - 1])];
        Array.prototype.push.apply(n, t), n = new THREE.SplineCurve(n), this.curves.push(n), this.actions.push({
            action: "splineThru",
            args: e
        })
    }, THREE.Path.prototype.arc = function(t, e, n, r, i, o) {
        var a = this.actions[this.actions.length - 1].args;
        this.absarc(t + a[a.length - 2], e + a[a.length - 1], n, r, i, o)
    }, THREE.Path.prototype.absarc = function(t, e, n, r, i, o) {
        this.absellipse(t, e, n, n, r, i, o)
    }, THREE.Path.prototype.ellipse = function(t, e, n, r, i, o, a, s) {
        var u = this.actions[this.actions.length - 1].args;
        this.absellipse(t + u[u.length - 2], e + u[u.length - 1], n, r, i, o, a, s)
    }, THREE.Path.prototype.absellipse = function(t, e, n, r, i, o, a, s) {
        var u = [t, e, n, r, i, o, a, s || 0];
        t = new THREE.EllipseCurve(t, e, n, r, i, o, a, s), this.curves.push(t), t = t.getPoint(1), u.push(t.x), u.push(t.y), this.actions.push({
            action: "ellipse",
            args: u
        })
    }, THREE.Path.prototype.getSpacedPoints = function(t, e) {
        t || (t = 40);
        for (var n = [], r = 0; r < t; r++) n.push(this.getPoint(r / t));
        return n
    }, THREE.Path.prototype.getPoints = function(t, e) {
        t = t || 12;
        for (var n, r, i, o, a, s, u, h, c, l, p = THREE.ShapeUtils.b2, f = THREE.ShapeUtils.b3, d = [], E = 0, m = this.actions.length; E < m; E++) {
            var g = (c = this.actions[E]).args;
            switch (c.action) {
                case "moveTo":
                case "lineTo":
                    d.push(new THREE.Vector2(g[0], g[1]));
                    break;
                case "quadraticCurveTo":
                    for (n = g[2], r = g[3], a = g[0], s = g[1], 0 < d.length ? (u = (c = d[d.length - 1]).x, h = c.y) : (u = (c = this.actions[E - 1].args)[c.length - 2], h = c[c.length - 1]), g = 1; g <= t; g++) c = p(l = g / t, u, a, n), l = p(l, h, s, r), d.push(new THREE.Vector2(c, l));
                    break;
                case "bezierCurveTo":
                    for (n = g[4], r = g[5], a = g[0], s = g[1], i = g[2], o = g[3], 0 < d.length ? (u = (c = d[d.length - 1]).x, h = c.y) : (u = (c = this.actions[E - 1].args)[c.length - 2], h = c[c.length - 1]), g = 1; g <= t; g++) c = f(l = g / t, u, a, i, n), l = f(l, h, s, o, r), d.push(new THREE.Vector2(c, l));
                    break;
                case "splineThru":
                    for (c = this.actions[E - 1].args, l = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])], c = t * g[0].length, l = l.concat(g[0]), l = new THREE.SplineCurve(l), g = 1; g <= c; g++) d.push(l.getPointAt(g / c));
                    break;
                case "arc":
                    for (n = g[0], r = g[1], s = g[2], i = g[3], c = g[4], a = !!g[5], u = c - i, h = 2 * t, g = 1; g <= h; g++) l = g / h, a || (l = 1 - l), l = i + l * u, c = n + s * Math.cos(l), l = r + s * Math.sin(l), d.push(new THREE.Vector2(c, l));
                    break;
                case "ellipse":
                    n = g[0], r = g[1], s = g[2], o = g[3], i = g[4], c = g[5], a = !!g[6];
                    var v, y, T = g[7];
                    for (u = c - i, h = 2 * t, 0 !== T && (v = Math.cos(T), y = Math.sin(T)), g = 1; g <= h; g++) {
                        if (l = g / h, a || (l = 1 - l), l = i + l * u, c = n + s * Math.cos(l), l = r + o * Math.sin(l), 0 !== T) {
                            var R = c;
                            c = (R - n) * v - (l - r) * y + n, l = (R - n) * y + (l - r) * v + r
                        }
                        d.push(new THREE.Vector2(c, l))
                    }
            }
        }
        return p = d[d.length - 1], Math.abs(p.x - d[0].x) < Number.EPSILON && Math.abs(p.y - d[0].y) < Number.EPSILON && d.splice(d.length - 1, 1), e && d.push(d[0]), d
    }, THREE.Path.prototype.toShapes = function(t, e) {
        function n(t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
                var i = t[n],
                    o = new THREE.Shape;
                o.actions = i.actions, o.curves = i.curves, e.push(o)
            }
            return e
        }

        function r(t, e) {
            for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                var a = e[i],
                    s = e[o],
                    u = s.x - a.x,
                    h = s.y - a.y;
                if (Math.abs(h) > Number.EPSILON) {
                    if (0 > h && (a = e[o], u = -u, s = e[i], h = -h), !(t.y < a.y || t.y > s.y))
                        if (t.y === a.y) {
                            if (t.x === a.x) return !0
                        } else {
                            if (0 === (i = h * (t.x - a.x) - u * (t.y - a.y))) return !0;
                            0 > i || (r = !r)
                        }
                } else if (t.y === a.y && (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)) return !0
            }
            return r
        }
        var i = THREE.ShapeUtils.isClockWise,
            o = function(t) {
                for (var e = [], n = new THREE.Path, r = 0, i = t.length; r < i; r++) {
                    var o, a = (o = t[r]).args;
                    "moveTo" === (o = o.action) && 0 !== n.actions.length && (e.push(n), n = new THREE.Path), n[o].apply(n, a)
                }
                return 0 !== n.actions.length && e.push(n), e
            }(this.actions);
        if (0 === o.length) return [];
        if (!0 === e) return n(o);
        var a, s, u, h = [];
        if (1 === o.length) return s = o[0], (u = new THREE.Shape).actions = s.actions, u.curves = s.curves, h.push(u), h;
        var c = !i(o[0].getPoints());
        c = t ? !c : c;
        u = [];
        var l, p = [],
            f = [],
            d = 0;
        p[d] = void 0, f[d] = [];
        for (var E = 0, m = o.length; E < m; E++) a = i(l = (s = o[E]).getPoints()), (a = t ? !a : a) ? (!c && p[d] && d++, p[d] = {
            s: new THREE.Shape,
            p: l
        }, p[d].s.actions = s.actions, p[d].s.curves = s.curves, c && d++, f[d] = []) : f[d].push({
            h: s,
            p: l[0]
        });
        if (!p[0]) return n(o);
        if (1 < p.length) {
            for (E = !1, s = [], i = 0, o = p.length; i < o; i++) u[i] = [];
            for (i = 0, o = p.length; i < o; i++)
                for (a = f[i], c = 0; c < a.length; c++) {
                    for (d = a[c], l = !0, m = 0; m < p.length; m++) r(d.p, p[m].p) && (i !== m && s.push({
                        froms: i,
                        tos: m,
                        hole: c
                    }), l ? (l = !1, u[m].push(d)) : E = !0);
                    l && u[i].push(d)
                }
            0 < s.length && (E || (f = u))
        }
        for (E = 0, i = p.length; E < i; E++)
            for (u = p[E].s, h.push(u), o = 0, a = (s = f[E]).length; o < a; o++) u.holes.push(s[o].h);
        return h
    }, THREE.Shape = function() {
        THREE.Path.apply(this, arguments), this.holes = []
    }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape, THREE.Shape.prototype.extrude = function(t) {
        return new THREE.ExtrudeGeometry(this, t)
    }, THREE.Shape.prototype.makeGeometry = function(t) {
        return new THREE.ShapeGeometry(this, t)
    }, THREE.Shape.prototype.getPointsHoles = function(t) {
        for (var e = [], n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
        return e
    }, THREE.Shape.prototype.extractAllPoints = function(t) {
        return {
            shape: this.getPoints(t),
            holes: this.getPointsHoles(t)
        }
    }, THREE.Shape.prototype.extractPoints = function(t) {
        return this.extractAllPoints(t)
    }, THREE.Shape.Utils = THREE.ShapeUtils, THREE.LineCurve = function(t, e) {
        this.v1 = t, this.v2 = e
    }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, THREE.LineCurve.prototype.getPoint = function(t) {
        var e = this.v2.clone().sub(this.v1);
        return e.multiplyScalar(t).add(this.v1), e
    }, THREE.LineCurve.prototype.getPointAt = function(t) {
        return this.getPoint(t)
    }, THREE.LineCurve.prototype.getTangent = function(t) {
        return this.v2.clone().sub(this.v1).normalize()
    }, THREE.QuadraticBezierCurve = function(t, e, n) {
        this.v0 = t, this.v1 = e, this.v2 = n
    }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
        var e = THREE.ShapeUtils.b2;
        return new THREE.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y))
    }, THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
        var e = THREE.CurveUtils.tangentQuadraticBezier;
        return new THREE.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y)).normalize()
    }, THREE.CubicBezierCurve = function(t, e, n, r) {
        this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
    }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, THREE.CubicBezierCurve.prototype.getPoint = function(t) {
        var e = THREE.ShapeUtils.b3;
        return new THREE.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
    }, THREE.CubicBezierCurve.prototype.getTangent = function(t) {
        var e = THREE.CurveUtils.tangentCubicBezier;
        return new THREE.Vector2(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
    }, THREE.SplineCurve = function(t) {
        this.points = void 0 == t ? [] : t
    }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, THREE.SplineCurve.prototype.getPoint = function(t) {
        t *= (i = this.points).length - 1, t -= o = Math.floor(t);
        var e = i[0 === o ? o : o - 1],
            n = i[o],
            r = i[o > i.length - 2 ? i.length - 1 : o + 1],
            i = i[o > i.length - 3 ? i.length - 1 : o + 2],
            o = THREE.CurveUtils.interpolate;
        return new THREE.Vector2(o(e.x, n.x, r.x, i.x, t), o(e.y, n.y, r.y, i.y, t))
    }, THREE.EllipseCurve = function(t, e, n, r, i, o, a, s) {
        this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = a, this.aRotation = s || 0
    }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, THREE.EllipseCurve.prototype.getPoint = function(t) {
        0 > (n = this.aEndAngle - this.aStartAngle) && (n += 2 * Math.PI), n > 2 * Math.PI && (n -= 2 * Math.PI), n = !0 === this.aClockwise ? this.aEndAngle + (1 - t) * (2 * Math.PI - n) : this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(n);
        var e = this.aY + this.yRadius * Math.sin(n);
        if (0 !== this.aRotation) {
            var n = Math.cos(this.aRotation),
                r = Math.sin(this.aRotation),
                i = t;
            t = (i - this.aX) * n - (e - this.aY) * r + this.aX, e = (i - this.aX) * r + (e - this.aY) * n + this.aY
        }
        return new THREE.Vector2(t, e)
    }, THREE.ArcCurve = function(t, e, n, r, i, o) {
        THREE.EllipseCurve.call(this, t, e, n, n, r, i, o)
    }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, THREE.LineCurve3 = THREE.Curve.create(function(t, e) {
        this.v1 = t, this.v2 = e
    }, function(t) {
        var e = new THREE.Vector3;
        return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e
    }), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(t, e, n) {
        this.v0 = t, this.v1 = e, this.v2 = n
    }, function(t) {
        var e = THREE.ShapeUtils.b2;
        return new THREE.Vector3(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y), e(t, this.v0.z, this.v1.z, this.v2.z))
    }), THREE.CubicBezierCurve3 = THREE.Curve.create(function(t, e, n, r) {
        this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
    }, function(t) {
        var e = THREE.ShapeUtils.b3;
        return new THREE.Vector3(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
    }), THREE.SplineCurve3 = THREE.Curve.create(function(t) {
        console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 == t ? [] : t
    }, function(t) {
        t *= (i = this.points).length - 1, t -= o = Math.floor(t);
        var e = i[0 == o ? o : o - 1],
            n = i[o],
            r = i[o > i.length - 2 ? i.length - 1 : o + 1],
            i = i[o > i.length - 3 ? i.length - 1 : o + 2],
            o = THREE.CurveUtils.interpolate;
        return new THREE.Vector3(o(e.x, n.x, r.x, i.x, t), o(e.y, n.y, r.y, i.y, t), o(e.z, n.z, r.z, i.z, t))
    }), THREE.CatmullRomCurve3 = function() {
        function t() {}
        var e = new THREE.Vector3,
            n = new t,
            r = new t,
            i = new t;
        return t.prototype.init = function(t, e, n, r) {
            this.c0 = t, this.c1 = n, this.c2 = -3 * t + 3 * e - 2 * n - r, this.c3 = 2 * t - 2 * e + n + r
        }, t.prototype.initNonuniformCatmullRom = function(t, e, n, r, i, o, a) {
            t = ((e - t) / i - (n - t) / (i + o) + (n - e) / o) * o, r = ((n - e) / o - (r - e) / (o + a) + (r - n) / a) * o, this.init(e, n, t, r)
        }, t.prototype.initCatmullRom = function(t, e, n, r, i) {
            this.init(e, n, i * (n - t), i * (r - e))
        }, t.prototype.calc = function(t) {
            var e = t * t;
            return this.c0 + this.c1 * t + this.c2 * e + this.c3 * e * t
        }, THREE.Curve.create(function(t) {
            this.points = t || []
        }, function(t) {
            var o, a, s, u, h, c = this.points;
            if (2 > (a = c.length) && console.log("duh, you need at least 2 points"), t *= a - 1, 0 === (t -= o = Math.floor(t)) && o === a - 1 && (o = a - 2, t = 1), 0 === o ? (e.subVectors(c[0], c[1]).add(c[0]), s = e) : s = c[o - 1], u = c[o], h = c[o + 1], o + 2 < a ? c = c[o + 2] : (e.subVectors(c[a - 1], c[a - 2]).add(c[a - 2]), c = e), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                var l = "chordal" === this.type ? .5 : .25;
                a = Math.pow(s.distanceToSquared(u), l), o = Math.pow(u.distanceToSquared(h), l), l = Math.pow(h.distanceToSquared(c), l), 1e-4 > o && (o = 1), 1e-4 > a && (a = o), 1e-4 > l && (l = o), n.initNonuniformCatmullRom(s.x, u.x, h.x, c.x, a, o, l), r.initNonuniformCatmullRom(s.y, u.y, h.y, c.y, a, o, l), i.initNonuniformCatmullRom(s.z, u.z, h.z, c.z, a, o, l)
            } else "catmullrom" === this.type && (a = void 0 !== this.tension ? this.tension : .5, n.initCatmullRom(s.x, u.x, h.x, c.x, a), r.initCatmullRom(s.y, u.y, h.y, c.y, a), i.initCatmullRom(s.z, u.z, h.z, c.z, a));
            return new THREE.Vector3(n.calc(t), r.calc(t), i.calc(t))
        })
    }(), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(t) {
        this.points = void 0 == t ? [] : t
    }, function(t) {
        t *= (i = this.points).length - 0, t -= o = Math.floor(t);
        var e = i[((o = o + (0 < o ? 0 : (Math.floor(Math.abs(o) / i.length) + 1) * i.length)) - 1) % i.length],
            n = i[o % i.length],
            r = i[(o + 1) % i.length],
            i = i[(o + 2) % i.length],
            o = THREE.CurveUtils.interpolate;
        return new THREE.Vector3(o(e.x, n.x, r.x, i.x, t), o(e.y, n.y, r.y, i.y, t), o(e.z, n.z, r.z, i.z, t))
    }), THREE.BoxGeometry = function(t, e, n, r, i, o) {
        function a(t, e, n, r, i, o, a, u) {
            var h, c = s.widthSegments,
                l = s.heightSegments,
                p = i / 2,
                f = o / 2,
                d = s.vertices.length;
            "x" === t && "y" === e || "y" === t && "x" === e ? h = "z" : "x" === t && "z" === e || "z" === t && "x" === e ? (h = "y", l = s.depthSegments) : ("z" === t && "y" === e || "y" === t && "z" === e) && (h = "x", c = s.depthSegments);
            var E = c + 1,
                m = l + 1,
                g = i / c,
                v = o / l,
                y = new THREE.Vector3;
            for (y[h] = 0 < a ? 1 : -1, i = 0; i < m; i++)
                for (o = 0; o < E; o++) {
                    var T = new THREE.Vector3;
                    T[t] = (o * g - p) * n, T[e] = (i * v - f) * r, T[h] = a, s.vertices.push(T)
                }
            for (i = 0; i < l; i++)
                for (o = 0; o < c; o++) f = o + E * i, t = o + E * (i + 1), e = o + 1 + E * (i + 1), n = o + 1 + E * i, r = new THREE.Vector2(o / c, 1 - i / l), a = new THREE.Vector2(o / c, 1 - (i + 1) / l), h = new THREE.Vector2((o + 1) / c, 1 - (i + 1) / l), p = new THREE.Vector2((o + 1) / c, 1 - i / l), (f = new THREE.Face3(f + d, t + d, n + d)).normal.copy(y), f.vertexNormals.push(y.clone(), y.clone(), y.clone()), f.materialIndex = u, s.faces.push(f), s.faceVertexUvs[0].push([r, a, p]), (f = new THREE.Face3(t + d, e + d, n + d)).normal.copy(y), f.vertexNormals.push(y.clone(), y.clone(), y.clone()), f.materialIndex = u, s.faces.push(f), s.faceVertexUvs[0].push([a.clone(), h, p.clone()])
        }
        THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        }, this.widthSegments = r || 1, this.heightSegments = i || 1, this.depthSegments = o || 1;
        var s = this;
        i = e / 2, o = n / 2, a("z", "y", -1, -1, n, e, r = t / 2, 0), a("z", "y", 1, -1, n, e, -r, 1), a("x", "z", 1, 1, t, n, i, 2), a("x", "z", 1, -1, t, n, -i, 3), a("x", "y", 1, -1, t, e, o, 4), a("x", "y", -1, -1, t, e, -o, 5), this.mergeVertices()
    }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, THREE.BoxGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.BoxGeometry(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }, THREE.CubeGeometry = THREE.BoxGeometry, THREE.CircleGeometry = function(t, e, n, r) {
        THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        }, this.fromBufferGeometry(new THREE.CircleBufferGeometry(t, e, n, r))
    }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, THREE.CircleGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.CircleGeometry(t.radius, t.segments, t.thetaStart, t.thetaLength)
    }, THREE.CircleBufferGeometry = function(t, e, n, r) {
        THREE.BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var i = e + 2,
            o = new Float32Array(3 * i),
            a = new Float32Array(3 * i);
        i = new Float32Array(2 * i);
        a[2] = 1, i[0] = .5, i[1] = .5;
        for (var s = 0, u = 3, h = 2; s <= e; s++, u += 3, h += 2) {
            var c = n + s / e * r;
            o[u] = t * Math.cos(c), o[u + 1] = t * Math.sin(c), a[u + 2] = 1, i[h] = (o[u] / t + 1) / 2, i[h + 1] = (o[u + 1] / t + 1) / 2
        }
        for (n = [], u = 1; u <= e; u++) n.push(u, u + 1, 0);
        this.setIndex(new THREE.BufferAttribute(new Uint16Array(n), 1)), this.addAttribute("position", new THREE.BufferAttribute(o, 3)), this.addAttribute("normal", new THREE.BufferAttribute(a, 3)), this.addAttribute("uv", new THREE.BufferAttribute(i, 2)), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t)
    }, THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry, THREE.CircleBufferGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.CircleBufferGeometry(t.radius, t.segments, t.thetaStart, t.thetaLength)
    }, THREE.CylinderGeometry = function(t, e, n, r, i, o, a, s) {
        THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, n = void 0 !== n ? n : 100, r = r || 8, i = i || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var u, h, c = n / 2,
            l = [],
            p = [];
        for (h = 0; h <= i; h++) {
            var f = [],
                d = [],
                E = (g = h / i) * (e - t) + t;
            for (u = 0; u <= r; u++) {
                var m = u / r;
                (v = new THREE.Vector3).x = E * Math.sin(m * s + a), v.y = -g * n + c, v.z = E * Math.cos(m * s + a), this.vertices.push(v), f.push(this.vertices.length - 1), d.push(new THREE.Vector2(m, 1 - g))
            }
            l.push(f), p.push(d)
        }
        for (n = (e - t) / n, u = 0; u < r; u++)
            for (0 !== t ? (a = this.vertices[l[0][u]].clone(), s = this.vertices[l[0][u + 1]].clone()) : (a = this.vertices[l[1][u]].clone(), s = this.vertices[l[1][u + 1]].clone()), a.setY(Math.sqrt(a.x * a.x + a.z * a.z) * n).normalize(), s.setY(Math.sqrt(s.x * s.x + s.z * s.z) * n).normalize(), h = 0; h < i; h++) {
                f = l[h][u], d = l[h + 1][u];
                var g = l[h + 1][u + 1],
                    v = (E = l[h][u + 1], m = a.clone(), a.clone()),
                    y = s.clone(),
                    T = s.clone(),
                    R = p[h][u].clone(),
                    x = p[h + 1][u].clone(),
                    b = p[h + 1][u + 1].clone(),
                    H = p[h][u + 1].clone();
                this.faces.push(new THREE.Face3(f, d, E, [m, v, T])), this.faceVertexUvs[0].push([R, x, H]), this.faces.push(new THREE.Face3(d, g, E, [v.clone(), y, T.clone()])), this.faceVertexUvs[0].push([x.clone(), b, H.clone()])
            }
        if (!1 === o && 0 < t)
            for (this.vertices.push(new THREE.Vector3(0, c, 0)), u = 0; u < r; u++) f = l[0][u], d = l[0][u + 1], g = this.vertices.length - 1, m = new THREE.Vector3(0, 1, 0), v = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), R = p[0][u].clone(), x = p[0][u + 1].clone(), b = new THREE.Vector2(x.x, 0), this.faces.push(new THREE.Face3(f, d, g, [m, v, y], void 0, 1)), this.faceVertexUvs[0].push([R, x, b]);
        if (!1 === o && 0 < e)
            for (this.vertices.push(new THREE.Vector3(0, -c, 0)), u = 0; u < r; u++) f = l[i][u + 1], d = l[i][u], g = this.vertices.length - 1, m = new THREE.Vector3(0, -1, 0), v = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), R = p[i][u + 1].clone(), x = p[i][u].clone(), b = new THREE.Vector2(x.x, 1), this.faces.push(new THREE.Face3(f, d, g, [m, v, y], void 0, 2)), this.faceVertexUvs[0].push([R, x, b]);
        this.computeFaceNormals()
    }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, THREE.CylinderGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.CylinderGeometry(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }, THREE.EdgesGeometry = function(t, e) {
        function n(t, e) {
            return t - e
        }
        THREE.BufferGeometry.call(this);
        var r, i = Math.cos(THREE.Math.degToRad(void 0 !== e ? e : 1)),
            o = [0, 0],
            a = {},
            s = ["a", "b", "c"];
        t instanceof THREE.BufferGeometry ? (r = new THREE.Geometry).fromBufferGeometry(t) : r = t.clone(), r.mergeVertices(), r.computeFaceNormals();
        for (var u = r.vertices, h = 0, c = (r = r.faces).length; h < c; h++)
            for (var l = r[h], p = 0; 3 > p; p++) {
                o[0] = l[s[p]], o[1] = l[s[(p + 1) % 3]], o.sort(n);
                var f = o.toString();
                void 0 === a[f] ? a[f] = {
                    vert1: o[0],
                    vert2: o[1],
                    face1: h,
                    face2: void 0
                } : a[f].face2 = h
            }
        for (f in o = [], a)(void 0 === (s = a[f]).face2 || r[s.face1].normal.dot(r[s.face2].normal) <= i) && (h = u[s.vert1], o.push(h.x), o.push(h.y), o.push(h.z), h = u[s.vert2], o.push(h.x), o.push(h.y), o.push(h.z));
        this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(o), 3))
    }, THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry, THREE.ExtrudeGeometry = function(t, e) {
        void 0 !== t && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeFaceNormals())
    }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, THREE.ExtrudeGeometry.prototype.addShapeList = function(t, e) {
        for (var n = t.length, r = 0; r < n; r++) this.addShape(t[r], e)
    }, THREE.ExtrudeGeometry.prototype.addShape = function(t, e) {
        function n(t, e, n) {
            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
        }

        function r(t, e, n) {
            var r = 1,
                i = (r = t.x - e.x, t.y - e.y),
                o = n.x - t.x,
                a = n.y - t.y,
                s = r * r + i * i;
            if (Math.abs(r * a - i * o) > Number.EPSILON) {
                var u = Math.sqrt(s),
                    h = Math.sqrt(o * o + a * a);
                s = e.x - i / u;
                if (e = e.y + r / u, 2 >= (r = (n = s + r * (o = ((n.x - a / h - s) * a - (n.y + o / h - e) * o) / (r * a - i * o)) - t.x) * n + (t = e + i * o - t.y) * t)) return new THREE.Vector2(n, t);
                r = Math.sqrt(r / 2)
            } else t = !1, r > Number.EPSILON ? o > Number.EPSILON && (t = !0) : r < -Number.EPSILON ? o < -Number.EPSILON && (t = !0) : Math.sign(i) === Math.sign(a) && (t = !0), t ? (n = -i, t = r, r = Math.sqrt(s)) : (n = r, t = i, r = Math.sqrt(s / 2));
            return new THREE.Vector2(n / r, t / r)
        }

        function i(t, e) {
            var n, r;
            for (V = t.length; 0 <= --V;) {
                n = V, 0 > (r = V - 1) && (r = t.length - 1);
                var i = 0,
                    o = v + 2 * E;
                for (i = 0; i < o; i++) {
                    var a = (a = e + n + (s = F * i)) + w,
                        s = (s = e + r + s) + w,
                        u = (u = e + r + (h = F * (i + 1))) + w,
                        h = (h = e + n + h) + w;
                    _.faces.push(new THREE.Face3(a, s, h, null, null, 1)), _.faces.push(new THREE.Face3(s, u, h, null, null, 1)), a = R.generateSideWallUV(_, a, s, u, h), _.faceVertexUvs[0].push([a[0], a[1], a[3]]), _.faceVertexUvs[0].push([a[1], a[2], a[3]])
                }
            }
        }

        function o(t, e, n) {
            _.vertices.push(new THREE.Vector3(t, e, n))
        }

        function a(t, e, n) {
            t += w, e += w, n += w, _.faces.push(new THREE.Face3(t, e, n, null, null, 0)), t = R.generateTopUV(_, t, e, n), _.faceVertexUvs[0].push(t)
        }
        var s, u, h, c, l, p = void 0 !== e.amount ? e.amount : 100,
            f = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            d = void 0 !== e.bevelSize ? e.bevelSize : f - 2,
            E = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
            m = void 0 === e.bevelEnabled || e.bevelEnabled,
            g = void 0 !== e.curveSegments ? e.curveSegments : 12,
            v = void 0 !== e.steps ? e.steps : 1,
            y = e.extrudePath,
            T = !1,
            R = void 0 !== e.UVGenerator ? e.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
        y && (s = y.getSpacedPoints(v), T = !0, m = !1, u = void 0 !== e.frames ? e.frames : new THREE.TubeGeometry.FrenetFrames(y, v, !1), h = new THREE.Vector3, c = new THREE.Vector3, l = new THREE.Vector3), m || (d = f = E = 0);
        var x, b, H, _ = this,
            w = this.vertices.length,
            M = (g = (y = t.extractPoints(g)).shape, y.holes);
        if (y = !THREE.ShapeUtils.isClockWise(g)) {
            for (g = g.reverse(), b = 0, H = M.length; b < H; b++) x = M[b], THREE.ShapeUtils.isClockWise(x) && (M[b] = x.reverse());
            y = !1
        }
        var S = THREE.ShapeUtils.triangulateShape(g, M),
            A = g;
        for (b = 0, H = M.length; b < H; b++) x = M[b], g = g.concat(x);
        var C, L, k, P, D, N, F = g.length,
            O = S.length,
            V = (y = [], 0);
        for (C = (k = A.length) - 1, L = V + 1; V < k; V++, C++, L++) C === k && (C = 0), L === k && (L = 0), y[V] = r(A[V], A[C], A[L]);
        var U, B = [],
            I = y.concat();
        for (b = 0, H = M.length; b < H; b++) {
            for (x = M[b], U = [], V = 0, C = (k = x.length) - 1, L = V + 1; V < k; V++, C++, L++) C === k && (C = 0), L === k && (L = 0), U[V] = r(x[V], x[C], x[L]);
            B.push(U), I = I.concat(U)
        }
        for (C = 0; C < E; C++) {
            for (P = f * (1 - (k = C / E)), L = d * Math.sin(k * Math.PI / 2), V = 0, k = A.length; V < k; V++) o((D = n(A[V], y[V], L)).x, D.y, -P);
            for (b = 0, H = M.length; b < H; b++)
                for (x = M[b], U = B[b], V = 0, k = x.length; V < k; V++) o((D = n(x[V], U[V], L)).x, D.y, -P)
        }
        for (L = d, V = 0; V < F; V++) D = m ? n(g[V], I[V], L) : g[V], T ? (c.copy(u.normals[0]).multiplyScalar(D.x), h.copy(u.binormals[0]).multiplyScalar(D.y), l.copy(s[0]).add(c).add(h), o(l.x, l.y, l.z)) : o(D.x, D.y, 0);
        for (k = 1; k <= v; k++)
            for (V = 0; V < F; V++) D = m ? n(g[V], I[V], L) : g[V], T ? (c.copy(u.normals[k]).multiplyScalar(D.x), h.copy(u.binormals[k]).multiplyScalar(D.y), l.copy(s[k]).add(c).add(h), o(l.x, l.y, l.z)) : o(D.x, D.y, p / v * k);
        for (C = E - 1; 0 <= C; C--) {
            for (P = f * (1 - (k = C / E)), L = d * Math.sin(k * Math.PI / 2), V = 0, k = A.length; V < k; V++) o((D = n(A[V], y[V], L)).x, D.y, p + P);
            for (b = 0, H = M.length; b < H; b++)
                for (x = M[b], U = B[b], V = 0, k = x.length; V < k; V++) D = n(x[V], U[V], L), T ? o(D.x, D.y + s[v - 1].y, s[v - 1].x + P) : o(D.x, D.y, p + P)
        }! function() {
            if (m) {
                var t;
                for (t = 0 * F, V = 0; V < O; V++) a((N = S[V])[2] + t, N[1] + t, N[0] + t);
                for (t = v + 2 * E, t *= F, V = 0; V < O; V++) a((N = S[V])[0] + t, N[1] + t, N[2] + t)
            } else {
                for (V = 0; V < O; V++) a((N = S[V])[2], N[1], N[0]);
                for (V = 0; V < O; V++) a((N = S[V])[0] + F * v, N[1] + F * v, N[2] + F * v)
            }
        }(),
        function() {
            var t = 0;
            for (i(A, t), t += A.length, b = 0, H = M.length; b < H; b++) i(x = M[b], t), t += x.length
        }()
    }, THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(t, e, n, r) {
            return e = (t = t.vertices)[e], n = t[n], r = t[r], [new THREE.Vector2(e.x, e.y), new THREE.Vector2(n.x, n.y), new THREE.Vector2(r.x, r.y)]
        },
        generateSideWallUV: function(t, e, n, r, i) {
            return e = (t = t.vertices)[e], n = t[n], r = t[r], i = t[i], .01 > Math.abs(e.y - n.y) ? [new THREE.Vector2(e.x, 1 - e.z), new THREE.Vector2(n.x, 1 - n.z), new THREE.Vector2(r.x, 1 - r.z), new THREE.Vector2(i.x, 1 - i.z)] : [new THREE.Vector2(e.y, 1 - e.z), new THREE.Vector2(n.y, 1 - n.z), new THREE.Vector2(r.y, 1 - r.z), new THREE.Vector2(i.y, 1 - i.z)]
        }
    }, THREE.ShapeGeometry = function(t, e) {
        THREE.Geometry.call(this), this.type = "ShapeGeometry", !1 === Array.isArray(t) && (t = [t]), this.addShapeList(t, e), this.computeFaceNormals()
    }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, THREE.ShapeGeometry.prototype.addShapeList = function(t, e) {
        for (var n = 0, r = t.length; n < r; n++) this.addShape(t[n], e);
        return this
    }, THREE.ShapeGeometry.prototype.addShape = function(t, e) {
        void 0 === e && (e = {});
        var n, r, i, o = e.material,
            a = void 0 === e.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : e.UVGenerator,
            s = this.vertices.length,
            u = (n = t.extractPoints(void 0 !== e.curveSegments ? e.curveSegments : 12)).shape,
            h = n.holes;
        if (!THREE.ShapeUtils.isClockWise(u))
            for (u = u.reverse(), n = 0, r = h.length; n < r; n++) i = h[n], THREE.ShapeUtils.isClockWise(i) && (h[n] = i.reverse());
        var c = THREE.ShapeUtils.triangulateShape(u, h);
        for (n = 0, r = h.length; n < r; n++) i = h[n], u = u.concat(i);
        for (h = u.length, r = c.length, n = 0; n < h; n++) i = u[n], this.vertices.push(new THREE.Vector3(i.x, i.y, 0));
        for (n = 0; n < r; n++) u = (h = c[n])[0] + s, i = h[1] + s, h = h[2] + s, this.faces.push(new THREE.Face3(u, i, h, null, null, o)), this.faceVertexUvs[0].push(a.generateTopUV(this, u, i, h))
    }, THREE.LatheGeometry = function(t, e, n, r) {
        THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        }, e = e || 12, n = n || 0, r = r || 2 * Math.PI;
        for (var i = 1 / (t.length - 1), o = 1 / e, a = 0, s = e; a <= s; a++)
            for (var u = n + a * o * r, h = Math.cos(u), c = Math.sin(u), l = (u = 0, t.length); u < l; u++) {
                var p = t[u];
                (f = new THREE.Vector3).x = h * p.x - c * p.y, f.y = c * p.x + h * p.y, f.z = p.z, this.vertices.push(f)
            }
        for (n = t.length, a = 0, s = e; a < s; a++)
            for (u = 0, l = t.length - 1; u < l; u++) {
                e = c = u + n * a, r = c + n;
                h = c + 1 + n, c = c + 1;
                var f, d = (p = a * o) + o,
                    E = (f = u * i) + i;
                this.faces.push(new THREE.Face3(e, r, c)), this.faceVertexUvs[0].push([new THREE.Vector2(p, f), new THREE.Vector2(d, f), new THREE.Vector2(p, E)]), this.faces.push(new THREE.Face3(r, h, c)), this.faceVertexUvs[0].push([new THREE.Vector2(d, f), new THREE.Vector2(d, E), new THREE.Vector2(p, E)])
            }
        this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, THREE.PlaneGeometry = function(t, e, n, r) {
        THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(t, e, n, r))
    }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry, THREE.PlaneGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.PlaneGeometry(t.width, t.height, t.widthSegments, t.heightSegments)
    }, THREE.PlaneBufferGeometry = function(t, e, n, r) {
        THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        };
        var i = t / 2,
            o = e / 2,
            a = (n = Math.floor(n) || 1) + 1,
            s = (r = Math.floor(r) || 1) + 1,
            u = t / n,
            h = e / r;
        e = new Float32Array(a * s * 3), t = new Float32Array(a * s * 3);
        for (var c = new Float32Array(a * s * 2), l = 0, p = 0, f = 0; f < s; f++)
            for (var d = f * h - o, E = 0; E < a; E++) e[l] = E * u - i, e[l + 1] = -d, t[l + 2] = 1, c[p] = E / n, c[p + 1] = 1 - f / r, l += 3, p += 2;
        for (l = 0, i = new(65535 < e.length / 3 ? Uint32Array : Uint16Array)(n * r * 6), f = 0; f < r; f++)
            for (E = 0; E < n; E++) o = E + a * (f + 1), s = E + 1 + a * (f + 1), u = E + 1 + a * f, i[l] = E + a * f, i[l + 1] = o, i[l + 2] = u, i[l + 3] = o, i[l + 4] = s, i[l + 5] = u, l += 6;
        this.setIndex(new THREE.BufferAttribute(i, 1)), this.addAttribute("position", new THREE.BufferAttribute(e, 3)), this.addAttribute("normal", new THREE.BufferAttribute(t, 3)), this.addAttribute("uv", new THREE.BufferAttribute(c, 2))
    }, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.PlaneBufferGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.PlaneBufferGeometry(t.width, t.height, t.widthSegments, t.heightSegments)
    }, THREE.RingGeometry = function(t, e, n, r, i, o) {
        THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, t = t || 0, e = e || 50, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s = [],
            u = t,
            h = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 8);
        for (t = 0; t < r + 1; t++) {
            for (a = 0; a < n + 1; a++) {
                var c = new THREE.Vector3,
                    l = i + a / n * o;
                c.x = u * Math.cos(l), c.y = u * Math.sin(l), this.vertices.push(c), s.push(new THREE.Vector2((c.x / e + 1) / 2, (c.y / e + 1) / 2))
            }
            u += h
        }
        for (e = new THREE.Vector3(0, 0, 1), t = 0; t < r; t++)
            for (i = t * (n + 1), a = 0; a < n; a++) o = l = a + i, h = l + n + 1, c = l + n + 2, this.faces.push(new THREE.Face3(o, h, c, [e.clone(), e.clone(), e.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[h].clone(), s[c].clone()]), o = l, h = l + n + 2, c = l + 1, this.faces.push(new THREE.Face3(o, h, c, [e.clone(), e.clone(), e.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[h].clone(), s[c].clone()]);
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, u)
    }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, THREE.RingGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.RingGeometry(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
    }, THREE.SphereGeometry = function(t, e, n, r, i, o, a) {
        THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new THREE.SphereBufferGeometry(t, e, n, r, i, o, a))
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, THREE.SphereGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.SphereGeometry(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }, THREE.SphereBufferGeometry = function(t, e, n, r, i, o, a) {
        THREE.BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI;
        for (var s = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI), u = (e + 1) * (n + 1), h = new THREE.BufferAttribute(new Float32Array(3 * u), 3), c = new THREE.BufferAttribute(new Float32Array(3 * u), 3), l = (u = new THREE.BufferAttribute(new Float32Array(2 * u), 2), 0), p = [], f = new THREE.Vector3, d = 0; d <= n; d++) {
            for (var E = [], m = d / n, g = 0; g <= e; g++) {
                var v = g / e,
                    y = -t * Math.cos(r + v * i) * Math.sin(o + m * a),
                    T = t * Math.cos(o + m * a),
                    R = t * Math.sin(r + v * i) * Math.sin(o + m * a);
                f.set(y, T, R).normalize(), h.setXYZ(l, y, T, R), c.setXYZ(l, f.x, f.y, f.z), u.setXY(l, v, 1 - m), E.push(l), l++
            }
            p.push(E)
        }
        for (r = [], d = 0; d < n; d++)
            for (g = 0; g < e; g++) i = p[d][g + 1], a = p[d][g], l = p[d + 1][g], f = p[d + 1][g + 1], (0 !== d || 0 < o) && r.push(i, a, f), (d !== n - 1 || s < Math.PI) && r.push(a, l, f);
        this.setIndex(new(65535 < h.count ? THREE.Uint32Attribute : THREE.Uint16Attribute)(r, 1)), this.addAttribute("position", h), this.addAttribute("normal", c), this.addAttribute("uv", u), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t)
    }, THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry, THREE.SphereBufferGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.SphereBufferGeometry(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }, THREE.TorusGeometry = function(t, e, n, r, i) {
        THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, t = t || 100, e = e || 40, n = n || 8, r = r || 6, i = i || 2 * Math.PI;
        for (var o = new THREE.Vector3, a = [], s = [], u = 0; u <= n; u++)
            for (var h = 0; h <= r; h++) {
                var c = h / r * i,
                    l = u / n * Math.PI * 2;
                o.x = t * Math.cos(c), o.y = t * Math.sin(c);
                var p = new THREE.Vector3;
                p.x = (t + e * Math.cos(l)) * Math.cos(c), p.y = (t + e * Math.cos(l)) * Math.sin(c), p.z = e * Math.sin(l), this.vertices.push(p), a.push(new THREE.Vector2(h / r, u / n)), s.push(p.clone().sub(o).normalize())
            }
        for (u = 1; u <= n; u++)
            for (h = 1; h <= r; h++) t = (r + 1) * u + h - 1, e = (r + 1) * (u - 1) + h - 1, i = (r + 1) * (u - 1) + h, o = (r + 1) * u + h, c = new THREE.Face3(t, e, o, [s[t].clone(), s[e].clone(), s[o].clone()]), this.faces.push(c), this.faceVertexUvs[0].push([a[t].clone(), a[e].clone(), a[o].clone()]), c = new THREE.Face3(e, i, o, [s[e].clone(), s[i].clone(), s[o].clone()]), this.faces.push(c), this.faceVertexUvs[0].push([a[e].clone(), a[i].clone(), a[o].clone()]);
        this.computeFaceNormals()
    }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, THREE.TorusGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.TorusGeometry(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
    }, THREE.TorusKnotGeometry = function(t, e, n, r, i, o, a) {
        function s(t, e, n, r, i) {
            var o = Math.cos(t),
                a = Math.sin(t);
            return t *= e / n, o *= r * (2 + (e = Math.cos(t))) * .5, a = r * (2 + e) * a * .5, r = i * r * Math.sin(t) * .5, new THREE.Vector3(o, a, r)
        }
        THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            p: i,
            q: o,
            heightScale: a
        }, t = t || 100, e = e || 40, n = n || 64, r = r || 8, i = i || 2, o = o || 3, a = a || 1;
        for (var u = Array(n), h = new THREE.Vector3, c = new THREE.Vector3, l = new THREE.Vector3, p = 0; p < n; ++p) {
            u[p] = Array(r);
            var f = s(d = p / n * 2 * i * Math.PI, o, i, t, a),
                d = s(d + .01, o, i, t, a);
            for (h.subVectors(d, f), c.addVectors(d, f), l.crossVectors(h, c), c.crossVectors(l, h), l.normalize(), c.normalize(), d = 0; d < r; ++d) {
                var E = d / r * 2 * Math.PI,
                    m = -e * Math.cos(E),
                    g = (E = e * Math.sin(E), new THREE.Vector3);
                g.x = f.x + m * c.x + E * l.x, g.y = f.y + m * c.y + E * l.y, g.z = f.z + m * c.z + E * l.z, u[p][d] = this.vertices.push(g) - 1
            }
        }
        for (p = 0; p < n; ++p)
            for (d = 0; d < r; ++d) i = (p + 1) % n, o = (d + 1) % r, t = u[p][d], e = u[i][d], i = u[i][o], o = u[p][o], a = new THREE.Vector2(p / n, d / r), h = new THREE.Vector2((p + 1) / n, d / r), c = new THREE.Vector2((p + 1) / n, (d + 1) / r), l = new THREE.Vector2(p / n, (d + 1) / r), this.faces.push(new THREE.Face3(t, e, o)), this.faceVertexUvs[0].push([a, h, l]), this.faces.push(new THREE.Face3(e, i, o)), this.faceVertexUvs[0].push([h.clone(), c, l.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TorusKnotGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.TorusKnotGeometry(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.p, t.q, t.heightScale)
    }, THREE.TubeGeometry = function(t, e, n, r, i, o) {
        THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            segments: e,
            radius: n,
            radialSegments: r,
            closed: i,
            taper: o
        }, e = e || 64, n = n || 1, r = r || 8, i = i || !1, o = o || THREE.TubeGeometry.NoTaper;
        var a, s, u, h, c, l, p, f, d, E, m = [],
            g = e + 1,
            v = new THREE.Vector3;
        for (d = (f = new THREE.TubeGeometry.FrenetFrames(t, e, i)).normals, E = f.binormals, this.tangents = f.tangents, this.normals = d, this.binormals = E, f = 0; f < g; f++)
            for (m[f] = [], u = f / (g - 1), p = t.getPointAt(u), a = d[f], s = E[f], c = n * o(u), u = 0; u < r; u++) h = u / r * 2 * Math.PI, l = -c * Math.cos(h), h = c * Math.sin(h), v.copy(p), v.x += l * a.x + h * s.x, v.y += l * a.y + h * s.y, v.z += l * a.z + h * s.z, m[f][u] = this.vertices.push(new THREE.Vector3(v.x, v.y, v.z)) - 1;
        for (f = 0; f < e; f++)
            for (u = 0; u < r; u++) o = i ? (f + 1) % e : f + 1, g = (u + 1) % r, t = m[f][u], n = m[o][u], o = m[o][g], g = m[f][g], v = new THREE.Vector2(f / e, u / r), d = new THREE.Vector2((f + 1) / e, u / r), E = new THREE.Vector2((f + 1) / e, (u + 1) / r), a = new THREE.Vector2(f / e, (u + 1) / r), this.faces.push(new THREE.Face3(t, n, g)), this.faceVertexUvs[0].push([v, d, a]), this.faces.push(new THREE.Face3(n, o, g)), this.faceVertexUvs[0].push([d.clone(), E, a.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, THREE.TubeGeometry.prototype.clone = function() {
        return new this.constructor(this.parameters.path, this.parameters.segments, this.parameters.radius, this.parameters.radialSegments, this.parameters.closed, this.parameters.taper)
    }, THREE.TubeGeometry.NoTaper = function(t) {
        return 1
    }, THREE.TubeGeometry.SinusoidalTaper = function(t) {
        return Math.sin(Math.PI * t)
    }, THREE.TubeGeometry.FrenetFrames = function(t, e, n) {
        var r, i, o, a = new THREE.Vector3,
            s = [],
            u = [],
            h = [],
            c = new THREE.Vector3,
            l = new THREE.Matrix4;
        for (e += 1, this.tangents = s, this.normals = u, this.binormals = h, r = 0; r < e; r++) i = r / (e - 1), s[r] = t.getTangentAt(i), s[r].normalize();
        for (u[0] = new THREE.Vector3, h[0] = new THREE.Vector3, t = Number.MAX_VALUE, r = Math.abs(s[0].x), i = Math.abs(s[0].y), o = Math.abs(s[0].z), r <= t && (t = r, a.set(1, 0, 0)), i <= t && (t = i, a.set(0, 1, 0)), o <= t && a.set(0, 0, 1), c.crossVectors(s[0], a).normalize(), u[0].crossVectors(s[0], c), h[0].crossVectors(s[0], u[0]), r = 1; r < e; r++) u[r] = u[r - 1].clone(), h[r] = h[r - 1].clone(), c.crossVectors(s[r - 1], s[r]), c.length() > Number.EPSILON && (c.normalize(), a = Math.acos(THREE.Math.clamp(s[r - 1].dot(s[r]), -1, 1)), u[r].applyMatrix4(l.makeRotationAxis(c, a))), h[r].crossVectors(s[r], u[r]);
        if (n)
            for (a = Math.acos(THREE.Math.clamp(u[0].dot(u[e - 1]), -1, 1)), a /= e - 1, 0 < s[0].dot(c.crossVectors(u[0], u[e - 1])) && (a = -a), r = 1; r < e; r++) u[r].applyMatrix4(l.makeRotationAxis(s[r], a * r)), h[r].crossVectors(s[r], u[r])
    }, THREE.PolyhedronGeometry = function(t, e, n, r) {
        function i(t) {
            var e = t.normalize().clone();
            e.index = u.vertices.push(e) - 1;
            var n = Math.atan2(t.z, -t.x) / 2 / Math.PI + .5;
            return t = Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5, e.uv = new THREE.Vector2(n, 1 - t), e
        }

        function o(t, e, n, r) {
            r = new THREE.Face3(t.index, e.index, n.index, [t.clone(), e.clone(), n.clone()], void 0, r), u.faces.push(r), m.copy(t).add(e).add(n).divideScalar(3), r = Math.atan2(m.z, -m.x), u.faceVertexUvs[0].push([s(t.uv, t, r), s(e.uv, e, r), s(n.uv, n, r)])
        }

        function a(t, e) {
            for (var n = Math.pow(2, e), r = i(u.vertices[t.a]), a = i(u.vertices[t.b]), s = i(u.vertices[t.c]), h = [], c = t.materialIndex, l = 0; l <= n; l++) {
                h[l] = [];
                for (var p = i(r.clone().lerp(s, l / n)), f = i(a.clone().lerp(s, l / n)), d = n - l, E = 0; E <= d; E++) h[l][E] = 0 === E && l === n ? p : i(p.clone().lerp(f, E / d))
            }
            for (l = 0; l < n; l++)
                for (E = 0; E < 2 * (n - l) - 1; E++) r = Math.floor(E / 2), 0 == E % 2 ? o(h[l][r + 1], h[l + 1][r], h[l][r], c) : o(h[l][r + 1], h[l + 1][r + 1], h[l + 1][r], c)
        }

        function s(t, e, n) {
            return 0 > n && 1 === t.x && (t = new THREE.Vector2(t.x - 1, t.y)), 0 === e.x && 0 === e.z && (t = new THREE.Vector2(n / 2 / Math.PI + .5, t.y)), t.clone()
        }
        THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        }, n = n || 1, r = r || 0;
        for (var u = this, h = 0, c = t.length; h < c; h += 3) i(new THREE.Vector3(t[h], t[h + 1], t[h + 2]));
        t = this.vertices;
        var l = [],
            p = h = 0;
        for (c = e.length; h < c; h += 3, p++) {
            var f = t[e[h]],
                d = t[e[h + 1]],
                E = t[e[h + 2]];
            l[p] = new THREE.Face3(f.index, d.index, E.index, [f.clone(), d.clone(), E.clone()], void 0, p)
        }
        var m = new THREE.Vector3;
        for (h = 0, c = l.length; h < c; h++) a(l[h], r);
        for (h = 0, c = this.faceVertexUvs[0].length; h < c; h++) r = (e = this.faceVertexUvs[0][h])[0].x, t = e[1].x, l = e[2].x, p = Math.max(r, t, l), f = Math.min(r, t, l), .9 < p && .1 > f && (.2 > r && (e[0].x += 1), .2 > t && (e[1].x += 1), .2 > l && (e[2].x += 1));
        for (h = 0, c = this.vertices.length; h < c; h++) this.vertices[h].multiplyScalar(n);
        this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, n)
    }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.PolyhedronGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.PolyhedronGeometry(t.vertices, t.indices, t.radius, t.detail)
    }, THREE.DodecahedronGeometry = function(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n;
        THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }, THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.DodecahedronGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.DodecahedronGeometry(t.radius, t.detail)
    }, THREE.IcosahedronGeometry = function(t, e) {
        var n = (1 + Math.sqrt(5)) / 2;
        THREE.PolyhedronGeometry.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.IcosahedronGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.IcosahedronGeometry(t.radius, t.detail)
    }, THREE.OctahedronGeometry = function(t, e) {
        THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }, THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.OctahedronGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.OctahedronGeometry(t.radius, t.detail)
    }, THREE.TetrahedronGeometry = function(t, e) {
        THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.TetrahedronGeometry.prototype.clone = function() {
        var t = this.parameters;
        return new THREE.TetrahedronGeometry(t.radius, t.detail)
    }, THREE.ParametricGeometry = function(t, e, n) {
        THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        var r, i, o, a, s, u, h, c, l = this.vertices,
            p = this.faces,
            f = this.faceVertexUvs[0],
            d = e + 1;
        for (r = 0; r <= n; r++)
            for (a = r / n, i = 0; i <= e; i++) o = t(o = i / e, a), l.push(o);
        for (r = 0; r < n; r++)
            for (i = 0; i < e; i++) t = r * d + i, l = r * d + i + 1, a = (r + 1) * d + i + 1, o = (r + 1) * d + i, s = new THREE.Vector2(i / e, r / n), u = new THREE.Vector2((i + 1) / e, r / n), h = new THREE.Vector2((i + 1) / e, (r + 1) / n), c = new THREE.Vector2(i / e, (r + 1) / n), p.push(new THREE.Face3(t, l, o)), f.push([s, u, c]), p.push(new THREE.Face3(l, a, o)), f.push([u.clone(), h, c.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.WireframeGeometry = function(t) {
        function e(t, e) {
            return t - e
        }
        THREE.BufferGeometry.call(this);
        var n = [0, 0],
            r = {},
            i = ["a", "b", "c"];
        if (t instanceof THREE.Geometry) {
            var o = t.vertices,
                a = t.faces,
                s = 0,
                u = new Uint32Array(6 * a.length);
            t = 0;
            for (var h = a.length; t < h; t++)
                for (var c = a[t], l = 0; 3 > l; l++) {
                    n[0] = c[i[l]], n[1] = c[i[(l + 1) % 3]], n.sort(e);
                    var p = n.toString();
                    void 0 === r[p] && (u[2 * s] = n[0], u[2 * s + 1] = n[1], r[p] = !0, s++)
                }
            for (n = new Float32Array(6 * s), t = 0, h = s; t < h; t++)
                for (l = 0; 2 > l; l++) r = o[u[2 * t + l]], n[(s = 6 * t + 3 * l) + 0] = r.x, n[s + 1] = r.y, n[s + 2] = r.z;
            this.addAttribute("position", new THREE.BufferAttribute(n, 3))
        } else if (t instanceof THREE.BufferGeometry) {
            if (null !== t.index) {
                for (h = t.index.array, o = t.attributes.position, s = 0, 0 === (i = t.drawcalls).length && t.addGroup(0, h.length), u = new Uint32Array(2 * h.length), a = 0, c = i.length; a < c; ++a) {
                    l = (t = i[a]).start, p = t.count, t = l;
                    for (var f = l + p; t < f; t += 3)
                        for (l = 0; 3 > l; l++) n[0] = h[t + l], n[1] = h[t + (l + 1) % 3], n.sort(e), void 0 === r[p = n.toString()] && (u[2 * s] = n[0], u[2 * s + 1] = n[1], r[p] = !0, s++)
                }
                for (n = new Float32Array(6 * s), t = 0, h = s; t < h; t++)
                    for (l = 0; 2 > l; l++) s = 6 * t + 3 * l, r = u[2 * t + l], n[s + 0] = o.getX(r), n[s + 1] = o.getY(r), n[s + 2] = o.getZ(r)
            } else
                for (u = (s = (o = t.attributes.position.array).length / 3) / 3, n = new Float32Array(6 * s), t = 0, h = u; t < h; t++)
                    for (l = 0; 3 > l; l++) u = 9 * t + 3 * l, n[(s = 18 * t + 6 * l) + 0] = o[u], n[s + 1] = o[u + 1], n[s + 2] = o[u + 2], r = 9 * t + (l + 1) % 3 * 3, n[s + 3] = o[r], n[s + 4] = o[r + 1], n[s + 5] = o[r + 2];
            this.addAttribute("position", new THREE.BufferAttribute(n, 3))
        }
    }, THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry, THREE.AxisHelper = function(t) {
        t = t || 1;
        var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]),
            n = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
        (t = new THREE.BufferGeometry).addAttribute("position", new THREE.BufferAttribute(e, 3)), t.addAttribute("color", new THREE.BufferAttribute(n, 3)), e = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        }), THREE.LineSegments.call(this, t, e)
    }, THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, THREE.ArrowHelper = function() {
        var t = new THREE.Geometry;
        t.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var e = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
        return e.translate(0, -.5, 0),
            function(n, r, i, o, a, s) {
                THREE.Object3D.call(this), void 0 === o && (o = 16776960), void 0 === i && (i = 1), void 0 === a && (a = .2 * i), void 0 === s && (s = .2 * a), this.position.copy(r), a < i && (this.line = new THREE.Line(t, new THREE.LineBasicMaterial({
                    color: o
                })), this.line.matrixAutoUpdate = !1, this.add(this.line)), this.cone = new THREE.Mesh(e, new THREE.MeshBasicMaterial({
                    color: o
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(n), this.setLength(i, a, s)
            }
    }(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, THREE.ArrowHelper.prototype.setDirection = function() {
        var t, e = new THREE.Vector3;
        return function(n) {
            .99999 < n.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > n.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
        }
    }(), THREE.ArrowHelper.prototype.setLength = function(t, e, n) {
        void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), e < t && (this.line.scale.set(1, t - e, 1), this.line.updateMatrix()), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
    }, THREE.ArrowHelper.prototype.setColor = function(t) {
        void 0 !== this.line && this.line.material.color.set(t), this.cone.material.color.set(t)
    }, THREE.BoxHelper = function(t) {
        var e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24),
            r = new THREE.BufferGeometry;
        r.setIndex(new THREE.BufferAttribute(e, 1)), r.addAttribute("position", new THREE.BufferAttribute(n, 3)), THREE.LineSegments.call(this, r, new THREE.LineBasicMaterial({
            color: 16776960
        })), void 0 !== t && this.update(t)
    }, THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, THREE.BoxHelper.prototype.update = function() {
        var t = new THREE.Box3;
        return function(e) {
            if (t.setFromObject(e), !t.empty()) {
                e = t.min;
                var n = t.max,
                    r = this.geometry.attributes.position,
                    i = r.array;
                i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), THREE.BoundingBoxHelper = function(t, e) {
        var n = void 0 !== e ? e : 8947848;
        this.object = t, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
            color: n,
            wireframe: !0
        }))
    }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, THREE.BoundingBoxHelper.prototype.update = function() {
        this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
    }, THREE.CameraHelper = function(t) {
        function e(t, e, r) {
            n(t, r), n(e, r)
        }

        function n(t, e) {
            r.vertices.push(new THREE.Vector3), r.colors.push(new THREE.Color(e)), void 0 === o[t] && (o[t] = []), o[t].push(r.vertices.length - 1)
        }
        var r = new THREE.Geometry,
            i = new THREE.LineBasicMaterial({
                color: 16777215,
                vertexColors: THREE.FaceColors
            }),
            o = {};
        e("n1", "n2", 16755200), e("n2", "n4", 16755200), e("n4", "n3", 16755200), e("n3", "n1", 16755200), e("f1", "f2", 16755200), e("f2", "f4", 16755200), e("f4", "f3", 16755200), e("f3", "f1", 16755200), e("n1", "f1", 16755200), e("n2", "f2", 16755200), e("n3", "f3", 16755200), e("n4", "f4", 16755200), e("p", "n1", 16711680), e("p", "n2", 16711680), e("p", "n3", 16711680), e("p", "n4", 16711680), e("u1", "u2", 43775), e("u2", "u3", 43775), e("u3", "u1", 43775), e("c", "t", 16777215), e("p", "c", 3355443), e("cn1", "cn2", 3355443), e("cn3", "cn4", 3355443), e("cf1", "cf2", 3355443), e("cf3", "cf4", 3355443), THREE.LineSegments.call(this, r, i), this.camera = t, this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }, THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
THREE.CameraHelper.prototype.update = function() {
    function t(t, o, a, s) {
        if (r.set(o, a, s).unproject(i), void 0 !== (t = n[t]))
            for (o = 0, a = t.length; o < a; o++) e.vertices[t[o]].copy(r)
    }
    var e, n, r = new THREE.Vector3,
        i = new THREE.Camera;
    return function() {
        e = this.geometry, n = this.pointMap, i.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.verticesNeedUpdate = !0
    }
}(), THREE.DirectionalLightHelper = function(t, e) {
    THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, e = e || 1;
    var n = new THREE.Geometry;
    n.vertices.push(new THREE.Vector3(-e, e, 0), new THREE.Vector3(e, e, 0), new THREE.Vector3(e, -e, 0), new THREE.Vector3(-e, -e, 0), new THREE.Vector3(-e, e, 0));
    var r = new THREE.LineBasicMaterial({
        fog: !1
    });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(n, r), this.add(this.lightPlane), (n = new THREE.Geometry).vertices.push(new THREE.Vector3, new THREE.Vector3), (r = new THREE.LineBasicMaterial({
        fog: !1
    })).color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(n, r), this.add(this.targetLine), this.update()
}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
}, THREE.DirectionalLightHelper.prototype.update = function() {
    var t = new THREE.Vector3,
        e = new THREE.Vector3,
        n = new THREE.Vector3;
    return function() {
        t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t), this.lightPlane.lookAt(n), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(n), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
    }
}(), THREE.EdgesHelper = function(t, e, n) {
    e = void 0 !== e ? e : 16777215, THREE.LineSegments.call(this, new THREE.EdgesGeometry(t.geometry, n), new THREE.LineBasicMaterial({
        color: e
    })), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
}, THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, THREE.FaceNormalsHelper = function(t, e, n, r) {
    this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== n ? n : 16776960, r = void 0 !== r ? r : 1, e = 0, (n = this.object.geometry) instanceof THREE.Geometry ? e = n.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), n = new THREE.BufferGeometry, e = new THREE.Float32Attribute(6 * e, 3), n.addAttribute("position", e), THREE.LineSegments.call(this, n, new THREE.LineBasicMaterial({
        color: t,
        linewidth: r
    })), this.matrixAutoUpdate = !1, this.update()
}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, THREE.FaceNormalsHelper.prototype.update = function() {
    var t = new THREE.Vector3,
        e = new THREE.Vector3,
        n = new THREE.Matrix3;
    return function() {
        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
        for (var r, i = this.object.matrixWorld, o = this.geometry.attributes.position, a = (r = this.object.geometry).vertices, s = 0, u = 0, h = (r = r.faces).length; u < h; u++) {
            var c = r[u],
                l = c.normal;
            t.copy(a[c.a]).add(a[c.b]).add(a[c.c]).divideScalar(3).applyMatrix4(i), e.copy(l).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(s, t.x, t.y, t.z), s += 1, o.setXYZ(s, e.x, e.y, e.z), s += 1
        }
        return o.needsUpdate = !0, this
    }
}(), THREE.GridHelper = function(t, e) {
    var n = new THREE.Geometry,
        r = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        });
    this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
    for (var i = -t; i <= t; i += e) {
        n.vertices.push(new THREE.Vector3(-t, 0, i), new THREE.Vector3(t, 0, i), new THREE.Vector3(i, 0, -t), new THREE.Vector3(i, 0, t));
        var o = 0 === i ? this.color1 : this.color2;
        n.colors.push(o, o, o, o)
    }
    THREE.LineSegments.call(this, n, r)
}, THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, THREE.GridHelper.prototype.setColors = function(t, e) {
    this.color1.set(t), this.color2.set(e), this.geometry.colorsNeedUpdate = !0
}, THREE.HemisphereLightHelper = function(t, e) {
    THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color];
    var n = new THREE.SphereGeometry(e, 4, 2);
    n.rotateX(-Math.PI / 2);
    for (var r = 0; 8 > r; r++) n.faces[r].color = this.colors[4 > r ? 0 : 1];
    r = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    }), this.lightSphere = new THREE.Mesh(n, r), this.add(this.lightSphere), this.update()
}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
}, THREE.HemisphereLightHelper.prototype.update = function() {
    var t = new THREE.Vector3;
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
    }
}(), THREE.PointLightHelper = function(t, e) {
    this.light = t, this.light.updateMatrixWorld();
    var n = new THREE.SphereGeometry(e, 4, 2),
        r = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose()
}, THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
}, THREE.SkeletonHelper = function(t) {
    this.bones = this.getBoneList(t);
    for (var e = new THREE.Geometry, n = 0; n < this.bones.length; n++) this.bones[n].parent instanceof THREE.Bone && (e.vertices.push(new THREE.Vector3), e.vertices.push(new THREE.Vector3), e.colors.push(new THREE.Color(0, 0, 1)), e.colors.push(new THREE.Color(0, 1, 0)));
    e.dynamic = !0, n = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), THREE.LineSegments.call(this, e, n), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update()
}, THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, THREE.SkeletonHelper.prototype.getBoneList = function(t) {
    var e = [];
    t instanceof THREE.Bone && e.push(t);
    for (var n = 0; n < t.children.length; n++) e.push.apply(e, this.getBoneList(t.children[n]));
    return e
}, THREE.SkeletonHelper.prototype.update = function() {
    for (var t = this.geometry, e = (new THREE.Matrix4).getInverse(this.root.matrixWorld), n = new THREE.Matrix4, r = 0, i = 0; i < this.bones.length; i++) {
        var o = this.bones[i];
        o.parent instanceof THREE.Bone && (n.multiplyMatrices(e, o.matrixWorld), t.vertices[r].setFromMatrixPosition(n), n.multiplyMatrices(e, o.parent.matrixWorld), t.vertices[r + 1].setFromMatrixPosition(n), r += 2)
    }
    t.verticesNeedUpdate = !0, t.computeBoundingSphere()
}, THREE.SpotLightHelper = function(t) {
    THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, (t = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0)).translate(0, -.5, 0), t.rotateX(-Math.PI / 2);
    var e = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(t, e), this.add(this.cone), this.update()
}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose()
}, THREE.SpotLightHelper.prototype.update = function() {
    var t = new THREE.Vector3,
        e = new THREE.Vector3;
    return function() {
        var n = this.light.distance ? this.light.distance : 1e4,
            r = n * Math.tan(this.light.angle);
        this.cone.scale.set(r, r, n), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }
}(), THREE.VertexNormalsHelper = function(t, e, n, r) {
    this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== n ? n : 16711680, r = void 0 !== r ? r : 1, e = 0, (n = this.object.geometry) instanceof THREE.Geometry ? e = 3 * n.faces.length : n instanceof THREE.BufferGeometry && (e = n.attributes.normal.count), n = new THREE.BufferGeometry, e = new THREE.Float32Attribute(6 * e, 3), n.addAttribute("position", e), THREE.LineSegments.call(this, n, new THREE.LineBasicMaterial({
        color: t,
        linewidth: r
    })), this.matrixAutoUpdate = !1, this.update()
}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, THREE.VertexNormalsHelper.prototype.update = function() {
    var t = new THREE.Vector3,
        e = new THREE.Vector3,
        n = new THREE.Matrix3;
    return function() {
        var r = ["a", "b", "c"];
        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
        var i = this.object.matrixWorld,
            o = this.geometry.attributes.position,
            a = this.object.geometry;
        if (a instanceof THREE.Geometry)
            for (var s = a.vertices, u = a.faces, h = a = 0, c = u.length; h < c; h++)
                for (var l = u[h], p = 0, f = l.vertexNormals.length; p < f; p++) {
                    var d = l.vertexNormals[p];
                    t.copy(s[l[r[p]]]).applyMatrix4(i), e.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1
                } else if (a instanceof THREE.BufferGeometry)
                    for (r = a.attributes.position, s = a.attributes.normal, p = a = 0, f = r.count; p < f; p++) t.set(r.getX(p), r.getY(p), r.getZ(p)).applyMatrix4(i), e.set(s.getX(p), s.getY(p), s.getZ(p)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1;
        return o.needsUpdate = !0, this
    }
}(), THREE.WireframeHelper = function(t, e) {
    var n = void 0 !== e ? e : 16777215;
    THREE.LineSegments.call(this, new THREE.WireframeGeometry(t.geometry), new THREE.LineBasicMaterial({
        color: n
    })), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
}, THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, THREE.ImmediateRenderObject = function(t) {
    THREE.Object3D.call(this), this.material = t, this.render = function(t) {}
}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, THREE.MorphBlendMesh = function(t, e) {
    THREE.Mesh.call(this, t, e), this.animationsMap = {}, this.animationsList = [];
    var n = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, n - 1, n / 1), this.setAnimationWeight("__default", 1)
}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, THREE.MorphBlendMesh.prototype.createAnimation = function(t, e, n, r) {
    e = {
        start: e,
        end: n,
        length: n - e + 1,
        fps: r,
        duration: (n - e) / r,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    }, this.animationsMap[t] = e, this.animationsList.push(e)
}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(t) {
    for (var e, n = /([a-z]+)_?(\d+)/, r = {}, i = this.geometry, o = 0, a = i.morphTargets.length; o < a; o++) {
        var s = i.morphTargets[o].name.match(n);
        if (s && 1 < s.length) {
            var u = s[1];
            r[u] || (r[u] = {
                start: 1 / 0,
                end: -1 / 0
            }), o < (s = r[u]).start && (s.start = o), o > s.end && (s.end = o), e || (e = u)
        }
    }
    for (u in r) s = r[u], this.createAnimation(u, s.start, s.end, t);
    this.firstAnimation = e
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(t) {
    (t = this.animationsMap[t]) && (t.direction = 1, t.directionBackwards = !1)
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(t) {
    (t = this.animationsMap[t]) && (t.direction = -1, t.directionBackwards = !0)
}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(t, e) {
    var n = this.animationsMap[t];
    n && (n.fps = e, n.duration = (n.end - n.start) / n.fps)
}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(t, e) {
    var n = this.animationsMap[t];
    n && (n.duration = e, n.fps = (n.end - n.start) / n.duration)
}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(t, e) {
    var n = this.animationsMap[t];
    n && (n.weight = e)
}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(t, e) {
    var n = this.animationsMap[t];
    n && (n.time = e)
}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(t) {
    var e = 0;
    return (t = this.animationsMap[t]) && (e = t.time), e
}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(t) {
    var e = -1;
    return (t = this.animationsMap[t]) && (e = t.duration), e
}, THREE.MorphBlendMesh.prototype.playAnimation = function(t) {
    var e = this.animationsMap[t];
    e ? (e.time = 0, e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
}, THREE.MorphBlendMesh.prototype.stopAnimation = function(t) {
    (t = this.animationsMap[t]) && (t.active = !1)
}, THREE.MorphBlendMesh.prototype.update = function(t) {
    for (var e = 0, n = this.animationsList.length; e < n; e++) {
        var r = this.animationsList[e];
        if (r.active) {
            var i = r.duration / r.length;
            r.time += r.direction * t, r.mirroredLoop ? (r.time > r.duration || 0 > r.time) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), 0 > r.time && (r.time = 0, r.directionBackwards = !1)) : (r.time %= r.duration, 0 > r.time && (r.time += r.duration));
            var o = r.start + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
                a = r.weight;
            o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, r.lastFrame = r.currentFrame, r.currentFrame = o), i = r.time % i / i, r.directionBackwards && (i = 1 - i), r.currentFrame !== r.lastFrame ? (this.morphTargetInfluences[r.currentFrame] = i * a, this.morphTargetInfluences[r.lastFrame] = (1 - i) * a) : this.morphTargetInfluences[r.currentFrame] = a
        }
    }
}, THREE.TrackballControls = function(t, e) {
    var n = this,
        r = {
            NONE: -1,
            ROTATE: 0,
            ZOOM: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_ZOOM_PAN: 4
        };
    this.object = t, this.domElement = void 0 !== e ? e : document, this.enabled = !0, this.screen = {
        left: 0,
        top: 0,
        width: 0,
        height: 0
    }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = .3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.noRoll = !1, this.staticMoving = !1, this.dynamicDampingFactor = .2, this.minDistance = 0, this.maxDistance = 1 / 0, this.keys = [65, 83, 68], this.target = new THREE.Vector3;
    var i = new THREE.Vector3,
        o = r.NONE,
        a = r.NONE,
        s = new THREE.Vector3,
        u = new THREE.Vector3,
        h = new THREE.Vector3,
        c = new THREE.Vector2,
        l = new THREE.Vector2,
        p = 0,
        f = 0,
        d = new THREE.Vector2,
        E = new THREE.Vector2;
    this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.up0 = this.object.up.clone();
    var m = {
            type: "change"
        },
        g = {
            type: "start"
        },
        v = {
            type: "end"
        };
    this.handleResize = function() {
        if (this.domElement === document) this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight;
        else {
            var t = this.domElement.getBoundingClientRect(),
                e = this.domElement.ownerDocument.documentElement;
            this.screen.left = t.left + window.pageXOffset - e.clientLeft, this.screen.top = t.top + window.pageYOffset - e.clientTop, this.screen.width = t.width, this.screen.height = t.height
        }
    }, this.handleEvent = function(t) {
        "function" == typeof this[t.type] && this[t.type](t)
    };
    var y, T, R, x, b, H, _ = (y = new THREE.Vector2, function(t, e) {
            return y.set((t - n.screen.left) / n.screen.width, (e - n.screen.top) / n.screen.height), y
        }),
        w = function() {
            var t = new THREE.Vector3,
                e = new THREE.Vector3,
                r = new THREE.Vector3;
            return function(i, o) {
                r.set((i - .5 * n.screen.width - n.screen.left) / (.5 * n.screen.width), (.5 * n.screen.height + n.screen.top - o) / (.5 * n.screen.height), 0);
                var a = r.length();
                return n.noRoll ? a < Math.SQRT1_2 ? r.z = Math.sqrt(1 - a * a) : r.z = .5 / a : a > 1 ? r.normalize() : r.z = Math.sqrt(1 - a * a), s.copy(n.object.position).sub(n.target), t.copy(n.object.up).setLength(r.y), t.add(e.copy(n.object.up).cross(s).setLength(r.x)), t.add(s.setLength(r.z)), t
            }
        }();

    function M(t) {
        !1 !== n.enabled && (window.removeEventListener("keydown", M), a = o, o === r.NONE && (t.keyCode !== n.keys[r.ROTATE] || n.noRotate ? t.keyCode !== n.keys[r.ZOOM] || n.noZoom ? t.keyCode !== n.keys[r.PAN] || n.noPan || (o = r.PAN) : o = r.ZOOM : o = r.ROTATE))
    }

    function S(t) {
        !1 !== n.enabled && (t.preventDefault(), t.stopPropagation(), o !== r.ROTATE || n.noRotate ? o !== r.ZOOM || n.noZoom ? o !== r.PAN || n.noPan || E.copy(_(t.pageX, t.pageY)) : l.copy(_(t.pageX, t.pageY)) : h.copy(w(t.pageX, t.pageY)))
    }

    function A(t) {
        !1 !== n.enabled && (t.preventDefault(), t.stopPropagation(), o = r.NONE, document.removeEventListener("mousemove", S), document.removeEventListener("mouseup", A), n.dispatchEvent(v))
    }

    function C(t) {
        if (!1 !== n.enabled) {
            t.preventDefault(), t.stopPropagation();
            var e = 0;
            t.wheelDelta ? e = t.wheelDelta / 40 : t.detail && (e = -t.detail / 3), c.y += .01 * e, n.dispatchEvent(g), n.dispatchEvent(v)
        }
    }
    this.rotateCamera = (T = new THREE.Vector3, R = new THREE.Quaternion, function() {
        var t = Math.acos(u.dot(h) / u.length() / h.length());
        t && (T.crossVectors(u, h).normalize(), t *= n.rotateSpeed, R.setFromAxisAngle(T, -t), s.applyQuaternion(R), n.object.up.applyQuaternion(R), h.applyQuaternion(R), n.staticMoving ? u.copy(h) : (R.setFromAxisAngle(T, t * (n.dynamicDampingFactor - 1)), u.applyQuaternion(R)))
    }), this.zoomCamera = function() {
        if (o === r.TOUCH_ZOOM_PAN) {
            var t = p / f;
            p = f, s.multiplyScalar(t)
        } else {
            1 !== (t = 1 + (l.y - c.y) * n.zoomSpeed) && t > 0 && (s.multiplyScalar(t), n.staticMoving ? c.copy(l) : c.y += (l.y - c.y) * this.dynamicDampingFactor)
        }
    }, this.panCamera = (x = new THREE.Vector2, b = new THREE.Vector3, H = new THREE.Vector3, function() {
        x.copy(E).sub(d), x.lengthSq() && (x.multiplyScalar(s.length() * n.panSpeed), H.copy(s).cross(n.object.up).setLength(x.x), H.add(b.copy(n.object.up).setLength(x.y)), n.object.position.add(H), n.target.add(H), n.staticMoving ? d.copy(E) : d.add(x.subVectors(E, d).multiplyScalar(n.dynamicDampingFactor)))
    }), this.checkDistances = function() {
        n.noZoom && n.noPan || (s.lengthSq() > n.maxDistance * n.maxDistance && n.object.position.addVectors(n.target, s.setLength(n.maxDistance)), s.lengthSq() < n.minDistance * n.minDistance && n.object.position.addVectors(n.target, s.setLength(n.minDistance)))
    }, this.update = function() {
        s.subVectors(n.object.position, n.target), n.noRotate || n.rotateCamera(), n.noZoom || n.zoomCamera(), n.noPan || n.panCamera(), n.object.position.addVectors(n.target, s), n.checkDistances(), n.object.lookAt(n.target), i.distanceToSquared(n.object.position) > 1e-6 && (n.dispatchEvent(m), i.copy(n.object.position))
    }, this.reset = function() {
        o = r.NONE, a = r.NONE, n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.up.copy(n.up0), s.subVectors(n.object.position, n.target), n.object.lookAt(n.target), n.dispatchEvent(m), i.copy(n.object.position)
    }, this.resetTo = function(t, e, u) {
        o = r.NONE, a = r.NONE, n.target.copy(t), n.object.position.copy(e), n.object.up.copy(u), s.subVectors(n.object.position, n.target), n.object.lookAt(n.target), n.dispatchEvent(m), i.copy(n.object.position)
    }, this.domElement.addEventListener("contextmenu", function(t) {
        t.preventDefault()
    }, !1), this.domElement.addEventListener("mousedown", function(t) {
        !1 !== n.enabled && (t.preventDefault(), t.stopPropagation(), o === r.NONE && (o = t.button), o !== r.ROTATE || n.noRotate ? o !== r.ZOOM || n.noZoom ? o !== r.PAN || n.noPan || (d.copy(_(t.pageX, t.pageY)), E.copy(d)) : (c.copy(_(t.pageX, t.pageY)), l.copy(c)) : (u.copy(w(t.pageX, t.pageY)), h.copy(u)), document.addEventListener("mousemove", S, !1), document.addEventListener("mouseup", A, !1), n.dispatchEvent(g))
    }, !1), this.domElement.addEventListener("mousewheel", C, !1), this.domElement.addEventListener("DOMMouseScroll", C, !1), this.domElement.addEventListener("touchstart", function(t) {
        if (!1 !== n.enabled) {
            switch (t.touches.length) {
                case 1:
                    o = r.TOUCH_ROTATE, u.copy(w(t.touches[0].pageX, t.touches[0].pageY)), h.copy(u);
                    break;
                case 2:
                    o = r.TOUCH_ZOOM_PAN;
                    var e = t.touches[0].pageX - t.touches[1].pageX,
                        i = t.touches[0].pageY - t.touches[1].pageY;
                    f = p = Math.sqrt(e * e + i * i);
                    var a = (t.touches[0].pageX + t.touches[1].pageX) / 2,
                        s = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                    d.copy(_(a, s)), E.copy(d);
                    break;
                default:
                    o = r.NONE
            }
            n.dispatchEvent(g)
        }
    }, !1), this.domElement.addEventListener("touchend", function(t) {
        if (!1 !== n.enabled) {
            switch (t.touches.length) {
                case 1:
                    h.copy(w(t.touches[0].pageX, t.touches[0].pageY)), u.copy(h);
                    break;
                case 2:
                    p = f = 0;
                    var e = (t.touches[0].pageX + t.touches[1].pageX) / 2,
                        i = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                    E.copy(_(e, i)), d.copy(E)
            }
            o = r.NONE, n.dispatchEvent(v)
        }
    }, !1), this.domElement.addEventListener("touchmove", function(t) {
        if (!1 !== n.enabled) switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
            case 1:
                h.copy(w(t.touches[0].pageX, t.touches[0].pageY));
                break;
            case 2:
                var e = t.touches[0].pageX - t.touches[1].pageX,
                    i = t.touches[0].pageY - t.touches[1].pageY;
                f = Math.sqrt(e * e + i * i);
                var a = (t.touches[0].pageX + t.touches[1].pageX) / 2,
                    s = (t.touches[0].pageY + t.touches[1].pageY) / 2;
                E.copy(_(a, s));
                break;
            default:
                o = r.NONE
        }
    }, !1), window.addEventListener("keydown", M, !1), window.addEventListener("keyup", function(t) {
        !1 !== n.enabled && (o = a, window.addEventListener("keydown", M, !1))
    }, !1), this.handleResize(), this.update()
}, THREE.TrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype), define("libs/three", function() {});
var dat = dat || {};
dat.gui = dat.gui || {}, dat.utils = dat.utils || {}, dat.controllers = dat.controllers || {}, dat.dom = dat.dom || {}, dat.color = dat.color || {}, dat.utils.css = {
    load: function(t, e) {
        var n = (e = e || document).createElement("link");
        n.type = "text/css", n.rel = "stylesheet", n.href = t, e.getElementsByTagName("head")[0].appendChild(n)
    },
    inject: function(t, e) {
        e = e || document;
        var n = document.createElement("style");
        n.type = "text/css", n.innerHTML = t, e.getElementsByTagName("head")[0].appendChild(n)
    }
}, dat.utils.common = function() {
    var t = Array.prototype.forEach,
        e = Array.prototype.slice;
    return {
        BREAK: {},
        extend: function(t) {
            return this.each(e.call(arguments, 1), function(e) {
                for (var n in e) this.isUndefined(e[n]) || (t[n] = e[n])
            }, this), t
        },
        defaults: function(t) {
            return this.each(e.call(arguments, 1), function(e) {
                for (var n in e) this.isUndefined(t[n]) && (t[n] = e[n])
            }, this), t
        },
        compose: function() {
            var t = e.call(arguments);
            return function() {
                for (var n = e.call(arguments), r = t.length - 1; 0 <= r; r--) n = [t[r].apply(this, n)];
                return n[0]
            }
        },
        each: function(e, n, r) {
            if (t && e.forEach === t) e.forEach(n, r);
            else if (e.length === e.length + 0)
                for (var i = 0, o = e.length; i < o && !(i in e && n.call(r, e[i], i) === this.BREAK); i++);
            else
                for (i in e)
                    if (n.call(r, e[i], i) === this.BREAK) break
        },
        defer: function(t) {
            setTimeout(t, 0)
        },
        toArray: function(t) {
            return t.toArray ? t.toArray() : e.call(t)
        },
        isUndefined: function(t) {
            return void 0 === t
        },
        isNull: function(t) {
            return null === t
        },
        isNaN: function(t) {
            return t != t
        },
        isArray: Array.isArray || function(t) {
            return t.constructor === Array
        },
        isObject: function(t) {
            return t === Object(t)
        },
        isNumber: function(t) {
            return t === t + 0
        },
        isString: function(t) {
            return t === t + ""
        },
        isBoolean: function(t) {
            return !1 === t || !0 === t
        },
        isFunction: function(t) {
            return "[object Function]" === Object.prototype.toString.call(t)
        }
    }
}(), dat.controllers.Controller = function(t) {
    var e = function(t, e) {
        this.initialValue = t[e], this.domElement = document.createElement("div"), this.object = t, this.property = e, this.__onFinishChange = this.__onChange = void 0
    };
    return dat.utils.common.extend(e.prototype, {
        onChange: function(t) {
            return this.__onChange = t, this
        },
        onFinishChange: function(t) {
            return this.__onFinishChange = t, this
        },
        setValue: function(t) {
            return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
        },
        getValue: function() {
            return this.object[this.property]
        },
        updateDisplay: function() {
            return this
        },
        isModified: function() {
            return this.initialValue !== this.getValue()
        }
    }), e
}(), dat.dom.dom = function(t) {
    function e(e) {
        return "0" === e || t.isUndefined(e) ? 0 : (e = e.match(r), t.isNull(e) ? 0 : parseFloat(e[1]))
    }
    var n = {};
    t.each({
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    }, function(e, r) {
        t.each(e, function(t) {
            n[t] = r
        })
    });
    var r = /(\d+(\.\d+)?)px/,
        i = {
            makeSelectable: function(t, e) {
                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                    return !1
                } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
            },
            makeFullscreen: function(e, n, r) {
                t.isUndefined(n) && (n = !0), t.isUndefined(r) && (r = !0), e.style.position = "absolute", n && (e.style.left = 0, e.style.right = 0), r && (e.style.top = 0, e.style.bottom = 0)
            },
            fakeEvent: function(e, r, i, o) {
                i = i || {};
                var a = n[r];
                if (!a) throw Error("Event type " + r + " not supported.");
                var s = document.createEvent(a);
                switch (a) {
                    case "MouseEvents":
                        s.initMouseEvent(r, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, i.x || i.clientX || 0, i.y || i.clientY || 0, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        a = s.initKeyboardEvent || s.initKeyEvent, t.defaults(i, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }), a(r, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
                        break;
                    default:
                        s.initEvent(r, i.bubbles || !1, i.cancelable || !0)
                }
                t.defaults(s, o), e.dispatchEvent(s)
            },
            bind: function(t, e, n, r) {
                return t.addEventListener ? t.addEventListener(e, n, r || !1) : t.attachEvent && t.attachEvent("on" + e, n), i
            },
            unbind: function(t, e, n, r) {
                return t.removeEventListener ? t.removeEventListener(e, n, r || !1) : t.detachEvent && t.detachEvent("on" + e, n), i
            },
            addClass: function(t, e) {
                if (void 0 === t.className) t.className = e;
                else if (t.className !== e) {
                    var n = t.className.split(/ +/); - 1 == n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                }
                return i
            },
            removeClass: function(t, e) {
                if (e) {
                    if (void 0 !== t.className)
                        if (t.className === e) t.removeAttribute("class");
                        else {
                            var n = t.className.split(/ +/),
                                r = n.indexOf(e); - 1 != r && (n.splice(r, 1), t.className = n.join(" "))
                        }
                } else t.className = void 0;
                return i
            },
            hasClass: function(t, e) {
                return RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
            },
            getWidth: function(t) {
                return e((t = getComputedStyle(t))["border-left-width"]) + e(t["border-right-width"]) + e(t["padding-left"]) + e(t["padding-right"]) + e(t.width)
            },
            getHeight: function(t) {
                return e((t = getComputedStyle(t))["border-top-width"]) + e(t["border-bottom-width"]) + e(t["padding-top"]) + e(t["padding-bottom"]) + e(t.height)
            },
            getOffset: function(t) {
                var e = {
                    left: 0,
                    top: 0
                };
                if (t.offsetParent)
                    do {
                        e.left += t.offsetLeft, e.top += t.offsetTop
                    } while (t = t.offsetParent);
                return e
            },
            isActive: function(t) {
                return t === document.activeElement && (t.type || t.href)
            }
        };
    return i
}(dat.utils.common), dat.controllers.OptionController = function(t, e, n) {
    var r = function(t, i, o) {
        r.superclass.call(this, t, i);
        var a = this;
        if (this.__select = document.createElement("select"), n.isArray(o)) {
            var s = {};
            n.each(o, function(t) {
                s[t] = t
            }), o = s
        }
        n.each(o, function(t, e) {
            var n = document.createElement("option");
            n.innerHTML = e, n.setAttribute("value", t), a.__select.appendChild(n)
        }), this.updateDisplay(), e.bind(this.__select, "change", function() {
            a.setValue(this.options[this.selectedIndex].value)
        }), this.domElement.appendChild(this.__select)
    };
    return r.superclass = t, n.extend(r.prototype, t.prototype, {
        setValue: function(t) {
            return t = r.superclass.prototype.setValue.call(this, t), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), t
        },
        updateDisplay: function() {
            return this.__select.value = this.getValue(), r.superclass.prototype.updateDisplay.call(this)
        }
    }), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.NumberController = function(t, e) {
    var n = function(t, r, i) {
        n.superclass.call(this, t, r), i = i || {}, this.__min = i.min, this.__max = i.max, this.__step = i.step, e.isUndefined(this.__step) ? this.__impliedStep = 0 == this.initialValue ? 1 : Math.pow(10, Math.floor(Math.log(this.initialValue) / Math.LN10)) / 10 : this.__impliedStep = this.__step, t = -1 < (t = (t = this.__impliedStep).toString()).indexOf(".") ? t.length - t.indexOf(".") - 1 : 0, this.__precision = t
    };
    return n.superclass = t, e.extend(n.prototype, t.prototype, {
        setValue: function(t) {
            return void 0 !== this.__min && t < this.__min ? t = this.__min : void 0 !== this.__max && t > this.__max && (t = this.__max), void 0 !== this.__step && 0 != t % this.__step && (t = Math.round(t / this.__step) * this.__step), n.superclass.prototype.setValue.call(this, t)
        },
        min: function(t) {
            return this.__min = t, this
        },
        max: function(t) {
            return this.__max = t, this
        },
        step: function(t) {
            return this.__step = t, this
        }
    }), n
}(dat.controllers.Controller, dat.utils.common), dat.controllers.NumberControllerBox = function(t, e, n) {
    var r = function(t, i, o) {
        function a() {
            var t = parseFloat(c.__input.value);
            n.isNaN(t) || c.setValue(t)
        }

        function s(t) {
            var e = h - t.clientY;
            c.setValue(c.getValue() + e * c.__impliedStep), h = t.clientY
        }

        function u() {
            e.unbind(window, "mousemove", s), e.unbind(window, "mouseup", u)
        }
        this.__truncationSuspended = !1, r.superclass.call(this, t, i, o);
        var h, c = this;
        this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), e.bind(this.__input, "change", a), e.bind(this.__input, "blur", function() {
            a(), c.__onFinishChange && c.__onFinishChange.call(c, c.getValue())
        }), e.bind(this.__input, "mousedown", function(t) {
            e.bind(window, "mousemove", s), e.bind(window, "mouseup", u), h = t.clientY
        }), e.bind(this.__input, "keydown", function(t) {
            13 === t.keyCode && (c.__truncationSuspended = !0, this.blur(), c.__truncationSuspended = !1)
        }), this.updateDisplay(), this.domElement.appendChild(this.__input)
    };
    return r.superclass = t, n.extend(r.prototype, t.prototype, {
        updateDisplay: function() {
            var t, e = this.__input;
            if (this.__truncationSuspended) t = this.getValue();
            else {
                t = this.getValue();
                var n = Math.pow(10, this.__precision);
                t = Math.round(t * n) / n
            }
            return e.value = t, r.superclass.prototype.updateDisplay.call(this)
        }
    }), r
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.common), dat.controllers.NumberControllerSlider = function(t, e, n, r, i) {
    var o = function(t, n, r, i, a) {
        function s(t) {
            t.preventDefault();
            var n = e.getOffset(h.__background),
                r = e.getWidth(h.__background);
            return h.setValue(function(t, e, n, r, i) {
                return r + (t - e) / (n - e) * (i - r)
            }(t.clientX, n.left, n.left + r, h.__min, h.__max)), !1
        }

        function u() {
            e.unbind(window, "mousemove", s), e.unbind(window, "mouseup", u), h.__onFinishChange && h.__onFinishChange.call(h, h.getValue())
        }
        o.superclass.call(this, t, n, {
            min: r,
            max: i,
            step: a
        });
        var h = this;
        this.__background = document.createElement("div"), this.__foreground = document.createElement("div"), e.bind(this.__background, "mousedown", function(t) {
            e.bind(window, "mousemove", s), e.bind(window, "mouseup", u), s(t)
        }), e.addClass(this.__background, "slider"), e.addClass(this.__foreground, "slider-fg"), this.updateDisplay(), this.__background.appendChild(this.__foreground), this.domElement.appendChild(this.__background)
    };
    return o.superclass = t, o.useDefaultStyles = function() {
        n.inject("/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}")
    }, r.extend(o.prototype, t.prototype, {
        updateDisplay: function() {
            var t = (this.getValue() - this.__min) / (this.__max - this.__min);
            return this.__foreground.style.width = 100 * t + "%", o.superclass.prototype.updateDisplay.call(this)
        }
    }), o
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.css, dat.utils.common), dat.controllers.FunctionController = function(t, e, n) {
    var r = function(t, n, i) {
        r.superclass.call(this, t, n);
        var o = this;
        this.__button = document.createElement("div"), this.__button.innerHTML = void 0 === i ? "Fire" : i, e.bind(this.__button, "click", function(t) {
            return t.preventDefault(), o.fire(), !1
        }), e.addClass(this.__button, "button"), this.domElement.appendChild(this.__button)
    };
    return r.superclass = t, n.extend(r.prototype, t.prototype, {
        fire: function() {
            this.__onChange && this.__onChange.call(this), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.getValue().call(this.object)
        }
    }), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.BooleanController = function(t, e, n) {
    var r = function(t, n) {
        r.superclass.call(this, t, n);
        var i = this;
        this.__prev = this.getValue(), this.__checkbox = document.createElement("input"), this.__checkbox.setAttribute("type", "checkbox"), e.bind(this.__checkbox, "change", function() {
            i.setValue(!i.__prev)
        }, !1), this.domElement.appendChild(this.__checkbox), this.updateDisplay()
    };
    return r.superclass = t, n.extend(r.prototype, t.prototype, {
        setValue: function(t) {
            return t = r.superclass.prototype.setValue.call(this, t), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), t
        },
        updateDisplay: function() {
            return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0) : this.__checkbox.checked = !1, r.superclass.prototype.updateDisplay.call(this)
        }
    }), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.color.toString = function(t) {
    return function(e) {
        if (1 == e.a || t.isUndefined(e.a)) {
            for (e = e.hex.toString(16); 6 > e.length;) e = "0" + e;
            return "#" + e
        }
        return "rgba(" + Math.round(e.r) + "," + Math.round(e.g) + "," + Math.round(e.b) + "," + e.a + ")"
    }
}(dat.utils.common), dat.color.interpret = function(t, e) {
    var n, r, i = [{
        litmus: e.isString,
        conversions: {
            THREE_CHAR_HEX: {
                read: function(t) {
                    return null !== (t = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i)) && {
                        space: "HEX",
                        hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString())
                    }
                },
                write: t
            },
            SIX_CHAR_HEX: {
                read: function(t) {
                    return null !== (t = t.match(/^#([A-F0-9]{6})$/i)) && {
                        space: "HEX",
                        hex: parseInt("0x" + t[1].toString())
                    }
                },
                write: t
            },
            CSS_RGB: {
                read: function(t) {
                    return null !== (t = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/)) && {
                        space: "RGB",
                        r: parseFloat(t[1]),
                        g: parseFloat(t[2]),
                        b: parseFloat(t[3])
                    }
                },
                write: t
            },
            CSS_RGBA: {
                read: function(t) {
                    return null !== (t = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/)) && {
                        space: "RGB",
                        r: parseFloat(t[1]),
                        g: parseFloat(t[2]),
                        b: parseFloat(t[3]),
                        a: parseFloat(t[4])
                    }
                },
                write: t
            }
        }
    }, {
        litmus: e.isNumber,
        conversions: {
            HEX: {
                read: function(t) {
                    return {
                        space: "HEX",
                        hex: t,
                        conversionName: "HEX"
                    }
                },
                write: function(t) {
                    return t.hex
                }
            }
        }
    }, {
        litmus: e.isArray,
        conversions: {
            RGB_ARRAY: {
                read: function(t) {
                    return 3 == t.length && {
                        space: "RGB",
                        r: t[0],
                        g: t[1],
                        b: t[2]
                    }
                },
                write: function(t) {
                    return [t.r, t.g, t.b]
                }
            },
            RGBA_ARRAY: {
                read: function(t) {
                    return 4 == t.length && {
                        space: "RGB",
                        r: t[0],
                        g: t[1],
                        b: t[2],
                        a: t[3]
                    }
                },
                write: function(t) {
                    return [t.r, t.g, t.b, t.a]
                }
            }
        }
    }, {
        litmus: e.isObject,
        conversions: {
            RGBA_OBJ: {
                read: function(t) {
                    return !!(e.isNumber(t.r) && e.isNumber(t.g) && e.isNumber(t.b) && e.isNumber(t.a)) && {
                        space: "RGB",
                        r: t.r,
                        g: t.g,
                        b: t.b,
                        a: t.a
                    }
                },
                write: function(t) {
                    return {
                        r: t.r,
                        g: t.g,
                        b: t.b,
                        a: t.a
                    }
                }
            },
            RGB_OBJ: {
                read: function(t) {
                    return !!(e.isNumber(t.r) && e.isNumber(t.g) && e.isNumber(t.b)) && {
                        space: "RGB",
                        r: t.r,
                        g: t.g,
                        b: t.b
                    }
                },
                write: function(t) {
                    return {
                        r: t.r,
                        g: t.g,
                        b: t.b
                    }
                }
            },
            HSVA_OBJ: {
                read: function(t) {
                    return !!(e.isNumber(t.h) && e.isNumber(t.s) && e.isNumber(t.v) && e.isNumber(t.a)) && {
                        space: "HSV",
                        h: t.h,
                        s: t.s,
                        v: t.v,
                        a: t.a
                    }
                },
                write: function(t) {
                    return {
                        h: t.h,
                        s: t.s,
                        v: t.v,
                        a: t.a
                    }
                }
            },
            HSV_OBJ: {
                read: function(t) {
                    return !!(e.isNumber(t.h) && e.isNumber(t.s) && e.isNumber(t.v)) && {
                        space: "HSV",
                        h: t.h,
                        s: t.s,
                        v: t.v
                    }
                },
                write: function(t) {
                    return {
                        h: t.h,
                        s: t.s,
                        v: t.v
                    }
                }
            }
        }
    }];
    return function() {
        r = !1;
        var t = 1 < arguments.length ? e.toArray(arguments) : arguments[0];
        return e.each(i, function(i) {
            if (i.litmus(t)) return e.each(i.conversions, function(i, o) {
                if (n = i.read(t), !1 === r && !1 !== n) return r = n, n.conversionName = o, n.conversion = i, e.BREAK
            }), e.BREAK
        }), r
    }
}(dat.color.toString, dat.utils.common), dat.GUI = dat.gui.GUI = function(t, e, n, r, i, o, a, s, u, h, c, l, p, f, d) {
    function E(t, e, n, o) {
        if (void 0 === e[n]) throw Error("Object " + e + ' has no property "' + n + '"');
        o.color ? e = new c(e, n) : (e = [e, n].concat(o.factoryArgs), e = r.apply(t, e)), o.before instanceof i && (o.before = o.before.__li), v(t, e), f.addClass(e.domElement, "c"), n = document.createElement("span"), f.addClass(n, "property-name"), n.innerHTML = e.property;
        var a = document.createElement("div");
        return a.appendChild(n), a.appendChild(e.domElement), o = m(t, a, o.before), f.addClass(o, C.CLASS_CONTROLLER_ROW), f.addClass(o, typeof e.getValue()), g(t, o, e), t.__controllers.push(e), e
    }

    function m(t, e, n) {
        var r = document.createElement("li");
        return e && r.appendChild(e), n ? t.__ul.insertBefore(r, params.before) : t.__ul.appendChild(r), t.onResize(), r
    }

    function g(t, e, n) {
        if (n.__li = e, n.__gui = t, d.extend(n, {
                options: function(e) {
                    return 1 < arguments.length ? (n.remove(), E(t, n.object, n.property, {
                        before: n.__li.nextElementSibling,
                        factoryArgs: [d.toArray(arguments)]
                    })) : d.isArray(e) || d.isObject(e) ? (n.remove(), E(t, n.object, n.property, {
                        before: n.__li.nextElementSibling,
                        factoryArgs: [e]
                    })) : void 0
                },
                name: function(t) {
                    return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
                },
                listen: function() {
                    return n.__gui.listen(n), n
                },
                remove: function() {
                    return n.__gui.remove(n), n
                }
            }), n instanceof u) {
            var r = new s(n.object, n.property, {
                min: n.__min,
                max: n.__max,
                step: n.__step
            });
            d.each(["updateDisplay", "onChange", "onFinishChange"], function(t) {
                var e = n[t],
                    i = r[t];
                n[t] = r[t] = function() {
                    var t = Array.prototype.slice.call(arguments);
                    return e.apply(n, t), i.apply(r, t)
                }
            }), f.addClass(e, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
        } else if (n instanceof s) {
            var i = function(e) {
                return d.isNumber(n.__min) && d.isNumber(n.__max) ? (n.remove(), E(t, n.object, n.property, {
                    before: n.__li.nextElementSibling,
                    factoryArgs: [n.__min, n.__max, n.__step]
                })) : e
            };
            n.min = d.compose(i, n.min), n.max = d.compose(i, n.max)
        } else n instanceof o ? (f.bind(e, "click", function() {
            f.fakeEvent(n.__checkbox, "click")
        }), f.bind(n.__checkbox, "click", function(t) {
            t.stopPropagation()
        })) : n instanceof a ? (f.bind(e, "click", function() {
            f.fakeEvent(n.__button, "click")
        }), f.bind(e, "mouseover", function() {
            f.addClass(n.__button, "hover")
        }), f.bind(e, "mouseout", function() {
            f.removeClass(n.__button, "hover")
        })) : n instanceof c && (f.addClass(e, "color"), n.updateDisplay = d.compose(function(t) {
            return e.style.borderLeftColor = n.__color.toString(), t
        }, n.updateDisplay), n.updateDisplay());
        n.setValue = d.compose(function(e) {
            return t.getRoot().__preset_select && n.isModified() && x(t.getRoot(), !0), e
        }, n.setValue)
    }

    function v(t, e) {
        var n = t.getRoot(),
            r = n.__rememberedObjects.indexOf(e.object);
        if (-1 != r) {
            var i = n.__rememberedObjectIndecesToControllers[r];
            if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[e.property] = e, n.load && n.load.remembered) {
                if ((n = n.load.remembered)[t.preset]) n = n[t.preset];
                else {
                    if (!n[H]) return;
                    n = n[H]
                }
                n[r] && void 0 !== n[r][e.property] && (r = n[r][e.property], e.initialValue = r, e.setValue(r))
            }
        }
    }

    function y(t, e) {
        t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
    }

    function T(t, e) {
        var n = {};
        return d.each(t.__rememberedObjects, function(r, i) {
            var o = {};
            d.each(t.__rememberedObjectIndecesToControllers[i], function(t, n) {
                o[n] = e ? t.initialValue : t.getValue()
            }), n[i] = o
        }), n
    }

    function R(t, e, n) {
        var r = document.createElement("option");
        r.innerHTML = e, r.value = e, t.__preset_select.appendChild(r), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }

    function x(t, e) {
        var n = t.__preset_select[t.__preset_select.selectedIndex];
        n.innerHTML = e ? n.value + "*" : n.value
    }
    t.inject(".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n");
    var b, H = "Default";
    try {
        b = "localStorage" in window && null !== window.localStorage
    } catch (t) {
        b = !1
    }
    var _, w, M = !0,
        S = !1,
        A = [],
        C = function(t) {
            function e() {
                localStorage.setItem(document.location.href + ".gui", JSON.stringify(n.getSaveObject()))
            }
            var n = this;
            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), f.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], t = t || {}, t = d.defaults(t, {
                autoPlace: !0,
                width: C.DEFAULT_WIDTH
            }), t = d.defaults(t, {
                resizable: t.autoPlace,
                hideable: t.autoPlace
            }), d.isUndefined(t.load) ? t.load = {
                preset: H
            } : t.preset && (t.load.preset = t.preset), d.isUndefined(t.parent) && t.hideable && A.push(this), t.resizable = d.isUndefined(t.parent) && t.resizable, t.autoPlace && d.isUndefined(t.scrollable) && (t.scrollable = !0);
            var r = b && "true" === localStorage.getItem(document.location.href + ".isLocal");
            if (Object.defineProperties(this, {
                    parent: {
                        get: function() {
                            return t.parent
                        }
                    },
                    scrollable: {
                        get: function() {
                            return t.scrollable
                        }
                    },
                    autoPlace: {
                        get: function() {
                            return t.autoPlace
                        }
                    },
                    preset: {
                        get: function() {
                            return n.parent ? n.getRoot().preset : t.load.preset
                        },
                        set: function(e) {
                            for (n.parent ? n.getRoot().preset = e : t.load.preset = e, e = 0; e < this.__preset_select.length; e++) this.__preset_select[e].value == this.preset && (this.__preset_select.selectedIndex = e);
                            n.revert()
                        }
                    },
                    width: {
                        get: function() {
                            return t.width
                        },
                        set: function(e) {
                            t.width = e, y(n, e)
                        }
                    },
                    name: {
                        get: function() {
                            return t.name
                        },
                        set: function(e) {
                            t.name = e, o && (o.innerHTML = t.name)
                        }
                    },
                    closed: {
                        get: function() {
                            return t.closed
                        },
                        set: function(e) {
                            t.closed = e, t.closed ? f.addClass(n.__ul, C.CLASS_CLOSED) : f.removeClass(n.__ul, C.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? C.TEXT_OPEN : C.TEXT_CLOSED)
                        }
                    },
                    load: {
                        get: function() {
                            return t.load
                        }
                    },
                    useLocalStorage: {
                        get: function() {
                            return r
                        },
                        set: function(t) {
                            b && ((r = t) ? f.bind(window, "unload", e) : f.unbind(window, "unload", e), localStorage.setItem(document.location.href + ".isLocal", t))
                        }
                    }
                }), d.isUndefined(t.parent)) {
                if (t.closed = !1, f.addClass(this.domElement, C.CLASS_MAIN), f.makeSelectable(this.domElement, !1), b && r) {
                    n.useLocalStorage = !0;
                    var i = localStorage.getItem(document.location.href + ".gui");
                    i && (t.load = JSON.parse(i))
                }
                this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = C.TEXT_CLOSED, f.addClass(this.__closeButton, C.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), f.bind(this.__closeButton, "click", function() {
                    n.closed = !n.closed
                })
            } else {
                void 0 === t.closed && (t.closed = !0);
                var o = document.createTextNode(t.name);
                f.addClass(o, "controller-name"), i = m(n, o), f.addClass(this.__ul, C.CLASS_CLOSED), f.addClass(i, "title"), f.bind(i, "click", function(t) {
                    return t.preventDefault(), n.closed = !n.closed, !1
                }), t.closed || (this.closed = !1)
            }
            t.autoPlace && (d.isUndefined(t.parent) && (M && (w = document.createElement("div"), f.addClass(w, "dg"), f.addClass(w, C.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(w), M = !1), w.appendChild(this.domElement), f.addClass(this.domElement, C.CLASS_AUTO_PLACE)), this.parent || y(n, t.width)), f.bind(window, "resize", function() {
                n.onResize()
            }), f.bind(this.__ul, "webkitTransitionEnd", function() {
                n.onResize()
            }), f.bind(this.__ul, "transitionend", function() {
                n.onResize()
            }), f.bind(this.__ul, "oTransitionEnd", function() {
                n.onResize()
            }), this.onResize(), t.resizable && function(t) {
                function e(e) {
                    return e.preventDefault(), i = e.clientX, f.addClass(t.__closeButton, C.CLASS_DRAG), f.bind(window, "mousemove", n), f.bind(window, "mouseup", r), !1
                }

                function n(e) {
                    return e.preventDefault(), t.width += i - e.clientX, t.onResize(), i = e.clientX, !1
                }

                function r() {
                    f.removeClass(t.__closeButton, C.CLASS_DRAG), f.unbind(window, "mousemove", n), f.unbind(window, "mouseup", r)
                }
                var i;
                t.__resize_handle = document.createElement("div"), d.extend(t.__resize_handle.style, {
                    width: "6px",
                    marginLeft: "-3px",
                    height: "200px",
                    cursor: "ew-resize",
                    position: "absolute"
                }), f.bind(t.__resize_handle, "mousedown", e), f.bind(t.__closeButton, "mousedown", e), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
            }(this), n.getRoot(), t.parent || function() {
                var t = n.getRoot();
                t.width += 1, d.defer(function() {
                    t.width -= 1
                })
            }()
        };
    return C.toggleHide = function() {
        S = !S, d.each(A, function(t) {
            t.domElement.style.zIndex = S ? -999 : 999, t.domElement.style.opacity = S ? 0 : 1
        })
    }, C.CLASS_AUTO_PLACE = "a", C.CLASS_AUTO_PLACE_CONTAINER = "ac", C.CLASS_MAIN = "main", C.CLASS_CONTROLLER_ROW = "cr", C.CLASS_TOO_TALL = "taller-than-window", C.CLASS_CLOSED = "closed", C.CLASS_CLOSE_BUTTON = "close-button", C.CLASS_DRAG = "drag", C.DEFAULT_WIDTH = 245, C.TEXT_CLOSED = "Close Controls", C.TEXT_OPEN = "Open Controls", f.bind(window, "keydown", function(t) {
        "text" === document.activeElement.type || 72 !== t.which && 72 != t.keyCode || C.toggleHide()
    }, !1), d.extend(C.prototype, {
        add: function(t, e) {
            return E(this, t, e, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            })
        },
        addColor: function(t, e) {
            return E(this, t, e, {
                color: !0
            })
        },
        remove: function(t) {
            this.__ul.removeChild(t.__li), this.__controllers.slice(this.__controllers.indexOf(t), 1);
            var e = this;
            d.defer(function() {
                e.onResize()
            })
        },
        destroy: function() {
            this.autoPlace && w.removeChild(this.domElement)
        },
        addFolder: function(t) {
            if (void 0 !== this.__folders[t]) throw Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = {
                name: t,
                parent: this
            };
            return e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]), e = new C(e), this.__folders[t] = e, t = m(this, e.domElement), f.addClass(t, "folder"), e
        },
        open: function() {
            this.closed = !1
        },
        close: function() {
            this.closed = !0
        },
        onResize: function() {
            var t = this.getRoot();
            if (t.scrollable) {
                var e = f.getOffset(t.__ul).top,
                    n = 0;
                d.each(t.__ul.childNodes, function(e) {
                    t.autoPlace && e === t.__save_row || (n += f.getHeight(e))
                }), window.innerHeight - e - 20 < n ? (f.addClass(t.domElement, C.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (f.removeClass(t.domElement, C.CLASS_TOO_TALL), t.__ul.style.height = "auto")
            }
            t.__resize_handle && d.defer(function() {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
            }), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
        },
        remember: function() {
            if (d.isUndefined(_) && ((_ = new p).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>'), this.parent) throw Error("You can only call remember on a top level GUI.");
            var t = this;
            d.each(Array.prototype.slice.call(arguments), function(e) {
                0 == t.__rememberedObjects.length && function(t) {
                    var e = t.__save_row = document.createElement("li");
                    f.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), f.addClass(e, "save-row");
                    var n = document.createElement("span");
                    n.innerHTML = "&nbsp;", f.addClass(n, "button gears");
                    var r = document.createElement("span");
                    r.innerHTML = "Save", f.addClass(r, "button"), f.addClass(r, "save");
                    var i = document.createElement("span");
                    i.innerHTML = "New", f.addClass(i, "button"), f.addClass(i, "save-as");
                    var o = document.createElement("span");
                    o.innerHTML = "Revert", f.addClass(o, "button"), f.addClass(o, "revert");
                    var a = t.__preset_select = document.createElement("select");
                    if (t.load && t.load.remembered ? d.each(t.load.remembered, function(e, n) {
                            R(t, n, n == t.preset)
                        }) : R(t, H, !1), f.bind(a, "change", function() {
                            for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                            t.preset = this.value
                        }), e.appendChild(a), e.appendChild(n), e.appendChild(r), e.appendChild(i), e.appendChild(o), b) {
                        e = document.getElementById("dg-save-locally");
                        var s = document.getElementById("dg-local-explain");
                        e.style.display = "block", e = document.getElementById("dg-local-storage"), "true" === localStorage.getItem(document.location.href + ".isLocal") && e.setAttribute("checked", "checked");
                        var u = function() {
                            s.style.display = t.useLocalStorage ? "block" : "none"
                        };
                        u(), f.bind(e, "change", function() {
                            t.useLocalStorage = !t.useLocalStorage, u()
                        })
                    }
                    var h = document.getElementById("dg-new-constructor");
                    f.bind(h, "keydown", function(t) {
                        !t.metaKey || 67 !== t.which && 67 != t.keyCode || _.hide()
                    }), f.bind(n, "click", function() {
                        h.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), _.show(), h.focus(), h.select()
                    }), f.bind(r, "click", function() {
                        t.save()
                    }), f.bind(i, "click", function() {
                        var e = prompt("Enter a new preset name.");
                        e && t.saveAs(e)
                    }), f.bind(o, "click", function() {
                        t.revert()
                    })
                }(t), -1 == t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
            }), this.autoPlace && y(this, this.width)
        },
        getRoot: function() {
            for (var t = this; t.parent;) t = t.parent;
            return t
        },
        getSaveObject: function() {
            var t = this.load;
            return t.closed = this.closed, 0 < this.__rememberedObjects.length && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = T(this)), t.folders = {}, d.each(this.__folders, function(e, n) {
                t.folders[n] = e.getSaveObject()
            }), t
        },
        save: function() {
            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = T(this), x(this, !1)
        },
        saveAs: function(t) {
            this.load.remembered || (this.load.remembered = {}, this.load.remembered[H] = T(this, !0)), this.load.remembered[t] = T(this), this.preset = t, R(this, t, !0)
        },
        revert: function(t) {
            d.each(this.__controllers, function(e) {
                this.getRoot().load.remembered ? v(t || this.getRoot(), e) : e.setValue(e.initialValue)
            }, this), d.each(this.__folders, function(t) {
                t.revert(t)
            }), t || x(this.getRoot(), !1)
        },
        listen: function(t) {
            var e = 0 == this.__listening.length;
            this.__listening.push(t), e && function t(e) {
                0 != e.length && l(function() {
                    t(e)
                }), d.each(e, function(t) {
                    t.updateDisplay()
                })
            }(this.__listening)
        }
    }), C
}(dat.utils.css, 0, 0, dat.controllers.factory = function(t, e, n, r, i, o, a) {
    return function(s, u, h, c) {
        var l = s[u];
        return a.isArray(h) || a.isObject(h) ? new t(s, u, h) : a.isNumber(l) ? a.isNumber(h) && a.isNumber(c) ? new n(s, u, h, c) : new e(s, u, {
            min: h,
            max: c
        }) : a.isString(l) ? new r(s, u) : a.isFunction(l) ? new i(s, u, "") : a.isBoolean(l) ? new o(s, u) : void 0
    }
}(dat.controllers.OptionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.StringController = function(t, e, n) {
    var r = function(t, n) {
        function i() {
            o.setValue(o.__input.value)
        }
        r.superclass.call(this, t, n);
        var o = this;
        this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), e.bind(this.__input, "keyup", i), e.bind(this.__input, "change", i), e.bind(this.__input, "blur", function() {
            o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
        }), e.bind(this.__input, "keydown", function(t) {
            13 === t.keyCode && this.blur()
        }), this.updateDisplay(), this.domElement.appendChild(this.__input)
    };
    return r.superclass = t, n.extend(r.prototype, t.prototype, {
        updateDisplay: function() {
            return e.isActive(this.__input) || (this.__input.value = this.getValue()), r.superclass.prototype.updateDisplay.call(this)
        }
    }), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.FunctionController, dat.controllers.BooleanController, dat.utils.common), dat.controllers.Controller, dat.controllers.BooleanController, dat.controllers.FunctionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.OptionController, dat.controllers.ColorController = function(t, e, n, r, i) {
    function o(t, e, n, r) {
        t.style.background = "", i.each(s, function(i) {
            t.style.cssText += "background: " + i + "linear-gradient(" + e + ", " + n + " 0%, " + r + " 100%); "
        })
    }
    var a = function(t, s) {
        function u(t) {
            p(t), e.bind(window, "mousemove", p), e.bind(window, "mouseup", h)
        }

        function h() {
            e.unbind(window, "mousemove", p), e.unbind(window, "mouseup", h)
        }

        function c() {
            var t = r(this.value);
            !1 !== t ? (d.__color.__state = t, d.setValue(d.__color.toOriginal())) : this.value = d.__color.toString()
        }

        function l() {
            e.unbind(window, "mousemove", f), e.unbind(window, "mouseup", l)
        }

        function p(t) {
            t.preventDefault();
            var n = e.getWidth(d.__saturation_field),
                r = e.getOffset(d.__saturation_field),
                i = (t.clientX - r.left + document.body.scrollLeft) / n;
            return 1 < (t = 1 - (t.clientY - r.top + document.body.scrollTop) / n) ? t = 1 : 0 > t && (t = 0), 1 < i ? i = 1 : 0 > i && (i = 0), d.__color.v = t, d.__color.s = i, d.setValue(d.__color.toOriginal()), !1
        }

        function f(t) {
            t.preventDefault();
            var n = e.getHeight(d.__hue_field),
                r = e.getOffset(d.__hue_field);
            return 1 < (t = 1 - (t.clientY - r.top + document.body.scrollTop) / n) ? t = 1 : 0 > t && (t = 0), d.__color.h = 360 * t, d.setValue(d.__color.toOriginal()), !1
        }
        a.superclass.call(this, t, s), this.__color = new n(this.getValue()), this.__temp = new n(0);
        var d = this;
        this.domElement = document.createElement("div"), e.makeSelectable(this.domElement, !1), this.__selector = document.createElement("div"), this.__selector.className = "selector", this.__saturation_field = document.createElement("div"), this.__saturation_field.className = "saturation-field", this.__field_knob = document.createElement("div"), this.__field_knob.className = "field-knob", this.__field_knob_border = "2px solid ", this.__hue_knob = document.createElement("div"), this.__hue_knob.className = "hue-knob", this.__hue_field = document.createElement("div"), this.__hue_field.className = "hue-field", this.__input = document.createElement("input"), this.__input.type = "text", this.__input_textShadow = "0 1px 1px ", e.bind(this.__input, "keydown", function(t) {
            13 === t.keyCode && c.call(this)
        }), e.bind(this.__input, "blur", c), e.bind(this.__selector, "mousedown", function(t) {
            e.addClass(this, "drag").bind(window, "mouseup", function(t) {
                e.removeClass(d.__selector, "drag")
            })
        });
        var E = document.createElement("div");
        i.extend(this.__selector.style, {
                width: "122px",
                height: "102px",
                padding: "3px",
                backgroundColor: "#222",
                boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
            }), i.extend(this.__field_knob.style, {
                position: "absolute",
                width: "12px",
                height: "12px",
                border: this.__field_knob_border + (.5 > this.__color.v ? "#fff" : "#000"),
                boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                borderRadius: "12px",
                zIndex: 1
            }), i.extend(this.__hue_knob.style, {
                position: "absolute",
                width: "15px",
                height: "2px",
                borderRight: "4px solid #fff",
                zIndex: 1
            }), i.extend(this.__saturation_field.style, {
                width: "100px",
                height: "100px",
                border: "1px solid #555",
                marginRight: "3px",
                display: "inline-block",
                cursor: "pointer"
            }), i.extend(E.style, {
                width: "100%",
                height: "100%",
                background: "none"
            }), o(E, "top", "rgba(0,0,0,0)", "#000"), i.extend(this.__hue_field.style, {
                width: "15px",
                height: "100px",
                display: "inline-block",
                border: "1px solid #555",
                cursor: "ns-resize"
            }),
            function(t) {
                t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
            }(this.__hue_field), i.extend(this.__input.style, {
                outline: "none",
                textAlign: "center",
                color: "#fff",
                border: 0,
                fontWeight: "bold",
                textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)"
            }), e.bind(this.__saturation_field, "mousedown", u), e.bind(this.__field_knob, "mousedown", u), e.bind(this.__hue_field, "mousedown", function(t) {
                f(t), e.bind(window, "mousemove", f), e.bind(window, "mouseup", l)
            }), this.__saturation_field.appendChild(E), this.__selector.appendChild(this.__field_knob), this.__selector.appendChild(this.__saturation_field), this.__selector.appendChild(this.__hue_field), this.__hue_field.appendChild(this.__hue_knob), this.domElement.appendChild(this.__input), this.domElement.appendChild(this.__selector), this.updateDisplay()
    };
    a.superclass = t, i.extend(a.prototype, t.prototype, {
        updateDisplay: function() {
            var t = r(this.getValue());
            if (!1 !== t) {
                var e = !1;
                i.each(n.COMPONENTS, function(n) {
                    if (!i.isUndefined(t[n]) && !i.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {}
                }, this), e && i.extend(this.__color.__state, t)
            }
            i.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
            var a = .5 > this.__color.v || .5 < this.__color.s ? 255 : 0,
                s = 255 - a;
            i.extend(this.__field_knob.style, {
                marginLeft: 100 * this.__color.s - 7 + "px",
                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                backgroundColor: this.__temp.toString(),
                border: this.__field_knob_border + "rgb(" + a + "," + a + "," + a + ")"
            }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, o(this.__saturation_field, "left", "#fff", this.__temp.toString()), i.extend(this.__input.style, {
                backgroundColor: this.__input.value = this.__color.toString(),
                color: "rgb(" + a + "," + a + "," + a + ")",
                textShadow: this.__input_textShadow + "rgba(" + s + "," + s + "," + s + ",.7)"
            })
        }
    });
    var s = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
    return a
}(dat.controllers.Controller, dat.dom.dom, dat.color.Color = function(t, e, n, r) {
    function i(t, e, n) {
        Object.defineProperty(t, e, {
            get: function() {
                return "RGB" === this.__state.space ? this.__state[e] : (a(this, e, n), this.__state[e])
            },
            set: function(t) {
                "RGB" !== this.__state.space && (a(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
            }
        })
    }

    function o(t, e) {
        Object.defineProperty(t, e, {
            get: function() {
                return "HSV" === this.__state.space ? this.__state[e] : (s(this), this.__state[e])
            },
            set: function(t) {
                "HSV" !== this.__state.space && (s(this), this.__state.space = "HSV"), this.__state[e] = t
            }
        })
    }

    function a(t, n, i) {
        if ("HEX" === t.__state.space) t.__state[n] = e.component_from_hex(t.__state.hex, i);
        else {
            if ("HSV" !== t.__state.space) throw "Corrupted color state";
            r.extend(t.__state, e.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }

    function s(t) {
        var n = e.rgb_to_hsv(t.r, t.g, t.b);
        r.extend(t.__state, {
            s: n.s,
            v: n.v
        }), r.isNaN(n.h) ? r.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = n.h
    }
    var u = function() {
        if (this.__state = t.apply(this, arguments), !1 === this.__state) throw "Failed to interpret color arguments";
        this.__state.a = this.__state.a || 1
    };
    return u.COMPONENTS = "r g b h s v hex a".split(" "), r.extend(u.prototype, {
        toString: function() {
            return n(this)
        },
        toOriginal: function() {
            return this.__state.conversion.write(this)
        }
    }), i(u.prototype, "r", 2), i(u.prototype, "g", 1), i(u.prototype, "b", 0), o(u.prototype, "h"), o(u.prototype, "s"), o(u.prototype, "v"), Object.defineProperty(u.prototype, "a", {
        get: function() {
            return this.__state.a
        },
        set: function(t) {
            this.__state.a = t
        }
    }), Object.defineProperty(u.prototype, "hex", {
        get: function() {
            return "HEX" !== !this.__state.space && (this.__state.hex = e.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
        },
        set: function(t) {
            this.__state.space = "HEX", this.__state.hex = t
        }
    }), u
}(dat.color.interpret, dat.color.math = function() {
    var t;
    return {
        hsv_to_rgb: function(t, e, n) {
            var r = t / 60 - Math.floor(t / 60),
                i = n * (1 - e),
                o = n * (1 - r * e);
            return {
                r: 255 * (t = [
                    [n, e = n * (1 - (1 - r) * e), i],
                    [o, n, i],
                    [i, n, e],
                    [i, o, n],
                    [e, i, n],
                    [n, i, o]
                ][Math.floor(t / 60) % 6])[0],
                g: 255 * t[1],
                b: 255 * t[2]
            }
        },
        rgb_to_hsv: function(t, e, n) {
            var r = Math.min(t, e, n),
                i = Math.max(t, e, n);
            r = i - r;
            return 0 == i ? {
                h: NaN,
                s: 0,
                v: 0
            } : (0 > (t = (t == i ? (e - n) / r : e == i ? 2 + (n - t) / r : 4 + (t - e) / r) / 6) && (t += 1), {
                h: 360 * t,
                s: r / i,
                v: i / 255
            })
        },
        rgb_to_hex: function(t, e, n) {
            return t = this.hex_with_component(0, 2, t), t = this.hex_with_component(t, 1, e), this.hex_with_component(t, 0, n)
        },
        component_from_hex: function(t, e) {
            return t >> 8 * e & 255
        },
        hex_with_component: function(e, n, r) {
            return r << (t = 8 * n) | e & ~(255 << t)
        }
    }
}(), dat.color.toString, dat.utils.common), dat.color.interpret, dat.utils.common), dat.utils.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t, e) {
    window.setTimeout(t, 1e3 / 60)
}, dat.dom.CenteredDiv = function(t, e) {
    var n = function() {
        this.backgroundElement = document.createElement("div"), e.extend(this.backgroundElement.style, {
            backgroundColor: "rgba(0,0,0,0.8)",
            top: 0,
            left: 0,
            display: "none",
            zIndex: "1000",
            opacity: 0,
            WebkitTransition: "opacity 0.2s linear"
        }), t.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), e.extend(this.domElement.style, {
            position: "fixed",
            display: "none",
            zIndex: "1001",
            opacity: 0,
            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear"
        }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
        var n = this;
        t.bind(this.backgroundElement, "click", function() {
            n.hide()
        })
    };
    return n.prototype.show = function() {
        var t = this;
        this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), e.defer(function() {
            t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
        })
    }, n.prototype.hide = function() {
        var e = this,
            n = function() {
                e.domElement.style.display = "none", e.backgroundElement.style.display = "none", t.unbind(e.domElement, "webkitTransitionEnd", n), t.unbind(e.domElement, "transitionend", n), t.unbind(e.domElement, "oTransitionEnd", n)
            };
        t.bind(this.domElement, "webkitTransitionEnd", n), t.bind(this.domElement, "transitionend", n), t.bind(this.domElement, "oTransitionEnd", n), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
    }, n.prototype.layout = function() {
        this.domElement.style.left = window.innerWidth / 2 - t.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - t.getHeight(this.domElement) / 2 + "px"
    }, n
}(dat.dom.dom, dat.utils.common), dat.dom.dom, dat.utils.common), define("libs/dat.gui", function() {}), define("graph/render/g9/lightUp", ["libs/three", "libs/dat.gui"], function(t) {
    "use strict";
    return function(t, e) {
        var n = t;

        function r(t) {
            return function(e) {
                "string" == typeof e && (e = e.replace("#", "0x")), t.setHex(e)
            }
        }
        this.addAmbientLight = function(t) {
            var e = new THREE.AmbientLight(t);
            return n.add(e), e
        }, this.addDirectionalLight = function(t, e, r) {
            var i = new THREE.DirectionalLight(t, e);
            return i.position.set(r.x, r.y, r.z), n.add(i), new THREE.DirectionalLightHelper(i, 3), i
        }, this.addHemisphereLight = function(t, e, r) {
            var i = new THREE.HemisphereLight(t, e, r);
            return n.add(i), i
        }, this.addPointLight = function(t, e, r, i, o) {
            var a = new THREE.PointLight(t, e, r, i);
            a.position.set(o.x, o.y, o.z), n.add(a);
            var s = new THREE.PointLightHelper(a, 1);
            return n.add(s), a
        }, this.addSpotLight = function(t, e, r) {
            var i = new THREE.SpotLight(16777215);
            i.position.set(e.x, e.y, e.z), i.castShadow = r, i.shadowMapWidth = 1024, i.shadowMapHeight = 1024, i.shadowCameraNear = 500, i.shadowCameraFar = 4e3, i.shadowCameraFov = 30, n.add(i);
            var o = new THREE.SpotLightHelper(i);
            return n.add(o), i
        };
        var i = new dat.GUI({
            autoPlace: !1
        });
        this.lights = [];
        var o = this.addHemisphereLight(16777215, 16777215, 1.25);
        o.color.setHSL(.6, 1, .75), o.groundColor.setHSL(.1, .8, .7), o.position.y = 5100, (s = i.addFolder("HemisphereLight")).add(o, "visible"), this.lights.push(o);
        var a = this.addDirectionalLight("#ffffff", 1, {
            x: 0,
            y: 0,
            z: 10
        });
        (s = i.addFolder("DirectionalLight")).addColor({
            color: a.color.getHex()
        }, "color").onChange(r(a.color)), s.add(a, "intensity", 0, 1), s.add(a.position, "x", -2e3, 2e3).step(1), s.add(a.position, "y", -2e3, 2e3).step(1), s.add(a.position, "z", -2e3, 2e3).step(1), s.add(a, "visible"), this.lights.push(a);
        a = this.addDirectionalLight("#ffffff", 1, {
            x: 0,
            y: 0,
            z: -10
        });
        (s = i.addFolder("DirectionalLight11")).addColor({
            color: a.color.getHex()
        }, "color").onChange(r(a.color)), s.add(a, "intensity", 0, 1), s.add(a.position, "x", -2e3, 2e3).step(1), s.add(a.position, "y", -2e3, 2e3).step(1), s.add(a.position, "z", -2e3, 2e3).step(1), s.add(a, "visible"), this.lights.push(a);
        a = this.addDirectionalLight("#ffffff", 1, {
            x: 0,
            y: 0,
            z: 1500
        });
        (s = i.addFolder("DirectionalLight3")).addColor({
            color: a.color.getHex()
        }, "color").onChange(r(a.color)), s.add(a, "intensity", 0, 1), s.add(a.position, "x", -2e3, 2e3).step(1), s.add(a.position, "y", -2e3, 2e3).step(1), s.add(a.position, "z", -2e3, 2e3).step(1), s.add(a, "visible"), this.lights.push(a);
        a = this.addDirectionalLight("#ffffff", 1, {
            x: 0,
            y: 0,
            z: -1500
        });
        (s = i.addFolder("DirectionalLight4")).addColor({
            color: a.color.getHex()
        }, "color").onChange(r(a.color)), s.add(a, "intensity", 0, 1), s.add(a.position, "x", -2e3, 2e3).step(1), s.add(a.position, "y", -2e3, 2e3).step(1), s.add(a.position, "z", -2e3, 2e3).step(1), s.add(a, "visible"), this.lights.push(a);
        var s;
        a = new THREE.AmbientLight(4210752);
        (s = i.addFolder("AmbientLight")).addColor({
            color: a.color.getHex()
        }, "color").onChange(r(a.color)), s.add(a, "visible"), this.lights.push(a), i.close()
    }
}), d3 = function() {
    function t(t) {
        return null != t && !isNaN(t)
    }

    function e(t) {
        return t.length
    }

    function n(t, e) {
        try {
            for (var n in e) Object.defineProperty(t.prototype, n, {
                value: e[n],
                enumerable: !1
            })
        } catch (n) {
            t.prototype = e
        }
    }

    function r() {}

    function i() {}

    function o(t, e, n) {
        return function() {
            var r = n.apply(e, arguments);
            return r === e ? t : r
        }
    }

    function a(t, e) {
        if (e in t) return e;
        e = e.charAt(0).toUpperCase() + e.substring(1);
        for (var n = 0, r = si.length; r > n; ++n) {
            var i = si[n] + e;
            if (i in t) return i
        }
    }

    function s() {}

    function u() {}

    function h(t) {
        function e() {
            for (var e, r = n, i = -1, o = r.length; ++i < o;)(e = r[i].on) && e.apply(this, arguments);
            return t
        }
        var n = [],
            i = new r;
        return e.on = function(e, r) {
            var o, a = i.get(e);
            return arguments.length < 2 ? a && a.on : (a && (a.on = null, n = n.slice(0, o = n.indexOf(a)).concat(n.slice(o + 1)), i.remove(e)), r && n.push(i.set(e, {
                on: r
            })), t)
        }, e
    }

    function c() {
        qr.event.preventDefault()
    }

    function l() {
        for (var t, e = qr.event; t = e.sourceEvent;) e = t;
        return e
    }

    function p(t) {
        for (var e = new u, n = 0, r = arguments.length; ++n < r;) e[arguments[n]] = h(e);
        return e.of = function(n, r) {
            return function(i) {
                try {
                    var o = i.sourceEvent = qr.event;
                    i.target = t, qr.event = i, e[i.type].apply(n, r)
                } finally {
                    qr.event = o
                }
            }
        }, e
    }

    function f(t) {
        return hi(t, di), t
    }

    function d(t) {
        return "function" == typeof t ? t : function() {
            return ci(t, this)
        }
    }

    function E(t) {
        return "function" == typeof t ? t : function() {
            return li(t, this)
        }
    }

    function m(t, e) {
        return t = qr.ns.qualify(t), null == e ? t.local ? function() {
            this.removeAttributeNS(t.space, t.local)
        } : function() {
            this.removeAttribute(t)
        } : "function" == typeof e ? t.local ? function() {
            var n = e.apply(this, arguments);
            null == n ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, n)
        } : function() {
            var n = e.apply(this, arguments);
            null == n ? this.removeAttribute(t) : this.setAttribute(t, n)
        } : t.local ? function() {
            this.setAttributeNS(t.space, t.local, e)
        } : function() {
            this.setAttribute(t, e)
        }
    }

    function g(t) {
        return t.trim().replace(/\s+/g, " ")
    }

    function v(t) {
        return new RegExp("(?:^|\\s+)" + qr.requote(t) + "(?:\\s+|$)", "g")
    }

    function y(t, e) {
        var n = (t = t.trim().split(/\s+/).map(T)).length;
        return "function" == typeof e ? function() {
            for (var r = -1, i = e.apply(this, arguments); ++r < n;) t[r](this, i)
        } : function() {
            for (var r = -1; ++r < n;) t[r](this, e)
        }
    }

    function T(t) {
        var e = v(t);
        return function(n, r) {
            if (i = n.classList) return r ? i.add(t) : i.remove(t);
            var i = n.getAttribute("class") || "";
            r ? (e.lastIndex = 0, e.test(i) || n.setAttribute("class", g(i + " " + t))) : n.setAttribute("class", g(i.replace(e, " ")))
        }
    }

    function R(t, e, n) {
        return null == e ? function() {
            this.style.removeProperty(t)
        } : "function" == typeof e ? function() {
            var r = e.apply(this, arguments);
            null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, n)
        } : function() {
            this.style.setProperty(t, e, n)
        }
    }

    function x(t, e) {
        return null == e ? function() {
            delete this[t]
        } : "function" == typeof e ? function() {
            var n = e.apply(this, arguments);
            null == n ? delete this[t] : this[t] = n
        } : function() {
            this[t] = e
        }
    }

    function b(t) {
        return "function" == typeof t ? t : (t = qr.ns.qualify(t)).local ? function() {
            return Zr.createElementNS(t.space, t.local)
        } : function() {
            return Zr.createElementNS(this.namespaceURI, t)
        }
    }

    function H(t) {
        return {
            __data__: t
        }
    }

    function _(t) {
        return function() {
            return fi(this, t)
        }
    }

    function w(t, e) {
        for (var n = 0, r = t.length; r > n; n++)
            for (var i, o = t[n], a = 0, s = o.length; s > a; a++)(i = o[a]) && e(i, a, n);
        return t
    }

    function M(t) {
        return hi(t, mi), t
    }

    function S() {
        var t = this.__transition__;
        t && ++t.active
    }

    function A(t, e, n) {
        function r() {
            var e = this[i];
            e && (this.removeEventListener(t, e, e.$), delete this[i])
        }
        var i = "__on" + t,
            o = t.indexOf("."),
            a = C;
        o > 0 && (t = t.substring(0, o));
        var u = vi.get(t);
        return u && (t = u, a = L), o ? e ? function() {
            var o = a(e, Kr(arguments));
            r.call(this), this.addEventListener(t, this[i] = o, o.$ = n), o._ = e
        } : r : e ? s : function() {
            var e, n = new RegExp("^__on([^.]+)" + qr.requote(t) + "$");
            for (var r in this)
                if (e = r.match(n)) {
                    var i = this[r];
                    this.removeEventListener(e[1], i, i.$), delete this[r]
                }
        }
    }

    function C(t, e) {
        return function(n) {
            var r = qr.event;
            qr.event = n, e[0] = this.__data__;
            try {
                t.apply(this, e)
            } finally {
                qr.event = r
            }
        }
    }

    function L(t, e) {
        var n = C(t, e);
        return function(t) {
            var e = this,
                r = t.relatedTarget;
            r && (r === e || 8 & r.compareDocumentPosition(e)) || n.call(e, t)
        }
    }

    function k() {
        var t = ".dragsuppress-" + ++Ti,
            e = "touchmove" + t,
            n = "selectstart" + t,
            r = "dragstart" + t,
            i = "click" + t,
            o = qr.select(Jr).on(e, c).on(n, c).on(r, c),
            a = Qr.style,
            s = a[yi];
        return a[yi] = "none",
            function(e) {
                function n() {
                    o.on(i, null)
                }
                o.on(t, null), a[yi] = s, e && (o.on(i, function() {
                    c(), n()
                }, !0), setTimeout(n, 0))
            }
    }

    function P(t, e) {
        e.changedTouches && (e = e.changedTouches[0]);
        var n = t.ownerSVGElement || t;
        if (n.createSVGPoint) {
            var r = n.createSVGPoint();
            if (0 > Ri && (Jr.scrollX || Jr.scrollY)) {
                var i = (n = qr.select("body").append("svg").style({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    margin: 0,
                    padding: 0,
                    border: "none"
                }, "important"))[0][0].getScreenCTM();
                Ri = !(i.f || i.e), n.remove()
            }
            return Ri ? (r.x = e.pageX, r.y = e.pageY) : (r.x = e.clientX, r.y = e.clientY), [(r = r.matrixTransform(t.getScreenCTM().inverse())).x, r.y]
        }
        var o = t.getBoundingClientRect();
        return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop]
    }

    function D(t) {
        return t > 0 ? 1 : 0 > t ? -1 : 0
    }

    function N(t) {
        return t > 1 ? 0 : -1 > t ? xi : Math.acos(t)
    }

    function F(t) {
        return t > 1 ? Hi : -1 > t ? -Hi : Math.asin(t)
    }

    function O(t) {
        return ((t = Math.exp(t)) - 1 / t) / 2
    }

    function V(t) {
        return ((t = Math.exp(t)) + 1 / t) / 2
    }

    function U(t) {
        return (t = Math.sin(t / 2)) * t
    }

    function B() {}

    function I(t, e, n) {
        return new z(t, e, n)
    }

    function z(t, e, n) {
        this.h = t, this.s = e, this.l = n
    }

    function G(t, e, n) {
        function r(t) {
            return Math.round(255 * function(t) {
                return t > 360 ? t -= 360 : 0 > t && (t += 360), 60 > t ? i + (o - i) * t / 60 : 180 > t ? o : 240 > t ? i + (o - i) * (240 - t) / 60 : i
            }(t))
        }
        var i, o;
        return t = isNaN(t) ? 0 : (t %= 360) < 0 ? t + 360 : t, e = isNaN(e) ? 0 : 0 > e ? 0 : e > 1 ? 1 : e, i = 2 * (n = 0 > n ? 0 : n > 1 ? 1 : n) - (o = .5 >= n ? n * (1 + e) : n + e - n * e), nt(r(t + 120), r(t), r(t - 120))
    }

    function j(t, e, n) {
        return new W(t, e, n)
    }

    function W(t, e, n) {
        this.h = t, this.c = e, this.l = n
    }

    function X(t, e, n) {
        return isNaN(t) && (t = 0), isNaN(e) && (e = 0), q(n, Math.cos(t *= Mi) * e, Math.sin(t) * e)
    }

    function q(t, e, n) {
        return new Y(t, e, n)
    }

    function Y(t, e, n) {
        this.l = t, this.a = e, this.b = n
    }

    function K(t, e, n) {
        var r = (t + 16) / 116,
            i = r + e / 500,
            o = r - n / 200;
        return nt($(3.2404542 * (i = Q(i) * Oi) - 1.5371385 * (r = Q(r) * Vi) - .4985314 * (o = Q(o) * Ui)), $(-.969266 * i + 1.8760108 * r + .041556 * o), $(.0556434 * i - .2040259 * r + 1.0572252 * o))
    }

    function Z(t, e, n) {
        return t > 0 ? j(Math.atan2(n, e) * Si, Math.sqrt(e * e + n * n), t) : j(NaN, NaN, t)
    }

    function Q(t) {
        return t > .206893034 ? t * t * t : (t - 4 / 29) / 7.787037
    }

    function J(t) {
        return t > .008856 ? Math.pow(t, 1 / 3) : 7.787037 * t + 4 / 29
    }

    function $(t) {
        return Math.round(255 * (.00304 >= t ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055))
    }

    function tt(t) {
        return nt(t >> 16, 255 & t >> 8, 255 & t)
    }

    function et(t) {
        return tt(t) + ""
    }

    function nt(t, e, n) {
        return new rt(t, e, n)
    }

    function rt(t, e, n) {
        this.r = t, this.g = e, this.b = n
    }

    function it(t) {
        return 16 > t ? "0" + Math.max(0, t).toString(16) : Math.min(255, t).toString(16)
    }

    function ot(t, e, n) {
        var r, i, o, a = 0,
            s = 0,
            u = 0;
        if (r = /([a-z]+)\((.*)\)/i.exec(t)) switch (i = r[2].split(","), r[1]) {
            case "hsl":
                return n(parseFloat(i[0]), parseFloat(i[1]) / 100, parseFloat(i[2]) / 100);
            case "rgb":
                return e(ht(i[0]), ht(i[1]), ht(i[2]))
        }
        return (o = zi.get(t)) ? e(o.r, o.g, o.b) : (null != t && "#" === t.charAt(0) && (4 === t.length ? (a = t.charAt(1), a += a, s = t.charAt(2), s += s, u = t.charAt(3), u += u) : 7 === t.length && (a = t.substring(1, 3), s = t.substring(3, 5), u = t.substring(5, 7)), a = parseInt(a, 16), s = parseInt(s, 16), u = parseInt(u, 16)), e(a, s, u))
    }

    function at(t, e, n) {
        var r, i, o = Math.min(t /= 255, e /= 255, n /= 255),
            a = Math.max(t, e, n),
            s = a - o,
            u = (a + o) / 2;
        return s ? (i = .5 > u ? s / (a + o) : s / (2 - a - o), r = t == a ? (e - n) / s + (n > e ? 6 : 0) : e == a ? (n - t) / s + 2 : (t - e) / s + 4, r *= 60) : (r = NaN, i = u > 0 && 1 > u ? 0 : r), I(r, i, u)
    }

    function st(t, e, n) {
        var r = J((.4124564 * (t = ut(t)) + .3575761 * (e = ut(e)) + .1804375 * (n = ut(n))) / Oi),
            i = J((.2126729 * t + .7151522 * e + .072175 * n) / Vi);
        return q(116 * i - 16, 500 * (r - i), 200 * (i - J((.0193339 * t + .119192 * e + .9503041 * n) / Ui)))
    }

    function ut(t) {
        return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
    }

    function ht(t) {
        var e = parseFloat(t);
        return "%" === t.charAt(t.length - 1) ? Math.round(2.55 * e) : e
    }

    function ct(t) {
        return "function" == typeof t ? t : function() {
            return t
        }
    }

    function lt(t) {
        return t
    }

    function pt(t) {
        return function(e, n, r) {
            return 2 === arguments.length && "function" == typeof n && (r = n, n = null), ft(e, n, t, r)
        }
    }

    function ft(t, e, n, r) {
        function i() {
            var t, e = u.status;
            if (!e && u.responseText || e >= 200 && 300 > e || 304 === e) {
                try {
                    t = n.call(o, u)
                } catch (t) {
                    return void a.error.call(o, t)
                }
                a.load.call(o, t)
            } else a.error.call(o, u)
        }
        var o = {},
            a = qr.dispatch("beforesend", "progress", "load", "error"),
            s = {},
            u = new XMLHttpRequest,
            h = null;
        return !Jr.XDomainRequest || "withCredentials" in u || !/^(http(s)?:)?\/\//.test(t) || (u = new XDomainRequest), "onload" in u ? u.onload = u.onerror = i : u.onreadystatechange = function() {
            u.readyState > 3 && i()
        }, u.onprogress = function(t) {
            var e = qr.event;
            qr.event = t;
            try {
                a.progress.call(o, u)
            } finally {
                qr.event = e
            }
        }, o.header = function(t, e) {
            return t = (t + "").toLowerCase(), arguments.length < 2 ? s[t] : (null == e ? delete s[t] : s[t] = e + "", o)
        }, o.mimeType = function(t) {
            return arguments.length ? (e = null == t ? null : t + "", o) : e
        }, o.responseType = function(t) {
            return arguments.length ? (h = t, o) : h
        }, o.response = function(t) {
            return n = t, o
        }, ["get", "post"].forEach(function(t) {
            o[t] = function() {
                return o.send.apply(o, [t].concat(Kr(arguments)))
            }
        }), o.send = function(n, r, i) {
            if (2 === arguments.length && "function" == typeof r && (i = r, r = null), u.open(n, t, !0), null == e || "accept" in s || (s.accept = e + ",*/*"), u.setRequestHeader)
                for (var c in s) u.setRequestHeader(c, s[c]);
            return null != e && u.overrideMimeType && u.overrideMimeType(e), null != h && (u.responseType = h), null != i && o.on("error", i).on("load", function(t) {
                i(null, t)
            }), a.beforesend.call(o, u), u.send(null == r ? null : r), o
        }, o.abort = function() {
            return u.abort(), o
        }, qr.rebind(o, a, "on"), null == r ? o : o.get(function(t) {
            return 1 === t.length ? function(e, n) {
                t(null == e ? n : null)
            } : t
        }(r))
    }

    function dt() {
        var t = mt(),
            e = gt() - t;
        e > 24 ? (isFinite(e) && (clearTimeout(Xi), Xi = setTimeout(dt, e)), Wi = 0) : (Wi = 1, Yi(dt))
    }

    function Et(t, e, n) {
        var r = arguments.length;
        2 > r && (e = 0), 3 > r && (n = Date.now()), qi.callback = t, qi.time = n + e
    }

    function mt() {
        var t = Date.now();
        for (qi = Gi; qi;) t >= qi.time && (qi.flush = qi.callback(t - qi.time)), qi = qi.next;
        return t
    }

    function gt() {
        for (var t, e = Gi, n = 1 / 0; e;) e.flush ? e = t ? t.next = e.next : Gi = e.next : (e.time < n && (n = e.time), e = (t = e).next);
        return ji = t, n
    }

    function vt(t, e) {
        return e - (t ? Math.ceil(Math.log(t) / Math.LN10) : 1)
    }

    function yt(t) {
        return t + ""
    }

    function Tt() {}

    function Rt(t, e, n) {
        var r = n.s = t + e,
            i = r - t,
            o = r - i;
        n.t = t - o + (e - i)
    }

    function xt(t, e) {
        t && ro.hasOwnProperty(t.type) && ro[t.type](t, e)
    }

    function bt(t, e, n) {
        var r, i = -1,
            o = t.length - n;
        for (e.lineStart(); ++i < o;) r = t[i], e.point(r[0], r[1], r[2]);
        e.lineEnd()
    }

    function Ht(t, e) {
        var n = -1,
            r = t.length;
        for (e.polygonStart(); ++n < r;) bt(t[n], e, 1);
        e.polygonEnd()
    }

    function _t() {
        function t(t, e) {
            e = e * Mi / 2 + xi / 4;
            var n = (t *= Mi) - r,
                a = Math.cos(e),
                s = Math.sin(e),
                u = o * s,
                h = i * a + u * Math.cos(n),
                c = u * Math.sin(n);
            oo.add(Math.atan2(c, h)), r = t, i = a, o = s
        }
        var e, n, r, i, o;
        ao.point = function(a, s) {
            ao.point = t, r = (e = a) * Mi, i = Math.cos(s = (n = s) * Mi / 2 + xi / 4), o = Math.sin(s)
        }, ao.lineEnd = function() {
            t(e, n)
        }
    }

    function wt(t) {
        var e = t[0],
            n = t[1],
            r = Math.cos(n);
        return [r * Math.cos(e), r * Math.sin(e), Math.sin(n)]
    }

    function Mt(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function St(t, e) {
        return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
    }

    function At(t, e) {
        t[0] += e[0], t[1] += e[1], t[2] += e[2]
    }

    function Ct(t, e) {
        return [t[0] * e, t[1] * e, t[2] * e]
    }

    function Lt(t) {
        var e = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
        t[0] /= e, t[1] /= e, t[2] /= e
    }

    function kt(t) {
        return [Math.atan2(t[1], t[0]), F(t[2])]
    }

    function Pt(t, e) {
        return Math.abs(t[0] - e[0]) < _i && Math.abs(t[1] - e[1]) < _i
    }

    function Dt(t, e) {
        t *= Mi;
        var n = Math.cos(e *= Mi);
        Nt(n * Math.cos(t), n * Math.sin(t), Math.sin(e))
    }

    function Nt(t, e, n) {
        ho += (t - ho) / ++so, co += (e - co) / so, lo += (n - lo) / so
    }

    function Ft() {
        function t(t, i) {
            t *= Mi;
            var o = Math.cos(i *= Mi),
                a = o * Math.cos(t),
                s = o * Math.sin(t),
                u = Math.sin(i),
                h = Math.atan2(Math.sqrt((h = n * u - r * s) * h + (h = r * a - e * u) * h + (h = e * s - n * a) * h), e * a + n * s + r * u);
            uo += h, po += h * (e + (e = a)), fo += h * (n + (n = s)), Eo += h * (r + (r = u)), Nt(e, n, r)
        }
        var e, n, r;
        yo.point = function(i, o) {
            i *= Mi;
            var a = Math.cos(o *= Mi);
            e = a * Math.cos(i), n = a * Math.sin(i), r = Math.sin(o), yo.point = t, Nt(e, n, r)
        }
    }

    function Ot() {
        yo.point = Dt
    }

    function Vt() {
        function t(t, e) {
            t *= Mi;
            var n = Math.cos(e *= Mi),
                a = n * Math.cos(t),
                s = n * Math.sin(t),
                u = Math.sin(e),
                h = i * u - o * s,
                c = o * a - r * u,
                l = r * s - i * a,
                p = Math.sqrt(h * h + c * c + l * l),
                f = r * a + i * s + o * u,
                d = p && -N(f) / p,
                E = Math.atan2(p, f);
            mo += d * h, go += d * c, vo += d * l, uo += E, po += E * (r + (r = a)), fo += E * (i + (i = s)), Eo += E * (o + (o = u)), Nt(r, i, o)
        }
        var e, n, r, i, o;
        yo.point = function(a, s) {
            e = a, n = s, yo.point = t, a *= Mi;
            var u = Math.cos(s *= Mi);
            r = u * Math.cos(a), i = u * Math.sin(a), o = Math.sin(s), Nt(r, i, o)
        }, yo.lineEnd = function() {
            t(e, n), yo.lineEnd = Ot, yo.point = Dt
        }
    }

    function Ut() {
        return !0
    }

    function Bt(t, e, n, r, i) {
        var o = [],
            a = [];
        if (t.forEach(function(t) {
                if (!((e = t.length - 1) <= 0)) {
                    var e, n = t[0],
                        r = t[e];
                    if (Pt(n, r)) {
                        i.lineStart();
                        for (var s = 0; e > s; ++s) i.point((n = t[s])[0], n[1]);
                        return void i.lineEnd()
                    }
                    var u = {
                            point: n,
                            points: t,
                            other: null,
                            visited: !1,
                            entry: !0,
                            subject: !0
                        },
                        h = {
                            point: n,
                            points: [n],
                            other: u,
                            visited: !1,
                            entry: !1,
                            subject: !1
                        };
                    u.other = h, o.push(u), a.push(h), h = {
                        point: r,
                        points: [r],
                        other: u = {
                            point: r,
                            points: [r],
                            other: null,
                            visited: !1,
                            entry: !1,
                            subject: !0
                        },
                        visited: !1,
                        entry: !0,
                        subject: !1
                    }, u.other = h, o.push(u), a.push(h)
                }
            }), a.sort(e), It(o), It(a), o.length) {
            for (var s = 0, u = n, h = a.length; h > s; ++s) a[s].entry = u = !u;
            for (var c, l, p, f = o[0];;) {
                for (c = f; c.visited;)
                    if ((c = c.next) === f) return;
                l = c.points, i.lineStart();
                do {
                    if (c.visited = c.other.visited = !0, c.entry) {
                        if (c.subject)
                            for (s = 0; s < l.length; s++) i.point((p = l[s])[0], p[1]);
                        else r(c.point, c.next.point, 1, i);
                        c = c.next
                    } else {
                        if (c.subject)
                            for (s = (l = c.prev.points).length; --s >= 0;) i.point((p = l[s])[0], p[1]);
                        else r(c.point, c.prev.point, -1, i);
                        c = c.prev
                    }
                    l = (c = c.other).points
                } while (!c.visited);
                i.lineEnd()
            }
        }
    }

    function It(t) {
        if (e = t.length) {
            for (var e, n, r = 0, i = t[0]; ++r < e;) i.next = n = t[r], n.prev = i, i = n;
            i.next = n = t[0], n.prev = i
        }
    }

    function zt(t, e, n, r) {
        return function(i, o) {
            function a(e, n) {
                var r = i(e, n);
                t(e = r[0], n = r[1]) && o.point(e, n)
            }

            function s(t, e) {
                var n = i(t, e);
                m.point(n[0], n[1])
            }

            function u() {
                v.point = s, m.lineStart()
            }

            function h() {
                v.point = a, m.lineEnd()
            }

            function c(t, e) {
                E.push([t, e]);
                var n = i(t, e);
                T.point(n[0], n[1])
            }

            function l() {
                T.lineStart(), E = []
            }

            function p() {
                c(E[0][0], E[0][1]), T.lineEnd();
                var t, e = T.clean(),
                    n = y.buffer(),
                    r = n.length;
                if (E.pop(), d.push(E), E = null, r) {
                    if (1 & e) {
                        r = (t = n[0]).length - 1;
                        var i, a = -1;
                        for (o.lineStart(); ++a < r;) o.point((i = t[a])[0], i[1]);
                        return void o.lineEnd()
                    }
                    r > 1 && 2 & e && n.push(n.pop().concat(n.shift())), f.push(n.filter(Gt))
                }
            }
            var f, d, E, m = e(o),
                g = i.invert(r[0], r[1]),
                v = {
                    point: a,
                    lineStart: u,
                    lineEnd: h,
                    polygonStart: function() {
                        v.point = c, v.lineStart = l, v.lineEnd = p, f = [], d = [], o.polygonStart()
                    },
                    polygonEnd: function() {
                        v.point = a, v.lineStart = u, v.lineEnd = h, f = qr.merge(f);
                        var t = function(t, e) {
                            var n = t[0],
                                r = t[1],
                                i = [Math.sin(n), -Math.cos(n), 0],
                                o = 0,
                                a = 0;
                            oo.reset();
                            for (var s = 0, u = e.length; u > s; ++s) {
                                var h = e[s],
                                    c = h.length;
                                if (c)
                                    for (var l = h[0], p = l[0], f = l[1] / 2 + xi / 4, d = Math.sin(f), E = Math.cos(f), m = 1;;) {
                                        m === c && (m = 0);
                                        var g = (t = h[m])[0],
                                            v = t[1] / 2 + xi / 4,
                                            y = Math.sin(v),
                                            T = Math.cos(v),
                                            R = g - p,
                                            x = Math.abs(R) > xi,
                                            b = d * y;
                                        if (oo.add(Math.atan2(b * Math.sin(R), E * T + b * Math.cos(R))), o += x ? R + (R >= 0 ? 2 : -2) * xi : R, x ^ p >= n ^ g >= n) {
                                            var H = St(wt(l), wt(t));
                                            Lt(H);
                                            var _ = St(i, H);
                                            Lt(_);
                                            var w = (x ^ R >= 0 ? -1 : 1) * F(_[2]);
                                            (r > w || r === w && (H[0] || H[1])) && (a += x ^ R >= 0 ? 1 : -1)
                                        }
                                        if (!m++) break;
                                        p = g, d = y, E = T, l = t
                                    }
                            }
                            return (-_i > o || _i > o && 0 > oo) ^ 1 & a
                        }(g, d);
                        f.length ? Bt(f, Wt, t, n, o) : t && (o.lineStart(), n(null, null, 1, o), o.lineEnd()), o.polygonEnd(), f = d = null
                    },
                    sphere: function() {
                        o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd()
                    }
                },
                y = jt(),
                T = e(y);
            return v
        }
    }

    function Gt(t) {
        return t.length > 1
    }

    function jt() {
        var t, e = [];
        return {
            lineStart: function() {
                e.push(t = [])
            },
            point: function(e, n) {
                t.push([e, n])
            },
            lineEnd: s,
            buffer: function() {
                var n = e;
                return e = [], t = null, n
            },
            rejoin: function() {
                e.length > 1 && e.push(e.pop().concat(e.shift()))
            }
        }
    }

    function Wt(t, e) {
        return ((t = t.point)[0] < 0 ? t[1] - Hi - _i : Hi - t[1]) - ((e = e.point)[0] < 0 ? e[1] - Hi - _i : Hi - e[1])
    }

    function Xt(t, e, n, r) {
        function i(r, i) {
            return Math.abs(r[0] - t) < _i ? i > 0 ? 0 : 3 : Math.abs(r[0] - n) < _i ? i > 0 ? 2 : 1 : Math.abs(r[1] - e) < _i ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2
        }

        function o(t, e) {
            return a(t.point, e.point)
        }

        function a(t, e) {
            var n = i(t, 1),
                r = i(e, 1);
            return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
        }

        function s(i, o) {
            var a = o[0] - i[0],
                s = o[1] - i[1],
                u = [0, 1];
            return Math.abs(a) < _i && Math.abs(s) < _i ? t <= i[0] && i[0] <= n && e <= i[1] && i[1] <= r : !!(qt(t - i[0], a, u) && qt(i[0] - n, -a, u) && qt(e - i[1], s, u) && qt(i[1] - r, -s, u)) && (u[1] < 1 && (o[0] = i[0] + u[1] * a, o[1] = i[1] + u[1] * s), u[0] > 0 && (i[0] += u[0] * a, i[1] += u[0] * s), !0)
        }
        return function(u) {
            function h(t, e, n) {
                return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1])
            }

            function c(o, s, u, h) {
                var c = 0,
                    l = 0;
                if (null == o || (c = i(o, u)) !== (l = i(s, u)) || a(o, s) < 0 ^ u > 0)
                    do {
                        h.point(0 === c || 3 === c ? t : n, c > 1 ? r : e)
                    } while ((c = (c + u + 4) % 4) !== l);
                else h.point(s[0], s[1])
            }

            function l(i, o) {
                return i >= t && n >= i && o >= e && r >= o
            }

            function p(t, e) {
                l(t, e) && u.point(t, e)
            }

            function f(t, e) {
                var n = l(t = Math.max(-Ro, Math.min(Ro, t)), e = Math.max(-Ro, Math.min(Ro, e)));
                if (E && m.push([t, e]), b) g = t, v = e, y = n, b = !1, n && (u.lineStart(), u.point(t, e));
                else if (n && x) u.point(t, e);
                else {
                    var r = [T, R],
                        i = [t, e];
                    s(r, i) ? (x || (u.lineStart(), u.point(r[0], r[1])), u.point(i[0], i[1]), n || u.lineEnd(), H = !1) : n && (u.lineStart(), u.point(t, e), H = !1)
                }
                T = t, R = e, x = n
            }
            var d, E, m, g, v, y, T, R, x, b, H, _ = u,
                w = jt(),
                M = {
                    point: p,
                    lineStart: function() {
                        M.point = f, E && E.push(m = []), b = !0, x = !1, T = R = NaN
                    },
                    lineEnd: function() {
                        d && (f(g, v), y && x && w.rejoin(), d.push(w.buffer())), M.point = p, x && u.lineEnd()
                    },
                    polygonStart: function() {
                        u = w, d = [], E = [], H = !0
                    },
                    polygonEnd: function() {
                        u = _, d = qr.merge(d);
                        var e = function(t) {
                                for (var e = 0, n = E.length, r = t[1], i = 0; n > i; ++i)
                                    for (var o, a = 1, s = E[i], u = s.length, c = s[0]; u > a; ++a) o = s[a], c[1] <= r ? o[1] > r && h(c, o, t) > 0 && ++e : o[1] <= r && h(c, o, t) < 0 && --e, c = o;
                                return 0 !== e
                            }([t, r]),
                            n = H && e,
                            i = d.length;
                        (n || i) && (u.polygonStart(), n && (u.lineStart(), c(null, null, 1, u), u.lineEnd()), i && Bt(d, o, e, c, u), u.polygonEnd()), d = E = m = null
                    }
                };
            return M
        }
    }

    function qt(t, e, n) {
        if (Math.abs(e) < _i) return 0 >= t;
        var r = t / e;
        if (e > 0) {
            if (r > n[1]) return !1;
            r > n[0] && (n[0] = r)
        } else {
            if (r < n[0]) return !1;
            r < n[1] && (n[1] = r)
        }
        return !0
    }

    function Yt(t, e) {
        function n(n, r) {
            return n = t(n, r), e(n[0], n[1])
        }
        return t.invert && e.invert && (n.invert = function(n, r) {
            return (n = e.invert(n, r)) && t.invert(n[0], n[1])
        }), n
    }

    function Kt(t) {
        var e = 0,
            n = xi / 3,
            r = ae(t),
            i = r(e, n);
        return i.parallels = function(t) {
            return arguments.length ? r(e = t[0] * xi / 180, n = t[1] * xi / 180) : [e / xi * 180, n / xi * 180]
        }, i
    }

    function Zt(t, e) {
        function n(t, e) {
            var n = Math.sqrt(o - 2 * i * Math.sin(e)) / i;
            return [n * Math.sin(t *= i), a - n * Math.cos(t)]
        }
        var r = Math.sin(t),
            i = (r + Math.sin(e)) / 2,
            o = 1 + r * (2 * i - r),
            a = Math.sqrt(o) / i;
        return n.invert = function(t, e) {
            var n = a - e;
            return [Math.atan2(t, n) / i, F((o - (t * t + n * n) * i * i) / (2 * i))]
        }, n
    }

    function Qt() {
        function t(t, e) {
            bo += i * t - r * e, r = t, i = e
        }
        var e, n, r, i;
        So.point = function(o, a) {
            So.point = t, e = r = o, n = i = a
        }, So.lineEnd = function() {
            t(e, n)
        }
    }

    function Jt(t) {
        return "m0," + t + "a" + t + "," + t + " 0 1,1 0," + -2 * t + "a" + t + "," + t + " 0 1,1 0," + 2 * t + "z"
    }

    function $t(t, e) {
        ho += t, co += e, ++lo
    }

    function te() {
        function t(t, r) {
            var i = t - e,
                o = r - n,
                a = Math.sqrt(i * i + o * o);
            po += a * (e + t) / 2, fo += a * (n + r) / 2, Eo += a, $t(e = t, n = r)
        }
        var e, n;
        Co.point = function(r, i) {
            Co.point = t, $t(e = r, n = i)
        }
    }

    function ee() {
        Co.point = $t
    }

    function ne() {
        function t(t, e) {
            var n = t - r,
                o = e - i,
                a = Math.sqrt(n * n + o * o);
            po += a * (r + t) / 2, fo += a * (i + e) / 2, Eo += a, mo += (a = i * t - r * e) * (r + t), go += a * (i + e), vo += 3 * a, $t(r = t, i = e)
        }
        var e, n, r, i;
        Co.point = function(o, a) {
            Co.point = t, $t(e = r = o, n = i = a)
        }, Co.lineEnd = function() {
            t(e, n)
        }
    }

    function re(t) {
        function e(e) {
            function r(n, r) {
                n = t(n, r), e.point(n[0], n[1])
            }

            function i() {
                v = NaN, b.point = a, e.lineStart()
            }

            function a(r, i) {
                var a = wt([r, i]),
                    s = t(r, i);
                n(v, y, g, T, R, x, v = s[0], y = s[1], g = r, T = a[0], R = a[1], x = a[2], o, e), e.point(v, y)
            }

            function s() {
                b.point = r, e.lineEnd()
            }

            function u() {
                i(), b.point = h, b.lineEnd = c
            }

            function h(t, e) {
                a(l = t, e), p = v, f = y, d = T, E = R, m = x, b.point = a
            }

            function c() {
                n(v, y, g, T, R, x, p, f, l, d, E, m, o, e), b.lineEnd = s, s()
            }
            var l, p, f, d, E, m, g, v, y, T, R, x, b = {
                point: r,
                lineStart: i,
                lineEnd: s,
                polygonStart: function() {
                    e.polygonStart(), b.lineStart = u
                },
                polygonEnd: function() {
                    e.polygonEnd(), b.lineStart = i
                }
            };
            return b
        }

        function n(e, o, a, s, u, h, c, l, p, f, d, E, m, g) {
            var v = c - e,
                y = l - o,
                T = v * v + y * y;
            if (T > 4 * r && m--) {
                var R = s + f,
                    x = u + d,
                    b = h + E,
                    H = Math.sqrt(R * R + x * x + b * b),
                    _ = Math.asin(b /= H),
                    w = Math.abs(Math.abs(b) - 1) < _i ? (a + p) / 2 : Math.atan2(x, R),
                    M = t(w, _),
                    S = M[0],
                    A = M[1],
                    C = S - e,
                    L = A - o,
                    k = y * C - v * L;
                (k * k / T > r || Math.abs((v * C + y * L) / T - .5) > .3 || i > s * f + u * d + h * E) && (n(e, o, a, s, u, h, S, A, w, R /= H, x /= H, b, m, g), g.point(S, A), n(S, A, w, R, x, b, c, l, p, f, d, E, m, g))
            }
        }
        var r = .5,
            i = Math.cos(30 * Mi),
            o = 16;
        return e.precision = function(t) {
            return arguments.length ? (o = (r = t * t) > 0 && 16, e) : Math.sqrt(r)
        }, e
    }

    function ie(t) {
        this.stream = t
    }

    function oe(t) {
        return ae(function() {
            return t
        })()
    }

    function ae(t) {
        function e(t) {
            return [(t = s(t[0] * Mi, t[1] * Mi))[0] * p + u, h - t[1] * p]
        }

        function n(t) {
            return (t = s.invert((t[0] - u) / p, (h - t[1]) / p)) && [t[0] * Si, t[1] * Si]
        }

        function r() {
            s = Yt(a = he(g, v, y), o);
            var t = o(E, m);
            return u = f - t[0] * p, h = d + t[1] * p, i()
        }

        function i() {
            return c && (c.valid = !1, c = null), e
        }
        var o, a, s, u, h, c, l = re(function(t, e) {
                return [(t = o(t, e))[0] * p + u, h - t[1] * p]
            }),
            p = 150,
            f = 480,
            d = 250,
            E = 0,
            m = 0,
            g = 0,
            v = 0,
            y = 0,
            T = To,
            R = lt,
            x = null,
            b = null;
        return e.stream = function(t) {
                return c && (c.valid = !1), (c = function(t) {
                    var e = new ie(t);
                    return e.point = function(e, n) {
                        t.point(e * Mi, n * Mi)
                    }, e
                }(T(a, l(R(t))))).valid = !0, c
            }, e.clipAngle = function(t) {
                return arguments.length ? (T = null == t ? (x = t, To) : function(t) {
                    function e(t, e) {
                        return Math.cos(t) * Math.cos(e) > i
                    }

                    function n(t, e, n) {
                        var r = [1, 0, 0],
                            o = St(wt(t), wt(e)),
                            a = Mt(o, o),
                            s = o[0],
                            u = a - s * s;
                        if (!u) return !n && t;
                        var h = i * a / u,
                            c = -i * s / u,
                            l = St(r, o),
                            p = Ct(r, h);
                        At(p, Ct(o, c));
                        var f = l,
                            d = Mt(p, f),
                            E = Mt(f, f),
                            m = d * d - E * (Mt(p, p) - 1);
                        if (!(0 > m)) {
                            var g = Math.sqrt(m),
                                v = Ct(f, (-d - g) / E);
                            if (At(v, p), v = kt(v), !n) return v;
                            var y, T = t[0],
                                R = e[0],
                                x = t[1],
                                b = e[1];
                            T > R && (y = T, T = R, R = y);
                            var H = R - T,
                                _ = Math.abs(H - xi) < _i;
                            if (!_ && x > b && (y = x, x = b, b = y), _ || _i > H ? _ ? x + b > 0 ^ v[1] < (Math.abs(v[0] - T) < _i ? x : b) : x <= v[1] && v[1] <= b : H > xi ^ (T <= v[0] && v[0] <= R)) {
                                var w = Ct(f, (-d + g) / E);
                                return At(w, p), [v, kt(w)]
                            }
                        }
                    }

                    function r(e, n) {
                        var r = o ? t : xi - t,
                            i = 0;
                        return -r > e ? i |= 1 : e > r && (i |= 2), -r > n ? i |= 4 : n > r && (i |= 8), i
                    }
                    var i = Math.cos(t),
                        o = i > 0,
                        a = Math.abs(i) > _i;
                    return zt(e, function(t) {
                        var i, s, u, h, c;
                        return {
                            lineStart: function() {
                                h = u = !1, c = 1
                            },
                            point: function(l, p) {
                                var f, d = [l, p],
                                    E = e(l, p),
                                    m = o ? E ? 0 : r(l, p) : E ? r(l + (0 > l ? xi : -xi), p) : 0;
                                if (!i && (h = u = E) && t.lineStart(), E !== u && (f = n(i, d), (Pt(i, f) || Pt(d, f)) && (d[0] += _i, d[1] += _i, E = e(d[0], d[1]))), E !== u) c = 0, E ? (t.lineStart(), f = n(d, i), t.point(f[0], f[1])) : (f = n(i, d), t.point(f[0], f[1]), t.lineEnd()), i = f;
                                else if (a && i && o ^ E) {
                                    var g;
                                    m & s || !(g = n(d, i, !0)) || (c = 0, o ? (t.lineStart(), t.point(g[0][0], g[0][1]), t.point(g[1][0], g[1][1]), t.lineEnd()) : (t.point(g[1][0], g[1][1]), t.lineEnd(), t.lineStart(), t.point(g[0][0], g[0][1])))
                                }!E || i && Pt(i, d) || t.point(d[0], d[1]), i = d, u = E, s = m
                            },
                            lineEnd: function() {
                                u && t.lineEnd(), i = null
                            },
                            clean: function() {
                                return c | (h && u) << 1
                            }
                        }
                    }, fe(t, 6 * Mi), o ? [0, -t] : [-xi, t - xi])
                }((x = +t) * Mi), i()) : x
            }, e.clipExtent = function(t) {
                return arguments.length ? (b = t, R = t ? Xt(t[0][0], t[0][1], t[1][0], t[1][1]) : lt, i()) : b
            }, e.scale = function(t) {
                return arguments.length ? (p = +t, r()) : p
            }, e.translate = function(t) {
                return arguments.length ? (f = +t[0], d = +t[1], r()) : [f, d]
            }, e.center = function(t) {
                return arguments.length ? (E = t[0] % 360 * Mi, m = t[1] % 360 * Mi, r()) : [E * Si, m * Si]
            }, e.rotate = function(t) {
                return arguments.length ? (g = t[0] % 360 * Mi, v = t[1] % 360 * Mi, y = t.length > 2 ? t[2] % 360 * Mi : 0, r()) : [g * Si, v * Si, y * Si]
            }, qr.rebind(e, l, "precision"),
            function() {
                return o = t.apply(this, arguments), e.invert = o.invert && n, r()
            }
    }

    function se(t, e) {
        return [t, e]
    }

    function ue(t, e) {
        return [t > xi ? t - bi : -xi > t ? t + bi : t, e]
    }

    function he(t, e, n) {
        return t ? e || n ? Yt(le(t), pe(e, n)) : le(t) : e || n ? pe(e, n) : ue
    }

    function ce(t) {
        return function(e, n) {
            return [(e += t) > xi ? e - bi : -xi > e ? e + bi : e, n]
        }
    }

    function le(t) {
        var e = ce(t);
        return e.invert = ce(-t), e
    }

    function pe(t, e) {
        function n(t, e) {
            var n = Math.cos(e),
                s = Math.cos(t) * n,
                u = Math.sin(t) * n,
                h = Math.sin(e),
                c = h * r + s * i;
            return [Math.atan2(u * o - c * a, s * r - h * i), F(c * o + u * a)]
        }
        var r = Math.cos(t),
            i = Math.sin(t),
            o = Math.cos(e),
            a = Math.sin(e);
        return n.invert = function(t, e) {
            var n = Math.cos(e),
                s = Math.cos(t) * n,
                u = Math.sin(t) * n,
                h = Math.sin(e),
                c = h * o - u * a;
            return [Math.atan2(u * o + h * a, s * r + c * i), F(c * r - s * i)]
        }, n
    }

    function fe(t, e) {
        var n = Math.cos(t),
            r = Math.sin(t);
        return function(i, o, a, s) {
            var u = a * e;
            null != i ? (i = de(n, i), o = de(n, o), (a > 0 ? o > i : i > o) && (i += a * bi)) : (i = t + a * bi, o = t - .5 * u);
            for (var h, c = i; a > 0 ? c > o : o > c; c -= u) s.point((h = kt([n, -r * Math.cos(c), -r * Math.sin(c)]))[0], h[1])
        }
    }

    function de(t, e) {
        var n = wt(e);
        n[0] -= t, Lt(n);
        var r = N(-n[1]);
        return ((-n[2] < 0 ? -r : r) + 2 * Math.PI - _i) % (2 * Math.PI)
    }

    function Ee(t, e, n) {
        var r = qr.range(t, e - _i, n).concat(e);
        return function(t) {
            return r.map(function(e) {
                return [t, e]
            })
        }
    }

    function me(t, e, n) {
        var r = qr.range(t, e - _i, n).concat(e);
        return function(t) {
            return r.map(function(e) {
                return [e, t]
            })
        }
    }

    function ge(t) {
        return t.source
    }

    function ve(t) {
        return t.target
    }

    function ye(t, e) {
        function n(e, n) {
            var r = Math.cos(e),
                i = Math.cos(n),
                o = t(r * i);
            return [o * i * Math.sin(e), o * Math.sin(n)]
        }
        return n.invert = function(t, n) {
            var r = Math.sqrt(t * t + n * n),
                i = e(r),
                o = Math.sin(i),
                a = Math.cos(i);
            return [Math.atan2(t * o, r * a), Math.asin(r && n * o / r)]
        }, n
    }

    function Te(t, e) {
        function n(t, e) {
            var n = Math.abs(Math.abs(e) - Hi) < _i ? 0 : a / Math.pow(i(e), o);
            return [n * Math.sin(o * t), a - n * Math.cos(o * t)]
        }
        var r = Math.cos(t),
            i = function(t) {
                return Math.tan(xi / 4 + t / 2)
            },
            o = t === e ? Math.sin(t) : Math.log(r / Math.cos(e)) / Math.log(i(e) / i(t)),
            a = r * Math.pow(i(t), o) / o;
        return o ? (n.invert = function(t, e) {
            var n = a - e,
                r = D(o) * Math.sqrt(t * t + n * n);
            return [Math.atan2(t, n) / o, 2 * Math.atan(Math.pow(a / r, 1 / o)) - Hi]
        }, n) : xe
    }

    function Re(t, e) {
        function n(t, e) {
            var n = o - e;
            return [n * Math.sin(i * t), o - n * Math.cos(i * t)]
        }
        var r = Math.cos(t),
            i = t === e ? Math.sin(t) : (r - Math.cos(e)) / (e - t),
            o = r / i + t;
        return Math.abs(i) < _i ? se : (n.invert = function(t, e) {
            var n = o - e;
            return [Math.atan2(t, n) / i, o - D(i) * Math.sqrt(t * t + n * n)]
        }, n)
    }

    function xe(t, e) {
        return [t, Math.log(Math.tan(xi / 4 + e / 2))]
    }

    function be(t) {
        var e, n = oe(t),
            r = n.scale,
            i = n.translate,
            o = n.clipExtent;
        return n.scale = function() {
            var t = r.apply(n, arguments);
            return t === n ? e ? n.clipExtent(null) : n : t
        }, n.translate = function() {
            var t = i.apply(n, arguments);
            return t === n ? e ? n.clipExtent(null) : n : t
        }, n.clipExtent = function(t) {
            var a = o.apply(n, arguments);
            if (a === n) {
                if (e = null == t) {
                    var s = xi * r(),
                        u = i();
                    o([
                        [u[0] - s, u[1] - s],
                        [u[0] + s, u[1] + s]
                    ])
                }
            } else e && (a = null);
            return a
        }, n.clipExtent(null)
    }

    function He(t, e) {
        var n = Math.cos(e) * Math.sin(t);
        return [Math.log((1 + n) / (1 - n)) / 2, Math.atan2(Math.tan(e), Math.cos(t))]
    }

    function _e(t) {
        function e(e) {
            function a() {
                h.push("M", o(t(c), s))
            }
            for (var u, h = [], c = [], l = -1, p = e.length, f = ct(n), d = ct(r); ++l < p;) i.call(this, u = e[l], l) ? c.push([+f.call(this, u, l), +d.call(this, u, l)]) : c.length && (a(), c = []);
            return c.length && a(), h.length ? h.join("") : null
        }
        var n = we,
            r = Me,
            i = Ut,
            o = Se,
            a = o.key,
            s = .7;
        return e.x = function(t) {
            return arguments.length ? (n = t, e) : n
        }, e.y = function(t) {
            return arguments.length ? (r = t, e) : r
        }, e.defined = function(t) {
            return arguments.length ? (i = t, e) : i
        }, e.interpolate = function(t) {
            return arguments.length ? (a = "function" == typeof t ? o = t : (o = Vo.get(t) || Se).key, e) : a
        }, e.tension = function(t) {
            return arguments.length ? (s = t, e) : s
        }, e
    }

    function we(t) {
        return t[0]
    }

    function Me(t) {
        return t[1]
    }

    function Se(t) {
        return t.join("L")
    }

    function Ae(t) {
        for (var e = 0, n = t.length, r = t[0], i = [r[0], ",", r[1]]; ++e < n;) i.push("V", (r = t[e])[1], "H", r[0]);
        return i.join("")
    }

    function Ce(t) {
        for (var e = 0, n = t.length, r = t[0], i = [r[0], ",", r[1]]; ++e < n;) i.push("H", (r = t[e])[0], "V", r[1]);
        return i.join("")
    }

    function Le(t, e) {
        if (e.length < 1 || t.length != e.length && t.length != e.length + 2) return Se(t);
        var n = t.length != e.length,
            r = "",
            i = t[0],
            o = t[1],
            a = e[0],
            s = a,
            u = 1;
        if (n && (r += "Q" + (o[0] - 2 * a[0] / 3) + "," + (o[1] - 2 * a[1] / 3) + "," + o[0] + "," + o[1], i = t[1], u = 2), e.length > 1) {
            s = e[1], o = t[u], u++, r += "C" + (i[0] + a[0]) + "," + (i[1] + a[1]) + "," + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1];
            for (var h = 2; h < e.length; h++, u++) o = t[u], s = e[h], r += "S" + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1]
        }
        if (n) {
            var c = t[u];
            r += "Q" + (o[0] + 2 * s[0] / 3) + "," + (o[1] + 2 * s[1] / 3) + "," + c[0] + "," + c[1]
        }
        return r
    }

    function ke(t, e) {
        for (var n, r = [], i = (1 - e) / 2, o = t[0], a = t[1], s = 1, u = t.length; ++s < u;) n = o, o = a, a = t[s], r.push([i * (a[0] - n[0]), i * (a[1] - n[1])]);
        return r
    }

    function Pe(t) {
        if (t.length < 3) return Se(t);
        var e = 1,
            n = t.length,
            r = t[0],
            i = r[0],
            o = r[1],
            a = [i, i, i, (r = t[1])[0]],
            s = [o, o, o, r[1]],
            u = [i, ",", o, "L", De(Io, a), ",", De(Io, s)];
        for (t.push(t[n - 1]); ++e <= n;) r = t[e], a.shift(), a.push(r[0]), s.shift(), s.push(r[1]), Ne(u, a, s);
        return t.pop(), u.push("L", r), u.join("")
    }

    function De(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
    }

    function Ne(t, e, n) {
        t.push("C", De(Uo, e), ",", De(Uo, n), ",", De(Bo, e), ",", De(Bo, n), ",", De(Io, e), ",", De(Io, n))
    }

    function Fe(t, e) {
        return (e[1] - t[1]) / (e[0] - t[0])
    }

    function Oe(t) {
        for (var e, n, r, i, o = [], a = function(t) {
                for (var e = 0, n = t.length - 1, r = [], i = t[0], o = t[1], a = r[0] = Fe(i, o); ++e < n;) r[e] = (a + (a = Fe(i = o, o = t[e + 1]))) / 2;
                return r[e] = a, r
            }(t), s = -1, u = t.length - 1; ++s < u;) e = Fe(t[s], t[s + 1]), Math.abs(e) < _i ? a[s] = a[s + 1] = 0 : (i = (n = a[s] / e) * n + (r = a[s + 1] / e) * r) > 9 && (i = 3 * e / Math.sqrt(i), a[s] = i * n, a[s + 1] = i * r);
        for (s = -1; ++s <= u;) i = (t[Math.min(u, s + 1)][0] - t[Math.max(0, s - 1)][0]) / (6 * (1 + a[s] * a[s])), o.push([i || 0, a[s] * i || 0]);
        return o
    }

    function Ve(t, e, n, r) {
        var i, o, a, s, u, h;
        return o = (i = r[t])[0], a = i[1], s = (i = r[e])[0], u = i[1], h = (i = r[n])[0], (i[1] - a) * (s - o) - (u - a) * (h - o) > 0
    }

    function Ue(t, e, n) {
        return (n[0] - e[0]) * (t[1] - e[1]) < (n[1] - e[1]) * (t[0] - e[0])
    }

    function Be(t, e, n, r) {
        var i = t[0],
            o = n[0],
            a = e[0] - i,
            s = r[0] - o,
            u = t[1],
            h = n[1],
            c = e[1] - u,
            l = r[1] - h,
            p = (s * (u - h) - l * (i - o)) / (l * a - s * c);
        return [i + p * a, u + p * c]
    }

    function Ie(t) {
        var e = t[0],
            n = t[t.length - 1];
        return !(e[0] - n[0] || e[1] - n[1])
    }

    function ze(t, e) {
        var n = {
                list: t.map(function(t, e) {
                    return {
                        index: e,
                        x: t[0],
                        y: t[1]
                    }
                }).sort(function(t, e) {
                    return t.y < e.y ? -1 : t.y > e.y ? 1 : t.x < e.x ? -1 : t.x > e.x ? 1 : 0
                }),
                bottomSite: null
            },
            r = {
                list: [],
                leftEnd: null,
                rightEnd: null,
                init: function() {
                    r.leftEnd = r.createHalfEdge(null, "l"), r.rightEnd = r.createHalfEdge(null, "l"), r.leftEnd.r = r.rightEnd, r.rightEnd.l = r.leftEnd, r.list.unshift(r.leftEnd, r.rightEnd)
                },
                createHalfEdge: function(t, e) {
                    return {
                        edge: t,
                        side: e,
                        vertex: null,
                        l: null,
                        r: null
                    }
                },
                insert: function(t, e) {
                    e.l = t, e.r = t.r, t.r.l = e, t.r = e
                },
                leftBound: function(t) {
                    var e = r.leftEnd;
                    do {
                        e = e.r
                    } while (e != r.rightEnd && i.rightOf(e, t));
                    return e.l
                },
                del: function(t) {
                    t.l.r = t.r, t.r.l = t.l, t.edge = null
                },
                right: function(t) {
                    return t.r
                },
                left: function(t) {
                    return t.l
                },
                leftRegion: function(t) {
                    return null == t.edge ? n.bottomSite : t.edge.region[t.side]
                },
                rightRegion: function(t) {
                    return null == t.edge ? n.bottomSite : t.edge.region[Go[t.side]]
                }
            },
            i = {
                bisect: function(t, e) {
                    var n = {
                            region: {
                                l: t,
                                r: e
                            },
                            ep: {
                                l: null,
                                r: null
                            }
                        },
                        r = e.x - t.x,
                        i = e.y - t.y,
                        o = r > 0 ? r : -r,
                        a = i > 0 ? i : -i;
                    return n.c = t.x * r + t.y * i + .5 * (r * r + i * i), o > a ? (n.a = 1, n.b = i / r, n.c /= r) : (n.b = 1, n.a = r / i, n.c /= i), n
                },
                intersect: function(t, e) {
                    var n = t.edge,
                        r = e.edge;
                    if (!n || !r || n.region.r == r.region.r) return null;
                    var i = n.a * r.b - n.b * r.a;
                    if (Math.abs(i) < 1e-10) return null;
                    var o, a, s = (n.c * r.b - r.c * n.b) / i,
                        u = (r.c * n.a - n.c * r.a) / i,
                        h = n.region.r,
                        c = r.region.r;
                    h.y < c.y || h.y == c.y && h.x < c.x ? (o = t, a = n) : (o = e, a = r);
                    var l = s >= a.region.r.x;
                    return l && "l" === o.side || !l && "r" === o.side ? null : {
                        x: s,
                        y: u
                    }
                },
                rightOf: function(t, e) {
                    var n = t.edge,
                        r = n.region.r,
                        i = e.x > r.x;
                    if (i && "l" === t.side) return 1;
                    if (!i && "r" === t.side) return 0;
                    if (1 === n.a) {
                        var o = e.y - r.y,
                            a = e.x - r.x,
                            s = 0,
                            u = 0;
                        if (!i && n.b < 0 || i && n.b >= 0 ? u = s = o >= n.b * a : (u = e.x + e.y * n.b > n.c, n.b < 0 && (u = !u), u || (s = 1)), !s) {
                            var h = r.x - n.region.l.x;
                            u = n.b * (a * a - o * o) < h * o * (1 + 2 * a / h + n.b * n.b), n.b < 0 && (u = !u)
                        }
                    } else {
                        var c = n.c - n.a * e.x,
                            l = e.y - c,
                            p = e.x - r.x,
                            f = c - r.y;
                        u = l * l > p * p + f * f
                    }
                    return "l" === t.side ? u : !u
                },
                endPoint: function(t, n, r) {
                    t.ep[n] = r, t.ep[Go[n]] && e(t)
                },
                distance: function(t, e) {
                    var n = t.x - e.x,
                        r = t.y - e.y;
                    return Math.sqrt(n * n + r * r)
                }
            },
            o = {
                list: [],
                insert: function(t, e, n) {
                    t.vertex = e, t.ystar = e.y + n;
                    for (var r = 0, i = o.list, a = i.length; a > r; r++) {
                        var s = i[r];
                        if (!(t.ystar > s.ystar || t.ystar == s.ystar && e.x > s.vertex.x)) break
                    }
                    i.splice(r, 0, t)
                },
                del: function(t) {
                    for (var e = 0, n = o.list, r = n.length; r > e && n[e] != t; ++e);
                    n.splice(e, 1)
                },
                empty: function() {
                    return 0 === o.list.length
                },
                nextEvent: function(t) {
                    for (var e = 0, n = o.list, r = n.length; r > e; ++e)
                        if (n[e] == t) return n[e + 1];
                    return null
                },
                min: function() {
                    var t = o.list[0];
                    return {
                        x: t.vertex.x,
                        y: t.ystar
                    }
                },
                extractMin: function() {
                    return o.list.shift()
                }
            };
        r.init(), n.bottomSite = n.list.shift();
        for (var a, s, u, h, c, l, p, f, d, E, m, g, v, y = n.list.shift();;)
            if (o.empty() || (a = o.min()), y && (o.empty() || y.y < a.y || y.y == a.y && y.x < a.x)) s = r.leftBound(y), u = r.right(s), p = r.rightRegion(s), g = i.bisect(p, y), l = r.createHalfEdge(g, "l"), r.insert(s, l), (E = i.intersect(s, l)) && (o.del(s), o.insert(s, E, i.distance(E, y))), s = l, l = r.createHalfEdge(g, "r"), r.insert(s, l), (E = i.intersect(l, u)) && o.insert(l, E, i.distance(E, y)), y = n.list.shift();
            else {
                if (o.empty()) break;
                s = o.extractMin(), h = r.left(s), u = r.right(s), c = r.right(u), p = r.leftRegion(s), f = r.rightRegion(u), m = s.vertex, i.endPoint(s.edge, s.side, m), i.endPoint(u.edge, u.side, m), r.del(s), o.del(u), r.del(u), v = "l", p.y > f.y && (d = p, p = f, f = d, v = "r"), g = i.bisect(p, f), l = r.createHalfEdge(g, v), r.insert(h, l), i.endPoint(g, Go[v], m), (E = i.intersect(h, l)) && (o.del(h), o.insert(h, E, i.distance(E, p))), (E = i.intersect(l, c)) && o.insert(l, E, i.distance(E, p))
            }
        for (s = r.right(r.leftEnd); s != r.rightEnd; s = r.right(s)) e(s.edge)
    }

    function Ge(t) {
        return t.x
    }

    function je(t) {
        return t.y
    }

    function We(t, e) {
        t = qr.rgb(t), e = qr.rgb(e);
        var n = t.r,
            r = t.g,
            i = t.b,
            o = e.r - n,
            a = e.g - r,
            s = e.b - i;
        return function(t) {
            return "#" + it(Math.round(n + o * t)) + it(Math.round(r + a * t)) + it(Math.round(i + s * t))
        }
    }

    function Xe(t, e) {
        var n, r = {},
            i = {};
        for (n in t) n in e ? r[n] = Ke(t[n], e[n]) : i[n] = t[n];
        for (n in e) n in t || (i[n] = e[n]);
        return function(t) {
            for (n in r) i[n] = r[n](t);
            return i
        }
    }

    function qe(t, e) {
        return e -= t = +t,
            function(n) {
                return t + e * n
            }
    }

    function Ye(t, e) {
        var n, r, i, o, a, s = 0,
            u = [],
            h = [];
        for (t += "", e += "", jo.lastIndex = 0, r = 0; n = jo.exec(e); ++r) n.index && u.push(e.substring(s, n.index)), h.push({
            i: u.length,
            x: n[0]
        }), u.push(null), s = jo.lastIndex;
        for (s < e.length && u.push(e.substring(s)), r = 0, o = h.length;
            (n = jo.exec(t)) && o > r; ++r)
            if ((a = h[r]).x == n[0]) {
                if (a.i)
                    if (null == u[a.i + 1])
                        for (u[a.i - 1] += a.x, u.splice(a.i, 1), i = r + 1; o > i; ++i) h[i].i--;
                    else
                        for (u[a.i - 1] += a.x + u[a.i + 1], u.splice(a.i, 2), i = r + 1; o > i; ++i) h[i].i -= 2;
                else if (null == u[a.i + 1]) u[a.i] = a.x;
                else
                    for (u[a.i] = a.x + u[a.i + 1], u.splice(a.i + 1, 1), i = r + 1; o > i; ++i) h[i].i--;
                h.splice(r, 1), o--, r--
            } else a.x = qe(parseFloat(n[0]), parseFloat(a.x));
        for (; o > r;) a = h.pop(), null == u[a.i + 1] ? u[a.i] = a.x : (u[a.i] = a.x + u[a.i + 1], u.splice(a.i + 1, 1)), o--;
        return 1 === u.length ? null == u[0] ? (a = h[0].x, function(t) {
            return a(t) + ""
        }) : function() {
            return e
        } : function(t) {
            for (r = 0; o > r; ++r) u[(a = h[r]).i] = a.x(t);
            return u.join("")
        }
    }

    function Ke(t, e) {
        for (var n, r = qr.interpolators.length; --r >= 0 && !(n = qr.interpolators[r](t, e)););
        return n
    }

    function Ze(t, e) {
        var n, r = [],
            i = [],
            o = t.length,
            a = e.length,
            s = Math.min(t.length, e.length);
        for (n = 0; s > n; ++n) r.push(Ke(t[n], e[n]));
        for (; o > n; ++n) i[n] = t[n];
        for (; a > n; ++n) i[n] = e[n];
        return function(t) {
            for (n = 0; s > n; ++n) i[n] = r[n](t);
            return i
        }
    }

    function Qe(t) {
        return function(e) {
            return 1 - t(1 - e)
        }
    }

    function Je(t) {
        return function(e) {
            return .5 * (.5 > e ? t(2 * e) : 2 - t(2 - 2 * e))
        }
    }

    function $e(t) {
        return t * t
    }

    function tn(t) {
        return t * t * t
    }

    function en(t) {
        if (0 >= t) return 0;
        if (t >= 1) return 1;
        var e = t * t,
            n = e * t;
        return 4 * (.5 > t ? n : 3 * (t - e) + n - .75)
    }

    function nn(t) {
        return 1 - Math.cos(t * Hi)
    }

    function rn(t) {
        return Math.pow(2, 10 * (t - 1))
    }

    function on(t) {
        return 1 - Math.sqrt(1 - t * t)
    }

    function an(t) {
        return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
    }

    function sn(t, e) {
        return e -= t,
            function(n) {
                return Math.round(t + e * n)
            }
    }

    function un(t) {
        var e = [t.a, t.b],
            n = [t.c, t.d],
            r = cn(e),
            i = hn(e, n),
            o = cn(function(t, e, n) {
                return t[0] += n * e[0], t[1] += n * e[1], t
            }(n, e, -i)) || 0;
        e[0] * n[1] < n[0] * e[1] && (e[0] *= -1, e[1] *= -1, r *= -1, i *= -1), this.rotate = (r ? Math.atan2(e[1], e[0]) : Math.atan2(-n[0], n[1])) * Si, this.translate = [t.e, t.f], this.scale = [r, o], this.skew = o ? Math.atan2(i, o) * Si : 0
    }

    function hn(t, e) {
        return t[0] * e[0] + t[1] * e[1]
    }

    function cn(t) {
        var e = Math.sqrt(hn(t, t));
        return e && (t[0] /= e, t[1] /= e), e
    }

    function ln(t, e) {
        var n, r = [],
            i = [],
            o = qr.transform(t),
            a = qr.transform(e),
            s = o.translate,
            u = a.translate,
            h = o.rotate,
            c = a.rotate,
            l = o.skew,
            p = a.skew,
            f = o.scale,
            d = a.scale;
        return s[0] != u[0] || s[1] != u[1] ? (r.push("translate(", null, ",", null, ")"), i.push({
                i: 1,
                x: qe(s[0], u[0])
            }, {
                i: 3,
                x: qe(s[1], u[1])
            })) : u[0] || u[1] ? r.push("translate(" + u + ")") : r.push(""), h != c ? (h - c > 180 ? c += 360 : c - h > 180 && (h += 360), i.push({
                i: r.push(r.pop() + "rotate(", null, ")") - 2,
                x: qe(h, c)
            })) : c && r.push(r.pop() + "rotate(" + c + ")"), l != p ? i.push({
                i: r.push(r.pop() + "skewX(", null, ")") - 2,
                x: qe(l, p)
            }) : p && r.push(r.pop() + "skewX(" + p + ")"), f[0] != d[0] || f[1] != d[1] ? (n = r.push(r.pop() + "scale(", null, ",", null, ")"), i.push({
                i: n - 4,
                x: qe(f[0], d[0])
            }, {
                i: n - 2,
                x: qe(f[1], d[1])
            })) : (1 != d[0] || 1 != d[1]) && r.push(r.pop() + "scale(" + d + ")"), n = i.length,
            function(t) {
                for (var e, o = -1; ++o < n;) r[(e = i[o]).i] = e.x(t);
                return r.join("")
            }
    }

    function pn(t, e) {
        return e = e - (t = +t) ? 1 / (e - t) : 0,
            function(n) {
                return (n - t) * e
            }
    }

    function fn(t, e) {
        return e = e - (t = +t) ? 1 / (e - t) : 0,
            function(n) {
                return Math.max(0, Math.min(1, (n - t) * e))
            }
    }

    function dn(t) {
        for (var e = t.source, n = t.target, r = function(t, e) {
                if (t === e) return t;
                for (var n = En(t), r = En(e), i = n.pop(), o = r.pop(), a = null; i === o;) a = i, i = n.pop(), o = r.pop();
                return a
            }(e, n), i = [e]; e !== r;) e = e.parent, i.push(e);
        for (var o = i.length; n !== r;) i.splice(o, 0, n), n = n.parent;
        return i
    }

    function En(t) {
        for (var e = [], n = t.parent; null != n;) e.push(t), t = n, n = n.parent;
        return e.push(t), e
    }

    function mn(t) {
        t.fixed |= 2
    }

    function gn(t) {
        t.fixed &= -7
    }

    function vn(t) {
        t.fixed |= 4, t.px = t.x, t.py = t.y
    }

    function yn(t) {
        t.fixed &= -5
    }

    function Tn(t, e) {
        return qr.rebind(t, e, "sort", "children", "value"), t.nodes = t, t.links = Hn, t
    }

    function Rn(t) {
        return t.children
    }

    function xn(t) {
        return t.value
    }

    function bn(t, e) {
        return e.value - t.value
    }

    function Hn(t) {
        return qr.merge(t.map(function(t) {
            return (t.children || []).map(function(e) {
                return {
                    source: t,
                    target: e
                }
            })
        }))
    }

    function _n(t) {
        return t.x
    }

    function wn(t) {
        return t.y
    }

    function Mn(t, e, n) {
        t.y0 = e, t.y = n
    }

    function Sn(t) {
        return qr.range(t.length)
    }

    function An(t) {
        for (var e = -1, n = t[0].length, r = []; ++e < n;) r[e] = 0;
        return r
    }

    function Cn(t) {
        for (var e, n = 1, r = 0, i = t[0][1], o = t.length; o > n; ++n)(e = t[n][1]) > i && (r = n, i = e);
        return r
    }

    function Ln(t) {
        return t.reduce(kn, 0)
    }

    function kn(t, e) {
        return t + e[1]
    }

    function Pn(t, e) {
        return Dn(t, Math.ceil(Math.log(e.length) / Math.LN2 + 1))
    }

    function Dn(t, e) {
        for (var n = -1, r = +t[0], i = (t[1] - r) / e, o = []; ++n <= e;) o[n] = i * n + r;
        return o
    }

    function Nn(t) {
        return [qr.min(t), qr.max(t)]
    }

    function Fn(t, e) {
        return t.parent == e.parent ? 1 : 2
    }

    function On(t) {
        var e = t.children;
        return e && e.length ? e[0] : t._tree.thread
    }

    function Vn(t) {
        var e, n = t.children;
        return n && (e = n.length) ? n[e - 1] : t._tree.thread
    }

    function Un(t, e) {
        var n = t.children;
        if (n && (i = n.length))
            for (var r, i, o = -1; ++o < i;) e(r = Un(n[o], e), t) > 0 && (t = r);
        return t
    }

    function Bn(t, e) {
        return t.x - e.x
    }

    function In(t, e) {
        return e.x - t.x
    }

    function zn(t, e) {
        return t.depth - e.depth
    }

    function Gn(t, e) {
        ! function t(n, r) {
            var i = n.children;
            if (i && (a = i.length))
                for (var o, a, s = null, u = -1; ++u < a;) t(o = i[u], s), s = o;
            e(n, r)
        }(t, null)
    }

    function jn(t, e, n) {
        t = t._tree;
        var r = n / ((e = e._tree).number - t.number);
        t.change += r, e.change -= r, e.shift += n, e.prelim += n, e.mod += n
    }

    function Wn(t, e, n) {
        return t._tree.ancestor.parent == e.parent ? t._tree.ancestor : n
    }

    function Xn(t, e) {
        return t.value - e.value
    }

    function qn(t, e) {
        var n = t._pack_next;
        t._pack_next = e, e._pack_prev = t, e._pack_next = n, n._pack_prev = e
    }

    function Yn(t, e) {
        t._pack_next = e, e._pack_prev = t
    }

    function Kn(t, e) {
        var n = e.x - t.x,
            r = e.y - t.y,
            i = t.r + e.r;
        return .999 * i * i > n * n + r * r
    }

    function Zn(t) {
        function e(t) {
            c = Math.min(t.x - t.r, c), l = Math.max(t.x + t.r, l), p = Math.min(t.y - t.r, p), f = Math.max(t.y + t.r, f)
        }
        if ((n = t.children) && (h = n.length)) {
            var n, r, i, o, a, s, u, h, c = 1 / 0,
                l = -1 / 0,
                p = 1 / 0,
                f = -1 / 0;
            if (n.forEach(Qn), (r = n[0]).x = -r.r, r.y = 0, e(r), h > 1 && ((i = n[1]).x = i.r, i.y = 0, e(i), h > 2))
                for ($n(r, i, o = n[2]), e(o), qn(r, o), r._pack_prev = o, qn(o, i), i = r._pack_next, a = 3; h > a; a++) {
                    $n(r, i, o = n[a]);
                    var d = 0,
                        E = 1,
                        m = 1;
                    for (s = i._pack_next; s !== i; s = s._pack_next, E++)
                        if (Kn(s, o)) {
                            d = 1;
                            break
                        }
                    if (1 == d)
                        for (u = r._pack_prev; u !== s._pack_prev && !Kn(u, o); u = u._pack_prev, m++);
                    d ? (m > E || E == m && i.r < r.r ? Yn(r, i = s) : Yn(r = u, i), a--) : (qn(r, o), i = o, e(o))
                }
            var g = (c + l) / 2,
                v = (p + f) / 2,
                y = 0;
            for (a = 0; h > a; a++)(o = n[a]).x -= g, o.y -= v, y = Math.max(y, o.r + Math.sqrt(o.x * o.x + o.y * o.y));
            t.r = y, n.forEach(Jn)
        }
    }

    function Qn(t) {
        t._pack_next = t._pack_prev = t
    }

    function Jn(t) {
        delete t._pack_next, delete t._pack_prev
    }

    function $n(t, e, n) {
        var r = t.r + n.r,
            i = e.x - t.x,
            o = e.y - t.y;
        if (r && (i || o)) {
            var a = e.r + n.r,
                s = i * i + o * o,
                u = .5 + ((r *= r) - (a *= a)) / (2 * s),
                h = Math.sqrt(Math.max(0, 2 * a * (r + s) - (r -= s) * r - a * a)) / (2 * s);
            n.x = t.x + u * i + h * o, n.y = t.y + u * o - h * i
        } else n.x = t.x + r, n.y = t.y
    }

    function tr(t) {
        return {
            x: t.x,
            y: t.y,
            dx: t.dx,
            dy: t.dy
        }
    }

    function er(t, e) {
        var n = t.x + e[3],
            r = t.y + e[0],
            i = t.dx - e[1] - e[3],
            o = t.dy - e[0] - e[2];
        return 0 > i && (n += i / 2, i = 0), 0 > o && (r += o / 2, o = 0), {
            x: n,
            y: r,
            dx: i,
            dy: o
        }
    }

    function nr(t) {
        var e = t[0],
            n = t[t.length - 1];
        return n > e ? [e, n] : [n, e]
    }

    function rr(t) {
        return t.rangeExtent ? t.rangeExtent() : nr(t.range())
    }

    function ir(t, e, n, r) {
        var i = n(t[0], t[1]),
            o = r(e[0], e[1]);
        return function(t) {
            return o(i(t))
        }
    }

    function or(t, e) {
        var n, r = 0,
            i = t.length - 1,
            o = t[r],
            a = t[i];
        return o > a && (n = r, r = i, i = n, n = o, o = a, a = n), t[r] = e.floor(o), t[i] = e.ceil(a), t
    }

    function ar(t, e, n, r) {
        var i = [],
            o = [],
            a = 0,
            s = Math.min(t.length, e.length) - 1;
        for (t[s] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++a <= s;) i.push(n(t[a - 1], t[a])), o.push(r(e[a - 1], e[a]));
        return function(e) {
            var n = qr.bisect(t, e, 1, s) - 1;
            return o[n](i[n](e))
        }
    }

    function sr(t, e) {
        return qr.rebind(t, e, "range", "rangeRound", "interpolate", "clamp")
    }

    function ur(t, e) {
        return or(t, function(t) {
            return t ? {
                floor: function(e) {
                    return Math.floor(e / t) * t
                },
                ceil: function(e) {
                    return Math.ceil(e / t) * t
                }
            } : ta
        }(hr(t, e)[2]))
    }

    function hr(t, e) {
        null == e && (e = 10);
        var n = nr(t),
            r = n[1] - n[0],
            i = Math.pow(10, Math.floor(Math.log(r / e) / Math.LN10)),
            o = e / r * i;
        return .15 >= o ? i *= 10 : .35 >= o ? i *= 5 : .75 >= o && (i *= 2), n[0] = Math.ceil(n[0] / i) * i, n[1] = Math.floor(n[1] / i) * i + .5 * i, n[2] = i, n
    }

    function cr(t, e) {
        return qr.range.apply(qr, hr(t, e))
    }

    function lr(t, e, n) {
        var r = -Math.floor(Math.log(hr(t, e)[2]) / Math.LN10 + .01);
        return qr.format(n ? n.replace(Qi, function(t, e, n, i, o, a, s, u, h, c) {
            return [e, n, i, o, a, s, u, h || "." + (r - 2 * ("%" === c)), c].join("")
        }) : ",." + r + "f")
    }

    function pr(t) {
        return function(e) {
            return 0 > e ? -Math.pow(-e, t) : Math.pow(e, t)
        }
    }

    function fr(t) {
        return t.innerRadius
    }

    function dr(t) {
        return t.outerRadius
    }

    function Er(t) {
        return t.startAngle
    }

    function mr(t) {
        return t.endAngle
    }

    function gr(t) {
        for (var e, n, r, i = -1, o = t.length; ++i < o;) n = (e = t[i])[0], r = e[1] + sa, e[0] = n * Math.cos(r), e[1] = n * Math.sin(r);
        return t
    }

    function vr(t) {
        function e(e) {
            function u() {
                E.push("M", s(t(g), l), c, h(t(m.reverse()), l), "Z")
            }
            for (var p, f, d, E = [], m = [], g = [], v = -1, y = e.length, T = ct(n), R = ct(i), x = n === r ? function() {
                    return f
                } : ct(r), b = i === o ? function() {
                    return d
                } : ct(o); ++v < y;) a.call(this, p = e[v], v) ? (m.push([f = +T.call(this, p, v), d = +R.call(this, p, v)]), g.push([+x.call(this, p, v), +b.call(this, p, v)])) : m.length && (u(), m = [], g = []);
            return m.length && u(), E.length ? E.join("") : null
        }
        var n = we,
            r = we,
            i = 0,
            o = Me,
            a = Ut,
            s = Se,
            u = s.key,
            h = s,
            c = "L",
            l = .7;
        return e.x = function(t) {
            return arguments.length ? (n = r = t, e) : r
        }, e.x0 = function(t) {
            return arguments.length ? (n = t, e) : n
        }, e.x1 = function(t) {
            return arguments.length ? (r = t, e) : r
        }, e.y = function(t) {
            return arguments.length ? (i = o = t, e) : o
        }, e.y0 = function(t) {
            return arguments.length ? (i = t, e) : i
        }, e.y1 = function(t) {
            return arguments.length ? (o = t, e) : o
        }, e.defined = function(t) {
            return arguments.length ? (a = t, e) : a
        }, e.interpolate = function(t) {
            return arguments.length ? (u = "function" == typeof t ? s = t : (s = Vo.get(t) || Se).key, h = s.reverse || s, c = s.closed ? "M" : "L", e) : u
        }, e.tension = function(t) {
            return arguments.length ? (l = t, e) : l
        }, e
    }

    function yr(t) {
        return t.radius
    }

    function Tr(t) {
        return [t.x, t.y]
    }

    function Rr() {
        return 64
    }

    function xr() {
        return "circle"
    }

    function br(t) {
        var e = Math.sqrt(t / xi);
        return "M0," + e + "A" + e + "," + e + " 0 1,1 0," + -e + "A" + e + "," + e + " 0 1,1 0," + e + "Z"
    }

    function Hr(t, e) {
        return hi(t, da), t.id = e, t
    }

    function _r(t, e, n, r) {
        var i = t.id;
        return w(t, "function" == typeof n ? function(t, o, a) {
            t.__transition__[i].tween.set(e, r(n.call(t, t.__data__, o, a)))
        } : (n = r(n), function(t) {
            t.__transition__[i].tween.set(e, n)
        }))
    }

    function wr(t) {
        return null == t && (t = ""),
            function() {
                this.textContent = t
            }
    }

    function Mr(t, e, n, i) {
        var o = t.__transition__ || (t.__transition__ = {
                active: 0,
                count: 0
            }),
            a = o[n];
        if (!a) {
            var s = i.time;
            a = o[n] = {
                tween: new r,
                time: s,
                ease: i.ease,
                delay: i.delay,
                duration: i.duration
            }, ++o.count, qr.timer(function(r) {
                function i(r) {
                    return o.active > n ? h() : (o.active = n, a.event && a.event.start.call(t, c, e), a.tween.forEach(function(n, r) {
                        (r = r.call(t, c, e)) && d.push(r)
                    }), u(r || 1) ? 1 : void Et(u, p, s))
                }

                function u(r) {
                    if (o.active !== n) return h();
                    for (var i = r / f, s = l(i), u = d.length; u > 0;) d[--u].call(t, s);
                    return i >= 1 ? (a.event && a.event.end.call(t, c, e), h()) : void 0
                }

                function h() {
                    return --o.count ? delete o[n] : delete t.__transition__, 1
                }
                var c = t.__data__,
                    l = a.ease,
                    p = a.delay,
                    f = a.duration,
                    d = [];
                return r >= p ? i(r - p) : void Et(i, p, s)
            }, 0, s)
        }
    }

    function Sr(t, e) {
        t.attr("transform", function(t) {
            return "translate(" + e(t) + ",0)"
        })
    }

    function Ar(t, e) {
        t.attr("transform", function(t) {
            return "translate(0," + e(t) + ")"
        })
    }

    function Cr() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0])
    }

    function Lr(t, e, n) {
        function r(e) {
            var n = t(e),
                r = o(n, 1);
            return r - e > e - n ? n : r
        }

        function i(n) {
            return e(n = t(new Ra(n - 1)), 1), n
        }

        function o(t, n) {
            return e(t = new Ra(+t), n), t
        }

        function a(t, r, o) {
            var a = i(t),
                s = [];
            if (o > 1)
                for (; r > a;) n(a) % o || s.push(new Date(+a)), e(a, 1);
            else
                for (; r > a;) s.push(new Date(+a)), e(a, 1);
            return s
        }
        t.floor = t, t.round = r, t.ceil = i, t.offset = o, t.range = a;
        var s = t.utc = kr(t);
        return s.floor = s, s.round = kr(r), s.ceil = kr(i), s.offset = kr(o), s.range = function(t, e, n) {
            try {
                Ra = Cr;
                var r = new Cr;
                return r._ = t, a(r, e, n)
            } finally {
                Ra = Date
            }
        }, t
    }

    function kr(t) {
        return function(e, n) {
            try {
                Ra = Cr;
                var r = new Cr;
                return r._ = e, t(r, n)._
            } finally {
                Ra = Date
            }
        }
    }

    function Pr(t) {
        function e(e) {
            for (var r, i, o, a = [], s = -1, u = 0; ++s < n;) 37 === t.charCodeAt(s) && (a.push(t.substring(u, s)), null != (i = Fa[r = t.charAt(++s)]) && (r = t.charAt(++s)), (o = Oa[r]) && (r = o(e, null == i ? "e" === r ? " " : "0" : i)), a.push(r), u = s + 1);
            return a.push(t.substring(u, s)), a.join("")
        }
        var n = t.length;
        return e.parse = function(e) {
            var n = {
                y: 1900,
                m: 0,
                d: 1,
                H: 0,
                M: 0,
                S: 0,
                L: 0,
                Z: null
            };
            if (Dr(n, t, e, 0) != e.length) return null;
            "p" in n && (n.H = n.H % 12 + 12 * n.p);
            var r = null != n.Z && Ra !== Cr,
                i = new(r ? Cr : Ra);
            return "j" in n ? i.setFullYear(n.y, 0, n.j) : "w" in n && ("W" in n || "U" in n) ? (i.setFullYear(n.y, 0, 1), i.setFullYear(n.y, 0, "W" in n ? (n.w + 6) % 7 + 7 * n.W - (i.getDay() + 5) % 7 : n.w + 7 * n.U - (i.getDay() + 6) % 7)) : i.setFullYear(n.y, n.m, n.d), i.setHours(n.H + Math.floor(n.Z / 100), n.M + n.Z % 100, n.S, n.L), r ? i._ : i
        }, e.toString = function() {
            return t
        }, e
    }

    function Dr(t, e, n, r) {
        for (var i, o, a, s = 0, u = e.length, h = n.length; u > s;) {
            if (r >= h) return -1;
            if (37 === (i = e.charCodeAt(s++))) {
                if (a = e.charAt(s++), !(o = Va[a in Fa ? e.charAt(s++) : a]) || (r = o(t, n, r)) < 0) return -1
            } else if (i != n.charCodeAt(r++)) return -1
        }
        return r
    }

    function Nr(t) {
        return new RegExp("^(?:" + t.map(qr.requote).join("|") + ")", "i")
    }

    function Fr(t) {
        for (var e = new r, n = -1, i = t.length; ++n < i;) e.set(t[n].toLowerCase(), n);
        return e
    }

    function Or(t, e, n) {
        var r = 0 > t ? "-" : "",
            i = (r ? -t : t) + "",
            o = i.length;
        return r + (n > o ? new Array(n - o + 1).join(e) + i : i)
    }

    function Vr(t, e, n) {
        Ua.lastIndex = 0;
        var r = Ua.exec(e.substring(n, n + 2));
        return r ? (t.d = +r[0], n + r[0].length) : -1
    }

    function Ur(t, e, n) {
        Ua.lastIndex = 0;
        var r = Ua.exec(e.substring(n, n + 2));
        return r ? (t.H = +r[0], n + r[0].length) : -1
    }

    function Br(t) {
        function e(t) {
            try {
                var e = new(Ra = Cr);
                return e._ = t, n(e)
            } finally {
                Ra = Date
            }
        }
        var n = Pr(t);
        return e.parse = function(t) {
            try {
                Ra = Cr;
                var e = n.parse(t);
                return e && e._
            } finally {
                Ra = Date
            }
        }, e.toString = n.toString, e
    }

    function Ir(t) {
        return t.toISOString()
    }

    function zr(t, e, n) {
        function r(e) {
            return t(e)
        }

        function i(t, n) {
            var r = (t[1] - t[0]) / n,
                i = qr.bisect(za, r);
            return i == za.length ? [e.year, hr(t.map(function(t) {
                return t / 31536e6
            }), n)[2]] : i ? e[r / za[i - 1] < za[i] / r ? i - 1 : i] : [Wa, hr(t, n)[2]]
        }
        return r.invert = function(e) {
            return Gr(t.invert(e))
        }, r.domain = function(e) {
            return arguments.length ? (t.domain(e), r) : t.domain().map(Gr)
        }, r.nice = function(t, e) {
            function n(n) {
                return !isNaN(n) && !t.range(n, Gr(+n + 1), e).length
            }
            var o = r.domain(),
                a = nr(o),
                s = null == t ? i(a, 10) : "number" == typeof t && i(a, t);
            return s && (t = s[0], e = s[1]), r.domain(or(o, e > 1 ? {
                floor: function(e) {
                    for (; n(e = t.floor(e));) e = Gr(e - 1);
                    return e
                },
                ceil: function(e) {
                    for (; n(e = t.ceil(e));) e = Gr(+e + 1);
                    return e
                }
            } : t))
        }, r.ticks = function(t, e) {
            var n = nr(r.domain()),
                o = null == t ? i(n, 10) : "number" == typeof t ? i(n, t) : !t.range && [{
                    range: t
                }, e];
            return o && (t = o[0], e = o[1]), t.range(n[0], Gr(+n[1] + 1), 1 > e ? 1 : e)
        }, r.tickFormat = function() {
            return n
        }, r.copy = function() {
            return zr(t.copy(), e, n)
        }, sr(r, t)
    }

    function Gr(t) {
        return new Date(t)
    }

    function jr(t) {
        return function(e) {
            for (var n = t.length - 1, r = t[n]; !r[1](e);) r = t[--n];
            return r[0](e)
        }
    }

    function Wr(t) {
        return JSON.parse(t.responseText)
    }

    function Xr(t) {
        var e = Zr.createRange();
        return e.selectNode(Zr.body), e.createContextualFragment(t.responseText)
    }
    var qr = {
        version: "3.3.6"
    };
    Date.now || (Date.now = function() {
        return +new Date
    });
    var Yr = [].slice,
        Kr = function(t) {
            return Yr.call(t)
        },
        Zr = document,
        Qr = Zr.documentElement,
        Jr = window;
    try {
        Kr(Qr.childNodes)[0].nodeType
    } catch (t) {
        Kr = function(t) {
            for (var e = t.length, n = new Array(e); e--;) n[e] = t[e];
            return n
        }
    }
    try {
        Zr.createElement("div").style.setProperty("opacity", 0, "")
    } catch (t) {
        var $r = Jr.Element.prototype,
            ti = $r.setAttribute,
            ei = $r.setAttributeNS,
            ni = Jr.CSSStyleDeclaration.prototype,
            ri = ni.setProperty;
        $r.setAttribute = function(t, e) {
            ti.call(this, t, e + "")
        }, $r.setAttributeNS = function(t, e, n) {
            ei.call(this, t, e, n + "")
        }, ni.setProperty = function(t, e, n) {
            ri.call(this, t, e + "", n)
        }
    }
    qr.ascending = function(t, e) {
        return e > t ? -1 : t > e ? 1 : t >= e ? 0 : NaN
    }, qr.descending = function(t, e) {
        return t > e ? -1 : e > t ? 1 : e >= t ? 0 : NaN
    }, qr.min = function(t, e) {
        var n, r, i = -1,
            o = t.length;
        if (1 === arguments.length) {
            for (; ++i < o && !(null != (n = t[i]) && n >= n);) n = void 0;
            for (; ++i < o;) null != (r = t[i]) && n > r && (n = r)
        } else {
            for (; ++i < o && !(null != (n = e.call(t, t[i], i)) && n >= n);) n = void 0;
            for (; ++i < o;) null != (r = e.call(t, t[i], i)) && n > r && (n = r)
        }
        return n
    }, qr.max = function(t, e) {
        var n, r, i = -1,
            o = t.length;
        if (1 === arguments.length) {
            for (; ++i < o && !(null != (n = t[i]) && n >= n);) n = void 0;
            for (; ++i < o;) null != (r = t[i]) && r > n && (n = r)
        } else {
            for (; ++i < o && !(null != (n = e.call(t, t[i], i)) && n >= n);) n = void 0;
            for (; ++i < o;) null != (r = e.call(t, t[i], i)) && r > n && (n = r)
        }
        return n
    }, qr.extent = function(t, e) {
        var n, r, i, o = -1,
            a = t.length;
        if (1 === arguments.length) {
            for (; ++o < a && !(null != (n = i = t[o]) && n >= n);) n = i = void 0;
            for (; ++o < a;) null != (r = t[o]) && (n > r && (n = r), r > i && (i = r))
        } else {
            for (; ++o < a && !(null != (n = i = e.call(t, t[o], o)) && n >= n);) n = void 0;
            for (; ++o < a;) null != (r = e.call(t, t[o], o)) && (n > r && (n = r), r > i && (i = r))
        }
        return [n, i]
    }, qr.sum = function(t, e) {
        var n, r = 0,
            i = t.length,
            o = -1;
        if (1 === arguments.length)
            for (; ++o < i;) isNaN(n = +t[o]) || (r += n);
        else
            for (; ++o < i;) isNaN(n = +e.call(t, t[o], o)) || (r += n);
        return r
    }, qr.mean = function(e, n) {
        var r, i = e.length,
            o = 0,
            a = -1,
            s = 0;
        if (1 === arguments.length)
            for (; ++a < i;) t(r = e[a]) && (o += (r - o) / ++s);
        else
            for (; ++a < i;) t(r = n.call(e, e[a], a)) && (o += (r - o) / ++s);
        return s ? o : void 0
    }, qr.quantile = function(t, e) {
        var n = (t.length - 1) * e + 1,
            r = Math.floor(n),
            i = +t[r - 1],
            o = n - r;
        return o ? i + o * (t[r] - i) : i
    }, qr.median = function(e, n) {
        return arguments.length > 1 && (e = e.map(n)), (e = e.filter(t)).length ? qr.quantile(e.sort(qr.ascending), .5) : void 0
    }, qr.bisector = function(t) {
        return {
            left: function(e, n, r, i) {
                for (arguments.length < 3 && (r = 0), arguments.length < 4 && (i = e.length); i > r;) {
                    var o = r + i >>> 1;
                    t.call(e, e[o], o) < n ? r = o + 1 : i = o
                }
                return r
            },
            right: function(e, n, r, i) {
                for (arguments.length < 3 && (r = 0), arguments.length < 4 && (i = e.length); i > r;) {
                    var o = r + i >>> 1;
                    n < t.call(e, e[o], o) ? i = o : r = o + 1
                }
                return r
            }
        }
    };
    var ii = qr.bisector(function(t) {
        return t
    });
    qr.bisectLeft = ii.left, qr.bisect = qr.bisectRight = ii.right, qr.shuffle = function(t) {
        for (var e, n, r = t.length; r;) n = 0 | Math.random() * r--, e = t[r], t[r] = t[n], t[n] = e;
        return t
    }, qr.permute = function(t, e) {
        for (var n = e.length, r = new Array(n); n--;) r[n] = t[e[n]];
        return r
    }, qr.pairs = function(t) {
        for (var e = 0, n = t.length - 1, r = t[0], i = new Array(0 > n ? 0 : n); n > e;) i[e] = [r, r = t[++e]];
        return i
    }, qr.zip = function() {
        if (!(i = arguments.length)) return [];
        for (var t = -1, n = qr.min(arguments, e), r = new Array(n); ++t < n;)
            for (var i, o = -1, a = r[t] = new Array(i); ++o < i;) a[o] = arguments[o][t];
        return r
    }, qr.transpose = function(t) {
        return qr.zip.apply(qr, t)
    }, qr.keys = function(t) {
        var e = [];
        for (var n in t) e.push(n);
        return e
    }, qr.values = function(t) {
        var e = [];
        for (var n in t) e.push(t[n]);
        return e
    }, qr.entries = function(t) {
        var e = [];
        for (var n in t) e.push({
            key: n,
            value: t[n]
        });
        return e
    }, qr.merge = function(t) {
        return Array.prototype.concat.apply([], t)
    }, qr.range = function(t, e, n) {
        if (arguments.length < 3 && (n = 1, arguments.length < 2 && (e = t, t = 0)), 1 / 0 == (e - t) / n) throw new Error("infinite range");
        var r, i = [],
            o = function(t) {
                for (var e = 1; t * e % 1;) e *= 10;
                return e
            }(Math.abs(n)),
            a = -1;
        if (t *= o, e *= o, 0 > (n *= o))
            for (;
                (r = t + n * ++a) > e;) i.push(r / o);
        else
            for (;
                (r = t + n * ++a) < e;) i.push(r / o);
        return i
    }, qr.map = function(t) {
        var e = new r;
        if (t instanceof r) t.forEach(function(t, n) {
            e.set(t, n)
        });
        else
            for (var n in t) e.set(n, t[n]);
        return e
    }, n(r, {
        has: function(t) {
            return oi + t in this
        },
        get: function(t) {
            return this[oi + t]
        },
        set: function(t, e) {
            return this[oi + t] = e
        },
        remove: function(t) {
            return (t = oi + t) in this && delete this[t]
        },
        keys: function() {
            var t = [];
            return this.forEach(function(e) {
                t.push(e)
            }), t
        },
        values: function() {
            var t = [];
            return this.forEach(function(e, n) {
                t.push(n)
            }), t
        },
        entries: function() {
            var t = [];
            return this.forEach(function(e, n) {
                t.push({
                    key: e,
                    value: n
                })
            }), t
        },
        forEach: function(t) {
            for (var e in this) e.charCodeAt(0) === ai && t.call(this, e.substring(1), this[e])
        }
    });
    var oi = "\0",
        ai = oi.charCodeAt(0);
    qr.nest = function() {
        function t(a, s, u) {
            if (u >= o.length) return n ? n.call(i, s) : e ? s.sort(e) : s;
            for (var h, c, l, p, f = -1, d = s.length, E = o[u++], m = new r; ++f < d;)(p = m.get(h = E(c = s[f]))) ? p.push(c) : m.set(h, [c]);
            return a ? (c = a(), l = function(e, n) {
                c.set(e, t(a, n, u))
            }) : (c = {}, l = function(e, n) {
                c[e] = t(a, n, u)
            }), m.forEach(l), c
        }
        var e, n, i = {},
            o = [],
            a = [];
        return i.map = function(e, n) {
            return t(n, e, 0)
        }, i.entries = function(e) {
            return function t(e, n) {
                if (n >= o.length) return e;
                var r = [],
                    i = a[n++];
                return e.forEach(function(e, i) {
                    r.push({
                        key: e,
                        values: t(i, n)
                    })
                }), i ? r.sort(function(t, e) {
                    return i(t.key, e.key)
                }) : r
            }(t(qr.map, e, 0), 0)
        }, i.key = function(t) {
            return o.push(t), i
        }, i.sortKeys = function(t) {
            return a[o.length - 1] = t, i
        }, i.sortValues = function(t) {
            return e = t, i
        }, i.rollup = function(t) {
            return n = t, i
        }, i
    }, qr.set = function(t) {
        var e = new i;
        if (t)
            for (var n = 0, r = t.length; r > n; ++n) e.add(t[n]);
        return e
    }, n(i, {
        has: function(t) {
            return oi + t in this
        },
        add: function(t) {
            return this[oi + t] = !0, t
        },
        remove: function(t) {
            return (t = oi + t) in this && delete this[t]
        },
        values: function() {
            var t = [];
            return this.forEach(function(e) {
                t.push(e)
            }), t
        },
        forEach: function(t) {
            for (var e in this) e.charCodeAt(0) === ai && t.call(this, e.substring(1))
        }
    }), qr.behavior = {}, qr.rebind = function(t, e) {
        for (var n, r = 1, i = arguments.length; ++r < i;) t[n = arguments[r]] = o(t, e, e[n]);
        return t
    };
    var si = ["webkit", "ms", "moz", "Moz", "o", "O"];
    qr.dispatch = function() {
        for (var t = new u, e = -1, n = arguments.length; ++e < n;) t[arguments[e]] = h(t);
        return t
    }, u.prototype.on = function(t, e) {
        var n = t.indexOf("."),
            r = "";
        if (n >= 0 && (r = t.substring(n + 1), t = t.substring(0, n)), t) return arguments.length < 2 ? this[t].on(r) : this[t].on(r, e);
        if (2 === arguments.length) {
            if (null == e)
                for (t in this) this.hasOwnProperty(t) && this[t].on(r, null);
            return this
        }
    }, qr.event = null, qr.requote = function(t) {
        return t.replace(ui, "\\$&")
    };
    var ui = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,
        hi = {}.__proto__ ? function(t, e) {
            t.__proto__ = e
        } : function(t, e) {
            for (var n in e) t[n] = e[n]
        },
        ci = function(t, e) {
            return e.querySelector(t)
        },
        li = function(t, e) {
            return e.querySelectorAll(t)
        },
        pi = Qr[a(Qr, "matchesSelector")],
        fi = function(t, e) {
            return pi.call(t, e)
        };
    "function" == typeof Sizzle && (ci = function(t, e) {
        return Sizzle(t, e)[0] || null
    }, li = function(t, e) {
        return Sizzle.uniqueSort(Sizzle(t, e))
    }, fi = Sizzle.matchesSelector), qr.selection = function() {
        return gi
    };
    var di = qr.selection.prototype = [];
    di.select = function(t) {
        var e, n, r, i, o = [];
        t = d(t);
        for (var a = -1, s = this.length; ++a < s;) {
            o.push(e = []), e.parentNode = (r = this[a]).parentNode;
            for (var u = -1, h = r.length; ++u < h;)(i = r[u]) ? (e.push(n = t.call(i, i.__data__, u, a)), n && "__data__" in i && (n.__data__ = i.__data__)) : e.push(null)
        }
        return f(o)
    }, di.selectAll = function(t) {
        var e, n, r = [];
        t = E(t);
        for (var i = -1, o = this.length; ++i < o;)
            for (var a = this[i], s = -1, u = a.length; ++s < u;)(n = a[s]) && (r.push(e = Kr(t.call(n, n.__data__, s, i))), e.parentNode = n);
        return f(r)
    };
    var Ei = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    qr.ns = {
        prefix: Ei,
        qualify: function(t) {
            var e = t.indexOf(":"),
                n = t;
            return e >= 0 && (n = t.substring(0, e), t = t.substring(e + 1)), Ei.hasOwnProperty(n) ? {
                space: Ei[n],
                local: t
            } : t
        }
    }, di.attr = function(t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) {
                var n = this.node();
                return (t = qr.ns.qualify(t)).local ? n.getAttributeNS(t.space, t.local) : n.getAttribute(t)
            }
            for (e in t) this.each(m(e, t[e]));
            return this
        }
        return this.each(m(t, e))
    }, di.classed = function(t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) {
                var n = this.node(),
                    r = (t = t.trim().split(/^|\s+/g)).length,
                    i = -1;
                if (e = n.classList) {
                    for (; ++i < r;)
                        if (!e.contains(t[i])) return !1
                } else
                    for (e = n.getAttribute("class"); ++i < r;)
                        if (!v(t[i]).test(e)) return !1;
                return !0
            }
            for (e in t) this.each(y(e, t[e]));
            return this
        }
        return this.each(y(t, e))
    }, di.style = function(t, e, n) {
        var r = arguments.length;
        if (3 > r) {
            if ("string" != typeof t) {
                for (n in 2 > r && (e = ""), t) this.each(R(n, t[n], e));
                return this
            }
            if (2 > r) return Jr.getComputedStyle(this.node(), null).getPropertyValue(t);
            n = ""
        }
        return this.each(R(t, e, n))
    }, di.property = function(t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) return this.node()[t];
            for (e in t) this.each(x(e, t[e]));
            return this
        }
        return this.each(x(t, e))
    }, di.text = function(t) {
        return arguments.length ? this.each("function" == typeof t ? function() {
            var e = t.apply(this, arguments);
            this.textContent = null == e ? "" : e
        } : null == t ? function() {
            this.textContent = ""
        } : function() {
            this.textContent = t
        }) : this.node().textContent
    }, di.html = function(t) {
        return arguments.length ? this.each("function" == typeof t ? function() {
            var e = t.apply(this, arguments);
            this.innerHTML = null == e ? "" : e
        } : null == t ? function() {
            this.innerHTML = ""
        } : function() {
            this.innerHTML = t
        }) : this.node().innerHTML
    }, di.append = function(t) {
        return t = b(t), this.select(function() {
            return this.appendChild(t.apply(this, arguments))
        })
    }, di.insert = function(t, e) {
        return t = b(t), e = d(e), this.select(function() {
            return this.insertBefore(t.apply(this, arguments), e.apply(this, arguments))
        })
    }, di.remove = function() {
        return this.each(function() {
            var t = this.parentNode;
            t && t.removeChild(this)
        })
    }, di.data = function(t, e) {
        function n(t, n) {
            var i, o, a, s = t.length,
                l = n.length,
                p = Math.min(s, l),
                f = new Array(l),
                d = new Array(l),
                E = new Array(s);
            if (e) {
                var m, g = new r,
                    v = new r,
                    y = [];
                for (i = -1; ++i < s;) m = e.call(o = t[i], o.__data__, i), g.has(m) ? E[i] = o : g.set(m, o), y.push(m);
                for (i = -1; ++i < l;) m = e.call(n, a = n[i], i), (o = g.get(m)) ? (f[i] = o, o.__data__ = a) : v.has(m) || (d[i] = H(a)), v.set(m, a), g.remove(m);
                for (i = -1; ++i < s;) g.has(y[i]) && (E[i] = t[i])
            } else {
                for (i = -1; ++i < p;) o = t[i], a = n[i], o ? (o.__data__ = a, f[i] = o) : d[i] = H(a);
                for (; l > i; ++i) d[i] = H(n[i]);
                for (; s > i; ++i) E[i] = t[i]
            }
            d.update = f, d.parentNode = f.parentNode = E.parentNode = t.parentNode, u.push(d), h.push(f), c.push(E)
        }
        var i, o, a = -1,
            s = this.length;
        if (!arguments.length) {
            for (t = new Array(s = (i = this[0]).length); ++a < s;)(o = i[a]) && (t[a] = o.__data__);
            return t
        }
        var u = M([]),
            h = f([]),
            c = f([]);
        if ("function" == typeof t)
            for (; ++a < s;) n(i = this[a], t.call(i, i.parentNode.__data__, a));
        else
            for (; ++a < s;) n(i = this[a], t);
        return h.enter = function() {
            return u
        }, h.exit = function() {
            return c
        }, h
    }, di.datum = function(t) {
        return arguments.length ? this.property("__data__", t) : this.property("__data__")
    }, di.filter = function(t) {
        var e, n, r, i = [];
        "function" != typeof t && (t = _(t));
        for (var o = 0, a = this.length; a > o; o++) {
            i.push(e = []), e.parentNode = (n = this[o]).parentNode;
            for (var s = 0, u = n.length; u > s; s++)(r = n[s]) && t.call(r, r.__data__, s) && e.push(r)
        }
        return f(i)
    }, di.order = function() {
        for (var t = -1, e = this.length; ++t < e;)
            for (var n, r = this[t], i = r.length - 1, o = r[i]; --i >= 0;)(n = r[i]) && (o && o !== n.nextSibling && o.parentNode.insertBefore(n, o), o = n);
        return this
    }, di.sort = function(t) {
        t = function(t) {
            return arguments.length || (t = qr.ascending),
                function(e, n) {
                    return e && n ? t(e.__data__, n.__data__) : !e - !n
                }
        }.apply(this, arguments);
        for (var e = -1, n = this.length; ++e < n;) this[e].sort(t);
        return this.order()
    }, di.each = function(t) {
        return w(this, function(e, n, r) {
            t.call(e, e.__data__, n, r)
        })
    }, di.call = function(t) {
        var e = Kr(arguments);
        return t.apply(e[0] = this, e), this
    }, di.empty = function() {
        return !this.node()
    }, di.node = function() {
        for (var t = 0, e = this.length; e > t; t++)
            for (var n = this[t], r = 0, i = n.length; i > r; r++) {
                var o = n[r];
                if (o) return o
            }
        return null
    }, di.size = function() {
        var t = 0;
        return this.each(function() {
            ++t
        }), t
    };
    var mi = [];
    qr.selection.enter = M, qr.selection.enter.prototype = mi, mi.append = di.append, mi.empty = di.empty, mi.node = di.node, mi.call = di.call, mi.size = di.size, mi.select = function(t) {
        for (var e, n, r, i, o, a = [], s = -1, u = this.length; ++s < u;) {
            r = (i = this[s]).update, a.push(e = []), e.parentNode = i.parentNode;
            for (var h = -1, c = i.length; ++h < c;)(o = i[h]) ? (e.push(r[h] = n = t.call(i.parentNode, o.__data__, h, s)), n.__data__ = o.__data__) : e.push(null)
        }
        return f(a)
    }, mi.insert = function(t, e) {
        return arguments.length < 2 && (e = function(t) {
            var e, n;
            return function(r, i, o) {
                var a, s = t[o].update,
                    u = s.length;
                for (o != n && (n = o, e = 0), i >= e && (e = i + 1); !(a = s[e]) && ++e < u;);
                return a
            }
        }(this)), di.insert.call(this, t, e)
    }, di.transition = function() {
        for (var t, e, n = ca || ++Ea, r = [], i = la || {
                time: Date.now(),
                ease: en,
                delay: 0,
                duration: 250
            }, o = -1, a = this.length; ++o < a;) {
            r.push(t = []);
            for (var s = this[o], u = -1, h = s.length; ++u < h;)(e = s[u]) && Mr(e, u, n, i), t.push(e)
        }
        return Hr(r, n)
    }, di.interrupt = function() {
        return this.each(S)
    }, qr.select = function(t) {
        var e = ["string" == typeof t ? ci(t, Zr) : t];
        return e.parentNode = Qr, f([e])
    }, qr.selectAll = function(t) {
        var e = Kr("string" == typeof t ? li(t, Zr) : t);
        return e.parentNode = Qr, f([e])
    };
    var gi = qr.select(Qr);
    di.on = function(t, e, n) {
        var r = arguments.length;
        if (3 > r) {
            if ("string" != typeof t) {
                for (n in 2 > r && (e = !1), t) this.each(A(n, t[n], e));
                return this
            }
            if (2 > r) return (r = this.node()["__on" + t]) && r._;
            n = !1
        }
        return this.each(A(t, e, n))
    };
    var vi = qr.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    vi.forEach(function(t) {
        "on" + t in Zr && vi.remove(t)
    });
    var yi = a(Qr.style, "userSelect"),
        Ti = 0;
    qr.mouse = function(t) {
        return P(t, l())
    };
    var Ri = /WebKit/.test(Jr.navigator.userAgent) ? -1 : 0;
    qr.touches = function(t, e) {
        return arguments.length < 2 && (e = l().touches), e ? Kr(e).map(function(e) {
            var n = P(t, e);
            return n.identifier = e.identifier, n
        }) : []
    }, qr.behavior.drag = function() {
        function t() {
            this.on("mousedown.drag", i).on("touchstart.drag", o)
        }

        function e(t, e, i, o) {
            return function() {
                var a, s = this,
                    u = s.parentNode,
                    h = n.of(s, arguments),
                    c = qr.event.target,
                    l = t(),
                    p = null == l ? "drag" : "drag-" + l,
                    f = e(u, l),
                    d = 0,
                    E = qr.select(Jr).on(i + "." + p, function() {
                        var t = e(u, l),
                            n = t[0] - f[0],
                            r = t[1] - f[1];
                        d |= n | r, f = t, h({
                            type: "drag",
                            x: t[0] + a[0],
                            y: t[1] + a[1],
                            dx: n,
                            dy: r
                        })
                    }).on(o + "." + p, function() {
                        E.on(i + "." + p, null).on(o + "." + p, null), m(d && qr.event.target === c), h({
                            type: "dragend"
                        })
                    }),
                    m = k();
                r ? a = [(a = r.apply(s, arguments)).x - f[0], a.y - f[1]] : a = [0, 0], h({
                    type: "dragstart"
                })
            }
        }
        var n = p(t, "drag", "dragstart", "dragend"),
            r = null,
            i = e(s, qr.mouse, "mousemove", "mouseup"),
            o = e(function() {
                return qr.event.changedTouches[0].identifier
            }, function(t, e) {
                return qr.touches(t).filter(function(t) {
                    return t.identifier === e
                })[0]
            }, "touchmove", "touchend");
        return t.origin = function(e) {
            return arguments.length ? (r = e, t) : r
        }, qr.rebind(t, n, "on")
    };
    var xi = Math.PI,
        bi = 2 * xi,
        Hi = xi / 2,
        _i = 1e-6,
        wi = _i * _i,
        Mi = xi / 180,
        Si = 180 / xi,
        Ai = Math.SQRT2,
        Ci = 2;
    qr.interpolateZoom = function(t, e) {
        function n(t) {
            var e = t * g;
            if (m) {
                var n = V(E),
                    a = o / (Ci * p) * (n * function(t) {
                        return ((t = Math.exp(2 * t)) - 1) / (t + 1)
                    }(Ai * e + E) - O(E));
                return [r + a * h, i + a * c, o * n / V(Ai * e + E)]
            }
            return [r + t * h, i + t * c, o * Math.exp(Ai * e)]
        }
        var r = t[0],
            i = t[1],
            o = t[2],
            a = e[0],
            s = e[1],
            u = e[2],
            h = a - r,
            c = s - i,
            l = h * h + c * c,
            p = Math.sqrt(l),
            f = (u * u - o * o + 4 * l) / (2 * o * Ci * p),
            d = (u * u - o * o - 4 * l) / (2 * u * Ci * p),
            E = Math.log(Math.sqrt(f * f + 1) - f),
            m = Math.log(Math.sqrt(d * d + 1) - d) - E,
            g = (m || Math.log(u / o)) / Ai;
        return n.duration = 1e3 * g, n
    }, qr.behavior.zoom = function() {
        function t(t) {
            t.on(w, u).on(Pi + ".zoom", l).on(M, f).on("dblclick.zoom", d).on(C, h)
        }

        function e(t) {
            return [(t[0] - b.x) / b.k, (t[1] - b.y) / b.k]
        }

        function n(t) {
            b.k = Math.max(_[0], Math.min(_[1], t))
        }

        function r(t, e) {
            e = function(t) {
                return [t[0] * b.k + b.x, t[1] * b.k + b.y]
            }(e), b.x += t[0] - e[0], b.y += t[1] - e[1]
        }

        function i() {
            T && T.domain(y.range().map(function(t) {
                return (t - b.x) / b.k
            }).map(y.invert)), x && x.domain(R.range().map(function(t) {
                return (t - b.y) / b.k
            }).map(R.invert))
        }

        function o(t) {
            t({
                type: "zoomstart"
            })
        }

        function a(t) {
            i(), t({
                type: "zoom",
                scale: b.k,
                translate: [b.x, b.y]
            })
        }

        function s(t) {
            t({
                type: "zoomend"
            })
        }

        function u() {
            var t = this,
                n = L.of(t, arguments),
                i = qr.event.target,
                u = 0,
                h = qr.select(Jr).on(M, function() {
                    u = 1, r(qr.mouse(t), c), a(n)
                }).on(A, function() {
                    h.on(M, Jr === t ? f : null).on(A, null), l(u && qr.event.target === i), s(n)
                }),
                c = e(qr.mouse(t)),
                l = k();
            S.call(t), o(n)
        }

        function h() {
            function t() {
                var t = qr.touches(p);
                return l = b.k, t.forEach(function(t) {
                    t.identifier in d && (d[t.identifier] = e(t))
                }), t
            }

            function i() {
                for (var e = qr.event.changedTouches, i = 0, o = e.length; o > i; ++i) d[e[i].identifier] = null;
                var s = t(),
                    u = Date.now();
                if (1 === s.length) {
                    if (500 > u - v) {
                        var h = s[0],
                            l = d[h.identifier];
                        n(2 * b.k), r(h, l), c(), a(f)
                    }
                    v = u
                } else if (s.length > 1) {
                    h = s[0];
                    var p = s[1],
                        m = h[0] - p[0],
                        g = h[1] - p[1];
                    E = m * m + g * g
                }
            }
            var l, p = this,
                f = L.of(p, arguments),
                d = {},
                E = 0,
                m = qr.event.changedTouches[0].identifier,
                g = "touchmove.zoom-" + m,
                y = "touchend.zoom-" + m,
                T = qr.select(Jr).on(g, function() {
                    for (var t, e, i, o, s = qr.touches(p), u = 0, h = s.length; h > u; ++u, o = null)
                        if (i = s[u], o = d[i.identifier]) {
                            if (e) break;
                            t = i, e = o
                        }
                    if (o) {
                        var c = (c = i[0] - t[0]) * c + (c = i[1] - t[1]) * c,
                            m = E && Math.sqrt(c / E);
                        t = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], e = [(e[0] + o[0]) / 2, (e[1] + o[1]) / 2], n(m * l)
                    }
                    v = null, r(t, e), a(f)
                }).on(y, function() {
                    if (qr.event.touches.length) {
                        for (var e = qr.event.changedTouches, n = 0, r = e.length; r > n; ++n) delete d[e[n].identifier];
                        for (var i in d) return void t()
                    }
                    T.on(g, null).on(y, null), R.on(w, u).on(C, h), x(), s(f)
                }),
                R = qr.select(p).on(w, null).on(C, i),
                x = k();
            S.call(p), i(), o(f)
        }

        function l() {
            var t = L.of(this, arguments);
            g ? clearTimeout(g) : (S.call(this), o(t)), g = setTimeout(function() {
                g = null, s(t)
            }, 50), c();
            var i = m || qr.mouse(this);
            E || (E = e(i)), n(Math.pow(2, .002 * Li()) * b.k), r(i, E), a(t)
        }

        function f() {
            E = null
        }

        function d() {
            var t = L.of(this, arguments),
                i = qr.mouse(this),
                u = e(i),
                h = Math.log(b.k) / Math.LN2;
            o(t), n(Math.pow(2, qr.event.shiftKey ? Math.ceil(h) - 1 : Math.floor(h) + 1)), r(i, u), a(t), s(t)
        }
        var E, m, g, v, y, T, R, x, b = {
                x: 0,
                y: 0,
                k: 1
            },
            H = [960, 500],
            _ = ki,
            w = "mousedown.zoom",
            M = "mousemove.zoom",
            A = "mouseup.zoom",
            C = "touchstart.zoom",
            L = p(t, "zoomstart", "zoom", "zoomend");
        return t.event = function(t) {
            t.each(function() {
                var t = L.of(this, arguments),
                    e = b;
                ca ? qr.select(this).transition().each("start.zoom", function() {
                    b = this.__chart__ || {
                        x: 0,
                        y: 0,
                        k: 1
                    }, o(t)
                }).tween("zoom:zoom", function() {
                    var n = H[0],
                        r = H[1],
                        i = n / 2,
                        o = r / 2,
                        s = qr.interpolateZoom([(i - b.x) / b.k, (o - b.y) / b.k, n / b.k], [(i - e.x) / e.k, (o - e.y) / e.k, n / e.k]);
                    return function(e) {
                        var r = s(e),
                            u = n / r[2];
                        this.__chart__ = b = {
                            x: i - r[0] * u,
                            y: o - r[1] * u,
                            k: u
                        }, a(t)
                    }
                }).each("end.zoom", function() {
                    s(t)
                }) : (this.__chart__ = b, o(t), a(t), s(t))
            })
        }, t.translate = function(e) {
            return arguments.length ? (b = {
                x: +e[0],
                y: +e[1],
                k: b.k
            }, i(), t) : [b.x, b.y]
        }, t.scale = function(e) {
            return arguments.length ? (b = {
                x: b.x,
                y: b.y,
                k: +e
            }, i(), t) : b.k
        }, t.scaleExtent = function(e) {
            return arguments.length ? (_ = null == e ? ki : [+e[0], +e[1]], t) : _
        }, t.center = function(e) {
            return arguments.length ? (m = e && [+e[0], +e[1]], t) : m
        }, t.size = function(e) {
            return arguments.length ? (H = e && [+e[0], +e[1]], t) : H
        }, t.x = function(e) {
            return arguments.length ? (T = e, y = e.copy(), b = {
                x: 0,
                y: 0,
                k: 1
            }, t) : T
        }, t.y = function(e) {
            return arguments.length ? (x = e, R = e.copy(), b = {
                x: 0,
                y: 0,
                k: 1
            }, t) : x
        }, qr.rebind(t, L, "on")
    };
    var Li, ki = [0, 1 / 0],
        Pi = "onwheel" in Zr ? (Li = function() {
            return -qr.event.deltaY * (qr.event.deltaMode ? 120 : 1)
        }, "wheel") : "onmousewheel" in Zr ? (Li = function() {
            return qr.event.wheelDelta
        }, "mousewheel") : (Li = function() {
            return -qr.event.detail
        }, "MozMousePixelScroll");
    B.prototype.toString = function() {
        return this.rgb() + ""
    }, qr.hsl = function(t, e, n) {
        return 1 === arguments.length ? t instanceof z ? I(t.h, t.s, t.l) : ot("" + t, at, I) : I(+t, +e, +n)
    };
    var Di = z.prototype = new B;
    Di.brighter = function(t) {
        return t = Math.pow(.7, arguments.length ? t : 1), I(this.h, this.s, this.l / t)
    }, Di.darker = function(t) {
        return t = Math.pow(.7, arguments.length ? t : 1), I(this.h, this.s, t * this.l)
    }, Di.rgb = function() {
        return G(this.h, this.s, this.l)
    }, qr.hcl = function(t, e, n) {
        return 1 === arguments.length ? t instanceof W ? j(t.h, t.c, t.l) : Z(t instanceof Y ? t.l : (t = st((t = qr.rgb(t)).r, t.g, t.b)).l, t.a, t.b) : j(+t, +e, +n)
    };
    var Ni = W.prototype = new B;
    Ni.brighter = function(t) {
        return j(this.h, this.c, Math.min(100, this.l + Fi * (arguments.length ? t : 1)))
    }, Ni.darker = function(t) {
        return j(this.h, this.c, Math.max(0, this.l - Fi * (arguments.length ? t : 1)))
    }, Ni.rgb = function() {
        return X(this.h, this.c, this.l).rgb()
    }, qr.lab = function(t, e, n) {
        return 1 === arguments.length ? t instanceof Y ? q(t.l, t.a, t.b) : t instanceof W ? X(t.l, t.c, t.h) : st((t = qr.rgb(t)).r, t.g, t.b) : q(+t, +e, +n)
    };
    var Fi = 18,
        Oi = .95047,
        Vi = 1,
        Ui = 1.08883,
        Bi = Y.prototype = new B;
    Bi.brighter = function(t) {
        return q(Math.min(100, this.l + Fi * (arguments.length ? t : 1)), this.a, this.b)
    }, Bi.darker = function(t) {
        return q(Math.max(0, this.l - Fi * (arguments.length ? t : 1)), this.a, this.b)
    }, Bi.rgb = function() {
        return K(this.l, this.a, this.b)
    }, qr.rgb = function(t, e, n) {
        return 1 === arguments.length ? t instanceof rt ? nt(t.r, t.g, t.b) : ot("" + t, nt, G) : nt(~~t, ~~e, ~~n)
    };
    var Ii = rt.prototype = new B;
    Ii.brighter = function(t) {
        t = Math.pow(.7, arguments.length ? t : 1);
        var e = this.r,
            n = this.g,
            r = this.b,
            i = 30;
        return e || n || r ? (e && i > e && (e = i), n && i > n && (n = i), r && i > r && (r = i), nt(Math.min(255, ~~(e / t)), Math.min(255, ~~(n / t)), Math.min(255, ~~(r / t)))) : nt(i, i, i)
    }, Ii.darker = function(t) {
        return nt(~~((t = Math.pow(.7, arguments.length ? t : 1)) * this.r), ~~(t * this.g), ~~(t * this.b))
    }, Ii.hsl = function() {
        return at(this.r, this.g, this.b)
    }, Ii.toString = function() {
        return "#" + it(this.r) + it(this.g) + it(this.b)
    };
    var zi = qr.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    zi.forEach(function(t, e) {
        zi.set(t, tt(e))
    }), qr.functor = ct, qr.xhr = pt(lt), qr.dsv = function(t, e) {
        function n(t, n, i) {
            arguments.length < 3 && (i = n, n = null);
            var a = qr.xhr(t, e, i);
            return a.row = function(t) {
                return arguments.length ? a.response(null == (n = t) ? r : o(t)) : n
            }, a.row(n)
        }

        function r(t) {
            return n.parse(t.responseText)
        }

        function o(t) {
            return function(e) {
                return n.parse(e.responseText, t)
            }
        }

        function a(e) {
            return e.map(s).join(t)
        }

        function s(t) {
            return u.test(t) ? '"' + t.replace(/\"/g, '""') + '"' : t
        }
        var u = new RegExp('["' + t + "\n]"),
            h = t.charCodeAt(0);
        return n.parse = function(t, e) {
            var r;
            return n.parseRows(t, function(t, n) {
                if (r) return r(t, n - 1);
                var i = new Function("d", "return {" + t.map(function(t, e) {
                    return JSON.stringify(t) + ": d[" + e + "]"
                }).join(",") + "}");
                r = e ? function(t, n) {
                    return e(i(t), n)
                } : i
            })
        }, n.parseRows = function(t, e) {
            function n() {
                if (c >= u) return a;
                if (i) return i = !1, o;
                var e = c;
                if (34 === t.charCodeAt(e)) {
                    for (var n = e; n++ < u;)
                        if (34 === t.charCodeAt(n)) {
                            if (34 !== t.charCodeAt(n + 1)) break;
                            ++n
                        }
                    return c = n + 2, 13 === (r = t.charCodeAt(n + 1)) ? (i = !0, 10 === t.charCodeAt(n + 2) && ++c) : 10 === r && (i = !0), t.substring(e + 1, n).replace(/""/g, '"')
                }
                for (; u > c;) {
                    var r, s = 1;
                    if (10 === (r = t.charCodeAt(c++))) i = !0;
                    else if (13 === r) i = !0, 10 === t.charCodeAt(c) && (++c, ++s);
                    else if (r !== h) continue;
                    return t.substring(e, c - s)
                }
                return t.substring(e)
            }
            for (var r, i, o = {}, a = {}, s = [], u = t.length, c = 0, l = 0;
                (r = n()) !== a;) {
                for (var p = []; r !== o && r !== a;) p.push(r), r = n();
                (!e || (p = e(p, l++))) && s.push(p)
            }
            return s
        }, n.format = function(e) {
            if (Array.isArray(e[0])) return n.formatRows(e);
            var r = new i,
                o = [];
            return e.forEach(function(t) {
                for (var e in t) r.has(e) || o.push(r.add(e))
            }), [o.map(s).join(t)].concat(e.map(function(e) {
                return o.map(function(t) {
                    return s(e[t])
                }).join(t)
            })).join("\n")
        }, n.formatRows = function(t) {
            return t.map(a).join("\n")
        }, n
    }, qr.csv = qr.dsv(",", "text/csv"), qr.tsv = qr.dsv("\t", "text/tab-separated-values");
    var Gi, ji, Wi, Xi, qi, Yi = Jr[a(Jr, "requestAnimationFrame")] || function(t) {
        setTimeout(t, 17)
    };
    qr.timer = function(t, e, n) {
        var r = arguments.length;
        2 > r && (e = 0), 3 > r && (n = Date.now());
        var i = {
            callback: t,
            time: n + e,
            next: null
        };
        ji ? ji.next = i : Gi = i, ji = i, Wi || (Xi = clearTimeout(Xi), Wi = 1, Yi(dt))
    }, qr.timer.flush = function() {
        mt(), gt()
    };
    var Ki = [3, 3],
        Zi = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(function(t, e) {
            var n = Math.pow(10, 3 * Math.abs(8 - e));
            return {
                scale: e > 8 ? function(t) {
                    return t / n
                } : function(t) {
                    return t * n
                },
                symbol: t
            }
        });
    qr.formatPrefix = function(t, e) {
        var n = 0;
        return t && (0 > t && (t *= -1), e && (t = qr.round(t, vt(t, e))), n = 1 + Math.floor(1e-12 + Math.log(t) / Math.LN10), n = Math.max(-24, Math.min(24, 3 * Math.floor((0 >= n ? n + 1 : n - 1) / 3)))), Zi[8 + n / 3]
    }, qr.round = function(t, e) {
        return e ? Math.round(t * (e = Math.pow(10, e))) / e : Math.round(t)
    }, qr.format = function(t) {
        var e = Qi.exec(t),
            n = e[1] || " ",
            r = e[2] || ">",
            i = e[3] || "",
            o = e[4] || "",
            a = e[5],
            s = +e[6],
            u = e[7],
            h = e[8],
            c = e[9],
            l = 1,
            p = "",
            f = !1;
        switch (h && (h = +h.substring(1)), (a || "0" === n && "=" === r) && (a = n = "0", r = "=", u && (s -= Math.floor((s - 1) / 4))), c) {
            case "n":
                u = !0, c = "g";
                break;
            case "%":
                l = 100, p = "%", c = "f";
                break;
            case "p":
                l = 100, p = "%", c = "r";
                break;
            case "b":
            case "o":
            case "x":
            case "X":
                "#" === o && (o = "0" + c.toLowerCase());
            case "c":
            case "d":
                f = !0, h = 0;
                break;
            case "s":
                l = -1, c = "r"
        }
        "#" === o ? o = "" : "$" === o && (o = "$"), "r" != c || h || (c = "g"), null != h && ("g" == c ? h = Math.max(1, Math.min(21, h)) : ("e" == c || "f" == c) && (h = Math.max(0, Math.min(20, h)))), c = Ji.get(c) || yt;
        var d = a && u;
        return function(t) {
            if (f && t % 1) return "";
            var e = 0 > t || 0 === t && 0 > 1 / t ? (t = -t, "-") : i;
            if (0 > l) {
                var E = qr.formatPrefix(t, h);
                t = E.scale(t), p = E.symbol
            } else t *= l;
            var m = (t = c(t, h)).lastIndexOf("."),
                g = 0 > m ? t : t.substring(0, m),
                v = 0 > m ? "" : "." + t.substring(m + 1);
            !a && u && (g = $i(g));
            var y = o.length + g.length + v.length + (d ? 0 : e.length),
                T = s > y ? new Array(y = s - y + 1).join(n) : "";
            return d && (g = $i(T + g)), e += o, t = g + v, ("<" === r ? e + t + T : ">" === r ? T + e + t : "^" === r ? T.substring(0, y >>= 1) + e + t + T.substring(y) : e + (d ? t : T + t)) + p
        }
    };
    var Qi = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,
        Ji = qr.map({
            b: function(t) {
                return t.toString(2)
            },
            c: function(t) {
                return String.fromCharCode(t)
            },
            o: function(t) {
                return t.toString(8)
            },
            x: function(t) {
                return t.toString(16)
            },
            X: function(t) {
                return t.toString(16).toUpperCase()
            },
            g: function(t, e) {
                return t.toPrecision(e)
            },
            e: function(t, e) {
                return t.toExponential(e)
            },
            f: function(t, e) {
                return t.toFixed(e)
            },
            r: function(t, e) {
                return (t = qr.round(t, vt(t, e))).toFixed(Math.max(0, Math.min(20, vt(t * (1 + 1e-15), e))))
            }
        }),
        $i = lt;
    if (Ki) {
        var to = Ki.length;
        $i = function(t) {
            for (var e = t.length, n = [], r = 0, i = Ki[0]; e > 0 && i > 0;) n.push(t.substring(e -= i, e + i)), i = Ki[r = (r + 1) % to];
            return n.reverse().join(",")
        }
    }
    qr.geo = {}, Tt.prototype = {
        s: 0,
        t: 0,
        add: function(t) {
            Rt(t, this.t, eo), Rt(eo.s, this.s, this), this.s ? this.t += eo.t : this.s = eo.t
        },
        reset: function() {
            this.s = this.t = 0
        },
        valueOf: function() {
            return this.s
        }
    };
    var eo = new Tt;
    qr.geo.stream = function(t, e) {
        t && no.hasOwnProperty(t.type) ? no[t.type](t, e) : xt(t, e)
    };
    var no = {
            Feature: function(t, e) {
                xt(t.geometry, e)
            },
            FeatureCollection: function(t, e) {
                for (var n = t.features, r = -1, i = n.length; ++r < i;) xt(n[r].geometry, e)
            }
        },
        ro = {
            Sphere: function(t, e) {
                e.sphere()
            },
            Point: function(t, e) {
                t = t.coordinates, e.point(t[0], t[1], t[2])
            },
            MultiPoint: function(t, e) {
                for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) t = n[r], e.point(t[0], t[1], t[2])
            },
            LineString: function(t, e) {
                bt(t.coordinates, e, 0)
            },
            MultiLineString: function(t, e) {
                for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) bt(n[r], e, 0)
            },
            Polygon: function(t, e) {
                Ht(t.coordinates, e)
            },
            MultiPolygon: function(t, e) {
                for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) Ht(n[r], e)
            },
            GeometryCollection: function(t, e) {
                for (var n = t.geometries, r = -1, i = n.length; ++r < i;) xt(n[r], e)
            }
        };
    qr.geo.area = function(t) {
        return io = 0, qr.geo.stream(t, ao), io
    };
    var io, oo = new Tt,
        ao = {
            sphere: function() {
                io += 4 * xi
            },
            point: s,
            lineStart: s,
            lineEnd: s,
            polygonStart: function() {
                oo.reset(), ao.lineStart = _t
            },
            polygonEnd: function() {
                var t = 2 * oo;
                io += 0 > t ? 4 * xi + t : t, ao.lineStart = ao.lineEnd = ao.point = s
            }
        };
    qr.geo.bounds = function() {
        function t(t, e) {
            y.push(T = [c = t, p = t]), l > e && (l = e), e > f && (f = e)
        }

        function e(e, n) {
            var r = wt([e * Mi, n * Mi]);
            if (g) {
                var i = St(g, r),
                    o = St([i[1], -i[0], 0], i);
                Lt(o), o = kt(o);
                var a = e - d,
                    u = a > 0 ? 1 : -1,
                    h = o[0] * Si * u,
                    E = Math.abs(a) > 180;
                if (E ^ (h > u * d && u * e > h))(m = o[1] * Si) > f && (f = m);
                else if (E ^ ((h = (h + 360) % 360 - 180) > u * d && u * e > h)) {
                    var m = -o[1] * Si;
                    l > m && (l = m)
                } else l > n && (l = n), n > f && (f = n);
                E ? d > e ? s(c, e) > s(c, p) && (p = e) : s(e, p) > s(c, p) && (c = e) : p >= c ? (c > e && (c = e), e > p && (p = e)) : e > d ? s(c, e) > s(c, p) && (p = e) : s(e, p) > s(c, p) && (c = e)
            } else t(e, n);
            g = r, d = e
        }

        function n() {
            R.point = e
        }

        function r() {
            T[0] = c, T[1] = p, R.point = t, g = null
        }

        function i(t, n) {
            if (g) {
                var r = t - d;
                v += Math.abs(r) > 180 ? r + (r > 0 ? 360 : -360) : r
            } else E = t, m = n;
            ao.point(t, n), e(t, n)
        }

        function o() {
            ao.lineStart()
        }

        function a() {
            i(E, m), ao.lineEnd(), Math.abs(v) > _i && (c = -(p = 180)), T[0] = c, T[1] = p, g = null
        }

        function s(t, e) {
            return (e -= t) < 0 ? e + 360 : e
        }

        function u(t, e) {
            return t[0] - e[0]
        }

        function h(t, e) {
            return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t
        }
        var c, l, p, f, d, E, m, g, v, y, T, R = {
            point: t,
            lineStart: n,
            lineEnd: r,
            polygonStart: function() {
                R.point = i, R.lineStart = o, R.lineEnd = a, v = 0, ao.polygonStart()
            },
            polygonEnd: function() {
                ao.polygonEnd(), R.point = t, R.lineStart = n, R.lineEnd = r, 0 > oo ? (c = -(p = 180), l = -(f = 90)) : v > _i ? f = 90 : -_i > v && (l = -90), T[0] = c, T[1] = p
            }
        };
        return function(t) {
            if (f = p = -(c = l = 1 / 0), y = [], qr.geo.stream(t, R), o = y.length) {
                y.sort(u);
                for (var e = 1, n = [d = y[0]]; o > e; ++e) h((i = y[e])[0], d) || h(i[1], d) ? (s(d[0], i[1]) > s(d[0], d[1]) && (d[1] = i[1]), s(i[0], d[1]) > s(d[0], d[1]) && (d[0] = i[0])) : n.push(d = i);
                for (var r, i, o, a = -1 / 0, d = (e = 0, n[o = n.length - 1]); o >= e; d = i, ++e) i = n[e], (r = s(d[1], i[0])) > a && (a = r, c = i[0], p = d[1])
            }
            return y = T = null, 1 / 0 === c || 1 / 0 === l ? [
                [NaN, NaN],
                [NaN, NaN]
            ] : [
                [c, l],
                [p, f]
            ]
        }
    }(), qr.geo.centroid = function(t) {
        so = uo = ho = co = lo = po = fo = Eo = mo = go = vo = 0, qr.geo.stream(t, yo);
        var e = mo,
            n = go,
            r = vo,
            i = e * e + n * n + r * r;
        return wi > i && (e = po, n = fo, r = Eo, _i > uo && (e = ho, n = co, r = lo), wi > (i = e * e + n * n + r * r)) ? [NaN, NaN] : [Math.atan2(n, e) * Si, F(r / Math.sqrt(i)) * Si]
    };
    var so, uo, ho, co, lo, po, fo, Eo, mo, go, vo, yo = {
            sphere: s,
            point: Dt,
            lineStart: Ft,
            lineEnd: Ot,
            polygonStart: function() {
                yo.lineStart = Vt
            },
            polygonEnd: function() {
                yo.lineStart = Ft
            }
        },
        To = zt(Ut, function(t) {
            var e, n = NaN,
                r = NaN,
                i = NaN;
            return {
                lineStart: function() {
                    t.lineStart(), e = 1
                },
                point: function(o, a) {
                    var s = o > 0 ? xi : -xi,
                        u = Math.abs(o - n);
                    Math.abs(u - xi) < _i ? (t.point(n, r = (r + a) / 2 > 0 ? Hi : -Hi), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(s, r), t.point(o, r), e = 0) : i !== s && u >= xi && (Math.abs(n - i) < _i && (n -= i * _i), Math.abs(o - s) < _i && (o -= s * _i), r = function(t, e, n, r) {
                        var i, o, a = Math.sin(t - n);
                        return Math.abs(a) > _i ? Math.atan((Math.sin(e) * (o = Math.cos(r)) * Math.sin(n) - Math.sin(r) * (i = Math.cos(e)) * Math.sin(t)) / (i * o * a)) : (e + r) / 2
                    }(n, r, o, a), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(s, r), e = 0), t.point(n = o, r = a), i = s
                },
                lineEnd: function() {
                    t.lineEnd(), n = r = NaN
                },
                clean: function() {
                    return 2 - e
                }
            }
        }, function(t, e, n, r) {
            var i;
            if (null == t) i = n * Hi, r.point(-xi, i), r.point(0, i), r.point(xi, i), r.point(xi, 0), r.point(xi, -i), r.point(0, -i), r.point(-xi, -i), r.point(-xi, 0), r.point(-xi, i);
            else if (Math.abs(t[0] - e[0]) > _i) {
                var o = (t[0] < e[0] ? 1 : -1) * xi;
                i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i)
            } else r.point(e[0], e[1])
        }, [-xi, -xi / 2]),
        Ro = 1e9;
    qr.geo.clipExtent = function() {
        var t, e, n, r, i, o, a = {
            stream: function(t) {
                return i && (i.valid = !1), (i = o(t)).valid = !0, i
            },
            extent: function(s) {
                return arguments.length ? (o = Xt(t = +s[0][0], e = +s[0][1], n = +s[1][0], r = +s[1][1]), i && (i.valid = !1, i = null), a) : [
                    [t, e],
                    [n, r]
                ]
            }
        };
        return a.extent([
            [0, 0],
            [960, 500]
        ])
    }, (qr.geo.conicEqualArea = function() {
        return Kt(Zt)
    }).raw = Zt, qr.geo.albers = function() {
        return qr.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
    }, qr.geo.albersUsa = function() {
        function t(t) {
            var o = t[0],
                a = t[1];
            return e = null, n(o, a), e || (r(o, a), e) || i(o, a), e
        }
        var e, n, r, i, o = qr.geo.albers(),
            a = qr.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            s = qr.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
            u = {
                point: function(t, n) {
                    e = [t, n]
                }
            };
        return t.invert = function(t) {
            var e = o.scale(),
                n = o.translate(),
                r = (t[0] - n[0]) / e,
                i = (t[1] - n[1]) / e;
            return (i >= .12 && .234 > i && r >= -.425 && -.214 > r ? a : i >= .166 && .234 > i && r >= -.214 && -.115 > r ? s : o).invert(t)
        }, t.stream = function(t) {
            var e = o.stream(t),
                n = a.stream(t),
                r = s.stream(t);
            return {
                point: function(t, i) {
                    e.point(t, i), n.point(t, i), r.point(t, i)
                },
                sphere: function() {
                    e.sphere(), n.sphere(), r.sphere()
                },
                lineStart: function() {
                    e.lineStart(), n.lineStart(), r.lineStart()
                },
                lineEnd: function() {
                    e.lineEnd(), n.lineEnd(), r.lineEnd()
                },
                polygonStart: function() {
                    e.polygonStart(), n.polygonStart(), r.polygonStart()
                },
                polygonEnd: function() {
                    e.polygonEnd(), n.polygonEnd(), r.polygonEnd()
                }
            }
        }, t.precision = function(e) {
            return arguments.length ? (o.precision(e), a.precision(e), s.precision(e), t) : o.precision()
        }, t.scale = function(e) {
            return arguments.length ? (o.scale(e), a.scale(.35 * e), s.scale(e), t.translate(o.translate())) : o.scale()
        }, t.translate = function(e) {
            if (!arguments.length) return o.translate();
            var h = o.scale(),
                c = +e[0],
                l = +e[1];
            return n = o.translate(e).clipExtent([
                [c - .455 * h, l - .238 * h],
                [c + .455 * h, l + .238 * h]
            ]).stream(u).point, r = a.translate([c - .307 * h, l + .201 * h]).clipExtent([
                [c - .425 * h + _i, l + .12 * h + _i],
                [c - .214 * h - _i, l + .234 * h - _i]
            ]).stream(u).point, i = s.translate([c - .205 * h, l + .212 * h]).clipExtent([
                [c - .214 * h + _i, l + .166 * h + _i],
                [c - .115 * h - _i, l + .234 * h - _i]
            ]).stream(u).point, t
        }, t.scale(1070)
    };
    var xo, bo, Ho, _o, wo, Mo, So = {
            point: s,
            lineStart: s,
            lineEnd: s,
            polygonStart: function() {
                bo = 0, So.lineStart = Qt
            },
            polygonEnd: function() {
                So.lineStart = So.lineEnd = So.point = s, xo += Math.abs(bo / 2)
            }
        },
        Ao = {
            point: function(t, e) {
                Ho > t && (Ho = t), t > wo && (wo = t), _o > e && (_o = e), e > Mo && (Mo = e)
            },
            lineStart: s,
            lineEnd: s,
            polygonStart: s,
            polygonEnd: s
        },
        Co = {
            point: $t,
            lineStart: te,
            lineEnd: ee,
            polygonStart: function() {
                Co.lineStart = ne
            },
            polygonEnd: function() {
                Co.point = $t, Co.lineStart = te, Co.lineEnd = ee
            }
        };
    qr.geo.transform = function(t) {
        return {
            stream: function(e) {
                var n = new ie(e);
                for (var r in t) n[r] = t[r];
                return n
            }
        }
    }, ie.prototype = {
        point: function(t, e) {
            this.stream.point(t, e)
        },
        sphere: function() {
            this.stream.sphere()
        },
        lineStart: function() {
            this.stream.lineStart()
        },
        lineEnd: function() {
            this.stream.lineEnd()
        },
        polygonStart: function() {
            this.stream.polygonStart()
        },
        polygonEnd: function() {
            this.stream.polygonEnd()
        }
    }, qr.geo.path = function() {
        function t(t) {
            return t && ("function" == typeof u && o.pointRadius(+u.apply(this, arguments)), a && a.valid || (a = i(o)), qr.geo.stream(t, a)), o.result()
        }

        function e() {
            return a = null, t
        }
        var n, r, i, o, a, u = 4.5;
        return t.area = function(t) {
            return xo = 0, qr.geo.stream(t, i(So)), xo
        }, t.centroid = function(t) {
            return ho = co = lo = po = fo = Eo = mo = go = vo = 0, qr.geo.stream(t, i(Co)), vo ? [mo / vo, go / vo] : Eo ? [po / Eo, fo / Eo] : lo ? [ho / lo, co / lo] : [NaN, NaN]
        }, t.bounds = function(t) {
            return wo = Mo = -(Ho = _o = 1 / 0), qr.geo.stream(t, i(Ao)), [
                [Ho, _o],
                [wo, Mo]
            ]
        }, t.projection = function(t) {
            return arguments.length ? (i = (n = t) ? t.stream || function(t) {
                var e = re(function(e, n) {
                    return t([e * Si, n * Si])
                });
                return function(t) {
                    var n = new ie(t = e(t));
                    return n.point = function(e, n) {
                        t.point(e * Mi, n * Mi)
                    }, n
                }
            }(t) : lt, e()) : n
        }, t.context = function(t) {
            return arguments.length ? (o = null == (r = t) ? new function() {
                function t(t, e) {
                    a.push("M", t, ",", e, o)
                }

                function e(t, e) {
                    a.push("M", t, ",", e), s.point = n
                }

                function n(t, e) {
                    a.push("L", t, ",", e)
                }

                function r() {
                    s.point = t
                }

                function i() {
                    a.push("Z")
                }
                var o = Jt(4.5),
                    a = [],
                    s = {
                        point: t,
                        lineStart: function() {
                            s.point = e
                        },
                        lineEnd: r,
                        polygonStart: function() {
                            s.lineEnd = i
                        },
                        polygonEnd: function() {
                            s.lineEnd = r, s.point = t
                        },
                        pointRadius: function(t) {
                            return o = Jt(t), s
                        },
                        result: function() {
                            if (a.length) {
                                var t = a.join("");
                                return a = [], t
                            }
                        }
                    };
                return s
            } : new function(t) {
                function e(e, n) {
                    t.moveTo(e, n), t.arc(e, n, a, 0, bi)
                }

                function n(e, n) {
                    t.moveTo(e, n), u.point = r
                }

                function r(e, n) {
                    t.lineTo(e, n)
                }

                function i() {
                    u.point = e
                }

                function o() {
                    t.closePath()
                }
                var a = 4.5,
                    u = {
                        point: e,
                        lineStart: function() {
                            u.point = n
                        },
                        lineEnd: i,
                        polygonStart: function() {
                            u.lineEnd = o
                        },
                        polygonEnd: function() {
                            u.lineEnd = i, u.point = e
                        },
                        pointRadius: function(t) {
                            return a = t, u
                        },
                        result: s
                    };
                return u
            }(t), "function" != typeof u && o.pointRadius(u), e()) : r
        }, t.pointRadius = function(e) {
            return arguments.length ? (u = "function" == typeof e ? e : (o.pointRadius(+e), +e), t) : u
        }, t.projection(qr.geo.albersUsa()).context(null)
    }, qr.geo.projection = oe, qr.geo.projectionMutator = ae, (qr.geo.equirectangular = function() {
        return oe(se)
    }).raw = se.invert = se, qr.geo.rotation = function(t) {
        function e(e) {
            return (e = t(e[0] * Mi, e[1] * Mi))[0] *= Si, e[1] *= Si, e
        }
        return t = he(t[0] % 360 * Mi, t[1] * Mi, t.length > 2 ? t[2] * Mi : 0), e.invert = function(e) {
            return (e = t.invert(e[0] * Mi, e[1] * Mi))[0] *= Si, e[1] *= Si, e
        }, e
    }, ue.invert = se, qr.geo.circle = function() {
        function t() {
            var t = "function" == typeof r ? r.apply(this, arguments) : r,
                e = he(-t[0] * Mi, -t[1] * Mi, 0).invert,
                i = [];
            return n(null, null, 1, {
                point: function(t, n) {
                    i.push(t = e(t, n)), t[0] *= Si, t[1] *= Si
                }
            }), {
                type: "Polygon",
                coordinates: [i]
            }
        }
        var e, n, r = [0, 0],
            i = 6;
        return t.origin = function(e) {
            return arguments.length ? (r = e, t) : r
        }, t.angle = function(r) {
            return arguments.length ? (n = fe((e = +r) * Mi, i * Mi), t) : e
        }, t.precision = function(r) {
            return arguments.length ? (n = fe(e * Mi, (i = +r) * Mi), t) : i
        }, t.angle(90)
    }, qr.geo.distance = function(t, e) {
        var n, r = (e[0] - t[0]) * Mi,
            i = t[1] * Mi,
            o = e[1] * Mi,
            a = Math.sin(r),
            s = Math.cos(r),
            u = Math.sin(i),
            h = Math.cos(i),
            c = Math.sin(o),
            l = Math.cos(o);
        return Math.atan2(Math.sqrt((n = l * a) * n + (n = h * c - u * l * s) * n), u * c + h * l * s)
    }, qr.geo.graticule = function() {
        function t() {
            return {
                type: "MultiLineString",
                coordinates: e()
            }
        }

        function e() {
            return qr.range(Math.ceil(o / m) * m, i, m).map(p).concat(qr.range(Math.ceil(h / g) * g, u, g).map(f)).concat(qr.range(Math.ceil(r / d) * d, n, d).filter(function(t) {
                return Math.abs(t % m) > _i
            }).map(c)).concat(qr.range(Math.ceil(s / E) * E, a, E).filter(function(t) {
                return Math.abs(t % g) > _i
            }).map(l))
        }
        var n, r, i, o, a, s, u, h, c, l, p, f, d = 10,
            E = d,
            m = 90,
            g = 360,
            v = 2.5;
        return t.lines = function() {
            return e().map(function(t) {
                return {
                    type: "LineString",
                    coordinates: t
                }
            })
        }, t.outline = function() {
            return {
                type: "Polygon",
                coordinates: [p(o).concat(f(u).slice(1), p(i).reverse().slice(1), f(h).reverse().slice(1))]
            }
        }, t.extent = function(e) {
            return arguments.length ? t.majorExtent(e).minorExtent(e) : t.minorExtent()
        }, t.majorExtent = function(e) {
            return arguments.length ? (o = +e[0][0], i = +e[1][0], h = +e[0][1], u = +e[1][1], o > i && (e = o, o = i, i = e), h > u && (e = h, h = u, u = e), t.precision(v)) : [
                [o, h],
                [i, u]
            ]
        }, t.minorExtent = function(e) {
            return arguments.length ? (r = +e[0][0], n = +e[1][0], s = +e[0][1], a = +e[1][1], r > n && (e = r, r = n, n = e), s > a && (e = s, s = a, a = e), t.precision(v)) : [
                [r, s],
                [n, a]
            ]
        }, t.step = function(e) {
            return arguments.length ? t.majorStep(e).minorStep(e) : t.minorStep()
        }, t.majorStep = function(e) {
            return arguments.length ? (m = +e[0], g = +e[1], t) : [m, g]
        }, t.minorStep = function(e) {
            return arguments.length ? (d = +e[0], E = +e[1], t) : [d, E]
        }, t.precision = function(e) {
            return arguments.length ? (v = +e, c = Ee(s, a, 90), l = me(r, n, v), p = Ee(h, u, 90), f = me(o, i, v), t) : v
        }, t.majorExtent([
            [-180, -90 + _i],
            [180, 90 - _i]
        ]).minorExtent([
            [-180, -80 - _i],
            [180, 80 + _i]
        ])
    }, qr.geo.greatArc = function() {
        function t() {
            return {
                type: "LineString",
                coordinates: [e || r.apply(this, arguments), n || i.apply(this, arguments)]
            }
        }
        var e, n, r = ge,
            i = ve;
        return t.distance = function() {
            return qr.geo.distance(e || r.apply(this, arguments), n || i.apply(this, arguments))
        }, t.source = function(n) {
            return arguments.length ? (r = n, e = "function" == typeof n ? null : n, t) : r
        }, t.target = function(e) {
            return arguments.length ? (i = e, n = "function" == typeof e ? null : e, t) : i
        }, t.precision = function() {
            return arguments.length ? t : 0
        }, t
    }, qr.geo.interpolate = function(t, e) {
        return function(t, e, n, r) {
            var i = Math.cos(e),
                o = Math.sin(e),
                a = Math.cos(r),
                s = Math.sin(r),
                u = i * Math.cos(t),
                h = i * Math.sin(t),
                c = a * Math.cos(n),
                l = a * Math.sin(n),
                p = 2 * Math.asin(Math.sqrt(U(r - e) + i * a * U(n - t))),
                f = 1 / Math.sin(p),
                d = p ? function(t) {
                    var e = Math.sin(t *= p) * f,
                        n = Math.sin(p - t) * f,
                        r = n * u + e * c,
                        i = n * h + e * l,
                        a = n * o + e * s;
                    return [Math.atan2(i, r) * Si, Math.atan2(a, Math.sqrt(r * r + i * i)) * Si]
                } : function() {
                    return [t * Si, e * Si]
                };
            return d.distance = p, d
        }(t[0] * Mi, t[1] * Mi, e[0] * Mi, e[1] * Mi)
    }, qr.geo.length = function(t) {
        return Lo = 0, qr.geo.stream(t, ko), Lo
    };
    var Lo, ko = {
            sphere: s,
            point: s,
            lineStart: function() {
                function t(t, i) {
                    var o = Math.sin(i *= Mi),
                        a = Math.cos(i),
                        s = Math.abs((t *= Mi) - e),
                        u = Math.cos(s);
                    Lo += Math.atan2(Math.sqrt((s = a * Math.sin(s)) * s + (s = r * o - n * a * u) * s), n * o + r * a * u), e = t, n = o, r = a
                }
                var e, n, r;
                ko.point = function(i, o) {
                    e = i * Mi, n = Math.sin(o *= Mi), r = Math.cos(o), ko.point = t
                }, ko.lineEnd = function() {
                    ko.point = ko.lineEnd = s
                }
            },
            lineEnd: s,
            polygonStart: s,
            polygonEnd: s
        },
        Po = ye(function(t) {
            return Math.sqrt(2 / (1 + t))
        }, function(t) {
            return 2 * Math.asin(t / 2)
        });
    (qr.geo.azimuthalEqualArea = function() {
        return oe(Po)
    }).raw = Po;
    var Do = ye(function(t) {
        var e = Math.acos(t);
        return e && e / Math.sin(e)
    }, lt);
    (qr.geo.azimuthalEquidistant = function() {
        return oe(Do)
    }).raw = Do, (qr.geo.conicConformal = function() {
        return Kt(Te)
    }).raw = Te, (qr.geo.conicEquidistant = function() {
        return Kt(Re)
    }).raw = Re;
    var No = ye(function(t) {
        return 1 / t
    }, Math.atan);
    (qr.geo.gnomonic = function() {
        return oe(No)
    }).raw = No, xe.invert = function(t, e) {
        return [t, 2 * Math.atan(Math.exp(e)) - Hi]
    }, (qr.geo.mercator = function() {
        return be(xe)
    }).raw = xe;
    var Fo = ye(function() {
        return 1
    }, Math.asin);
    (qr.geo.orthographic = function() {
        return oe(Fo)
    }).raw = Fo;
    var Oo = ye(function(t) {
        return 1 / (1 + t)
    }, function(t) {
        return 2 * Math.atan(t)
    });
    (qr.geo.stereographic = function() {
        return oe(Oo)
    }).raw = Oo, He.invert = function(t, e) {
        return [Math.atan2(O(t), Math.cos(e)), F(Math.sin(e) / V(t))]
    }, (qr.geo.transverseMercator = function() {
        return be(He)
    }).raw = He, qr.geom = {}, qr.svg = {}, qr.svg.line = function() {
        return _e(lt)
    };
    var Vo = qr.map({
        linear: Se,
        "linear-closed": function(t) {
            return Se(t) + "Z"
        },
        step: function(t) {
            for (var e = 0, n = t.length, r = t[0], i = [r[0], ",", r[1]]; ++e < n;) i.push("H", (r[0] + (r = t[e])[0]) / 2, "V", r[1]);
            return n > 1 && i.push("H", r[0]), i.join("")
        },
        "step-before": Ae,
        "step-after": Ce,
        basis: Pe,
        "basis-open": function(t) {
            if (t.length < 4) return Se(t);
            for (var e, n = [], r = -1, i = t.length, o = [0], a = [0]; ++r < 3;) e = t[r], o.push(e[0]), a.push(e[1]);
            for (n.push(De(Io, o) + "," + De(Io, a)), --r; ++r < i;) e = t[r], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), Ne(n, o, a);
            return n.join("")
        },
        "basis-closed": function(t) {
            for (var e, n, r = -1, i = t.length, o = i + 4, a = [], s = []; ++r < 4;) n = t[r % i], a.push(n[0]), s.push(n[1]);
            for (e = [De(Io, a), ",", De(Io, s)], --r; ++r < o;) n = t[r % i], a.shift(), a.push(n[0]), s.shift(), s.push(n[1]), Ne(e, a, s);
            return e.join("")
        },
        bundle: function(t, e) {
            var n = t.length - 1;
            if (n)
                for (var r, i, o = t[0][0], a = t[0][1], s = t[n][0] - o, u = t[n][1] - a, h = -1; ++h <= n;) i = h / n, (r = t[h])[0] = e * r[0] + (1 - e) * (o + i * s), r[1] = e * r[1] + (1 - e) * (a + i * u);
            return Pe(t)
        },
        cardinal: function(t, e) {
            return t.length < 3 ? Se(t) : t[0] + Le(t, ke(t, e))
        },
        "cardinal-open": function(t, e) {
            return t.length < 4 ? Se(t) : t[1] + Le(t.slice(1, t.length - 1), ke(t, e))
        },
        "cardinal-closed": function(t, e) {
            return t.length < 3 ? Se(t) : t[0] + Le((t.push(t[0]), t), ke([t[t.length - 2]].concat(t, [t[1]]), e))
        },
        monotone: function(t) {
            return t.length < 3 ? Se(t) : t[0] + Le(t, Oe(t))
        }
    });
    Vo.forEach(function(t, e) {
        e.key = t, e.closed = /-closed$/.test(t)
    });
    var Uo = [0, 2 / 3, 1 / 3, 0],
        Bo = [0, 1 / 3, 2 / 3, 0],
        Io = [0, 1 / 6, 2 / 3, 1 / 6];
    qr.geom.hull = function(t) {
        function e(t) {
            if (t.length < 3) return [];
            var e, i, o, a, s, u, h, c, l, p, f, d, E = ct(n),
                m = ct(r),
                g = t.length,
                v = g - 1,
                y = [],
                T = [],
                R = 0;
            if (E === we && r === Me) e = t;
            else
                for (o = 0, e = []; g > o; ++o) e.push([+E.call(this, i = t[o], o), +m.call(this, i, o)]);
            for (o = 1; g > o; ++o)(e[o][1] < e[R][1] || e[o][1] == e[R][1] && e[o][0] < e[R][0]) && (R = o);
            for (o = 0; g > o; ++o) o !== R && (u = e[o][1] - e[R][1], s = e[o][0] - e[R][0], y.push({
                angle: Math.atan2(u, s),
                index: o
            }));
            for (y.sort(function(t, e) {
                    return t.angle - e.angle
                }), f = y[0].angle, p = y[0].index, l = 0, o = 1; v > o; ++o) {
                if (a = y[o].index, f == y[o].angle) {
                    if ((s = e[p][0] - e[R][0]) * s + (u = e[p][1] - e[R][1]) * u >= (h = e[a][0] - e[R][0]) * h + (c = e[a][1] - e[R][1]) * c) {
                        y[o].index = -1;
                        continue
                    }
                    y[l].index = -1
                }
                f = y[o].angle, l = o, p = a
            }
            for (T.push(R), o = 0, a = 0; 2 > o; ++a) y[a].index > -1 && (T.push(y[a].index), o++);
            for (d = T.length; v > a; ++a)
                if (!(y[a].index < 0)) {
                    for (; !Ve(T[d - 2], T[d - 1], y[a].index, e);) --d;
                    T[d++] = y[a].index
                }
            var x = [];
            for (o = d - 1; o >= 0; --o) x.push(t[T[o]]);
            return x
        }
        var n = we,
            r = Me;
        return arguments.length ? e(t) : (e.x = function(t) {
            return arguments.length ? (n = t, e) : n
        }, e.y = function(t) {
            return arguments.length ? (r = t, e) : r
        }, e)
    }, qr.geom.polygon = function(t) {
        return hi(t, zo), t
    };
    var zo = qr.geom.polygon.prototype = [];
    zo.area = function() {
        for (var t, e = -1, n = this.length, r = this[n - 1], i = 0; ++e < n;) t = r, r = this[e], i += t[1] * r[0] - t[0] * r[1];
        return .5 * i
    }, zo.centroid = function(t) {
        var e, n, r = -1,
            i = this.length,
            o = 0,
            a = 0,
            s = this[i - 1];
        for (arguments.length || (t = -1 / (6 * this.area())); ++r < i;) e = s, s = this[r], n = e[0] * s[1] - s[0] * e[1], o += (e[0] + s[0]) * n, a += (e[1] + s[1]) * n;
        return [o * t, a * t]
    }, zo.clip = function(t) {
        for (var e, n, r, i, o, a, s = Ie(t), u = -1, h = this.length - Ie(this), c = this[h - 1]; ++u < h;) {
            for (e = t.slice(), t.length = 0, i = this[u], o = e[(r = e.length - s) - 1], n = -1; ++n < r;) Ue(a = e[n], c, i) ? (Ue(o, c, i) || t.push(Be(o, a, c, i)), t.push(a)) : Ue(o, c, i) && t.push(Be(o, a, c, i)), o = a;
            s && t.push(t[0]), c = i
        }
        return t
    }, qr.geom.delaunay = function(t) {
        var e = t.map(function() {
                return []
            }),
            n = [];
        return ze(t, function(n) {
            e[n.region.l.index].push(t[n.region.r.index])
        }), e.forEach(function(e, r) {
            var i = t[r],
                o = i[0],
                a = i[1];
            e.forEach(function(t) {
                t.angle = Math.atan2(t[0] - o, t[1] - a)
            }), e.sort(function(t, e) {
                return t.angle - e.angle
            });
            for (var s = 0, u = e.length - 1; u > s; s++) n.push([i, e[s], e[s + 1]])
        }), n
    }, qr.geom.voronoi = function(t) {
        function e(t) {
            var e, o, a, s = t.map(function() {
                    return []
                }),
                u = ct(n),
                h = ct(r),
                c = t.length,
                l = 1e6;
            if (u === we && h === Me) e = t;
            else
                for (e = new Array(c), a = 0; c > a; ++a) e[a] = [+u.call(this, o = t[a], a), +h.call(this, o, a)];
            if (ze(e, function(t) {
                    var e, n, r, i, o, a;
                    1 === t.a && t.b >= 0 ? (e = t.ep.r, n = t.ep.l) : (e = t.ep.l, n = t.ep.r), 1 === t.a ? (o = e ? e.y : -l, r = t.c - t.b * o, a = n ? n.y : l, i = t.c - t.b * a) : (r = e ? e.x : -l, o = t.c - t.a * r, i = n ? n.x : l, a = t.c - t.a * i);
                    var u = [r, o],
                        h = [i, a];
                    s[t.region.l.index].push(u, h), s[t.region.r.index].push(u, h)
                }), (s = s.map(function(t, n) {
                    var r = e[n][0],
                        i = e[n][1],
                        o = t.map(function(t) {
                            return Math.atan2(t[0] - r, t[1] - i)
                        }),
                        a = qr.range(t.length).sort(function(t, e) {
                            return o[t] - o[e]
                        });
                    return a.filter(function(t, e) {
                        return !e || o[t] - o[a[e - 1]] > _i
                    }).map(function(e) {
                        return t[e]
                    })
                })).forEach(function(t, n) {
                    var r = t.length;
                    if (!r) return t.push([-l, -l], [-l, l], [l, l], [l, -l]);
                    if (!(r > 2)) {
                        var i = e[n],
                            o = t[0],
                            a = t[1],
                            s = i[0],
                            u = i[1],
                            h = o[0],
                            c = o[1],
                            p = a[0],
                            f = a[1],
                            d = Math.abs(p - h),
                            E = f - c;
                        if (Math.abs(E) < _i) {
                            var m = c > u ? -l : l;
                            t.push([-l, m], [l, m])
                        } else if (_i > d) {
                            var g = h > s ? -l : l;
                            t.push([g, -l], [g, l])
                        } else {
                            m = (h - s) * (f - c) > (p - h) * (c - u) ? l : -l;
                            var v = Math.abs(E) - d;
                            Math.abs(v) < _i ? t.push([0 > E ? m : -m, m]) : (v > 0 && (m *= -1), t.push([-l, m], [l, m]))
                        }
                    }
                }), i)
                for (a = 0; c > a; ++a) i.clip(s[a]);
            for (a = 0; c > a; ++a) s[a].point = t[a];
            return s
        }
        var n = we,
            r = Me,
            i = null;
        return arguments.length ? e(t) : (e.x = function(t) {
            return arguments.length ? (n = t, e) : n
        }, e.y = function(t) {
            return arguments.length ? (r = t, e) : r
        }, e.clipExtent = function(t) {
            if (!arguments.length) return i && [i[0], i[2]];
            if (null == t) i = null;
            else {
                var n = +t[0][0],
                    r = +t[0][1],
                    o = +t[1][0],
                    a = +t[1][1];
                i = qr.geom.polygon([
                    [n, r],
                    [n, a],
                    [o, a],
                    [o, r]
                ])
            }
            return e
        }, e.size = function(t) {
            return arguments.length ? e.clipExtent(t && [
                [0, 0], t
            ]) : i && i[2]
        }, e.links = function(t) {
            var e, i, o, a = t.map(function() {
                    return []
                }),
                s = [],
                u = ct(n),
                h = ct(r),
                c = t.length;
            if (u === we && h === Me) e = t;
            else
                for (e = new Array(c), o = 0; c > o; ++o) e[o] = [+u.call(this, i = t[o], o), +h.call(this, i, o)];
            return ze(e, function(e) {
                var n = e.region.l.index,
                    r = e.region.r.index;
                a[n][r] || (a[n][r] = a[r][n] = !0, s.push({
                    source: t[n],
                    target: t[r]
                }))
            }), s
        }, e.triangles = function(t) {
            if (n === we && r === Me) return qr.geom.delaunay(t);
            for (var e, i = new Array(u), o = ct(n), a = ct(r), s = -1, u = t.length; ++s < u;)(i[s] = [+o.call(this, e = t[s], s), +a.call(this, e, s)]).data = e;
            return qr.geom.delaunay(i).map(function(t) {
                return t.map(function(t) {
                    return t.data
                })
            })
        }, e)
    };
    var Go = {
        l: "r",
        r: "l"
    };
    qr.geom.quadtree = function(t, e, n, r, i) {
        function o(t) {
            function o(t, e, n, r, i, o, a, s) {
                if (!isNaN(n) && !isNaN(r))
                    if (t.leaf) {
                        var u = t.x,
                            c = t.y;
                        if (null != u)
                            if (Math.abs(u - n) + Math.abs(c - r) < .01) h(t, e, n, r, i, o, a, s);
                            else {
                                var l = t.point;
                                t.x = t.y = t.point = null, h(t, l, u, c, i, o, a, s), h(t, e, n, r, i, o, a, s)
                            }
                        else t.x = n, t.y = r, t.point = e
                    } else h(t, e, n, r, i, o, a, s)
            }

            function h(t, e, n, r, i, a, s, u) {
                var h = .5 * (i + s),
                    c = .5 * (a + u),
                    l = n >= h,
                    p = r >= c,
                    f = (p << 1) + l;
                t.leaf = !1, t = t.nodes[f] || (t.nodes[f] = {
                    leaf: !0,
                    nodes: [],
                    point: null,
                    x: null,
                    y: null,
                    add: function(t) {
                        o(_, t, +y(t, ++f), +T(t, f), E, m, g, v)
                    }
                }), l ? i = h : s = h, p ? a = c : u = c, o(t, e, n, r, i, a, s, u)
            }
            var c, l, p, f, d, E, m, g, v, y = ct(s),
                T = ct(u);
            if (null != e) E = e, m = n, g = r, v = i;
            else if (g = v = -(E = m = 1 / 0), l = [], p = [], d = t.length, a)
                for (f = 0; d > f; ++f)(c = t[f]).x < E && (E = c.x), c.y < m && (m = c.y), c.x > g && (g = c.x), c.y > v && (v = c.y), l.push(c.x), p.push(c.y);
            else
                for (f = 0; d > f; ++f) {
                    var R = +y(c = t[f], f),
                        x = +T(c, f);
                    E > R && (E = R), m > x && (m = x), R > g && (g = R), x > v && (v = x), l.push(R), p.push(x)
                }
            var b = g - E,
                H = v - m;
            b > H ? v = m + b : g = E + H;
            var _ = {
                leaf: !0,
                nodes: [],
                point: null,
                x: null,
                y: null,
                add: function(t) {
                    o(_, t, +y(t, ++f), +T(t, f), E, m, g, v)
                }
            };
            if (_.visit = function(t) {
                    ! function t(e, n, r, i, o, a) {
                        if (!e(n, r, i, o, a)) {
                            var s = .5 * (r + o),
                                u = .5 * (i + a),
                                h = n.nodes;
                            h[0] && t(e, h[0], r, i, s, u), h[1] && t(e, h[1], s, i, o, u), h[2] && t(e, h[2], r, u, s, a), h[3] && t(e, h[3], s, u, o, a)
                        }
                    }(t, _, E, m, g, v)
                }, f = -1, null == e) {
                for (; ++f < d;) o(_, t[f], l[f], p[f], E, m, g, v);
                --f
            } else t.forEach(_.add);
            return l = p = t = c = null, _
        }
        var a, s = we,
            u = Me;
        return (a = arguments.length) ? (s = Ge, u = je, 3 === a && (i = n, r = e, n = e = 0), o(t)) : (o.x = function(t) {
            return arguments.length ? (s = t, o) : s
        }, o.y = function(t) {
            return arguments.length ? (u = t, o) : u
        }, o.extent = function(t) {
            return arguments.length ? (null == t ? e = n = r = i = null : (e = +t[0][0], n = +t[0][1], r = +t[1][0], i = +t[1][1]), o) : null == e ? null : [
                [e, n],
                [r, i]
            ]
        }, o.size = function(t) {
            return arguments.length ? (null == t ? e = n = r = i = null : (e = n = 0, r = +t[0], i = +t[1]), o) : null == e ? null : [r - e, i - n]
        }, o)
    }, qr.interpolateRgb = We, qr.interpolateObject = Xe, qr.interpolateNumber = qe, qr.interpolateString = Ye;
    var jo = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    qr.interpolate = Ke, qr.interpolators = [function(t, e) {
        var n = typeof e;
        return ("string" === n ? zi.has(e) || /^(#|rgb\(|hsl\()/.test(e) ? We : Ye : e instanceof B ? We : "object" === n ? Array.isArray(e) ? Ze : Xe : qe)(t, e)
    }], qr.interpolateArray = Ze;
    var Wo = function() {
            return lt
        },
        Xo = qr.map({
            linear: Wo,
            poly: function(t) {
                return function(e) {
                    return Math.pow(e, t)
                }
            },
            quad: function() {
                return $e
            },
            cubic: function() {
                return tn
            },
            sin: function() {
                return nn
            },
            exp: function() {
                return rn
            },
            circle: function() {
                return on
            },
            elastic: function(t, e) {
                var n;
                return arguments.length < 2 && (e = .45), arguments.length ? n = e / bi * Math.asin(1 / t) : (t = 1, n = e / 4),
                    function(r) {
                        return 1 + t * Math.pow(2, -10 * r) * Math.sin((r - n) * bi / e)
                    }
            },
            back: function(t) {
                return t || (t = 1.70158),
                    function(e) {
                        return e * e * ((t + 1) * e - t)
                    }
            },
            bounce: function() {
                return an
            }
        }),
        qo = qr.map({ in: lt,
            out: Qe,
            "in-out": Je,
            "out-in": function(t) {
                return Je(Qe(t))
            }
        });
    qr.ease = function(t) {
        var e = t.indexOf("-"),
            n = e >= 0 ? t.substring(0, e) : t,
            r = e >= 0 ? t.substring(e + 1) : "in";
        return n = Xo.get(n) || Wo,
            function(t) {
                return function(e) {
                    return 0 >= e ? 0 : e >= 1 ? 1 : t(e)
                }
            }((r = qo.get(r) || lt)(n.apply(null, Array.prototype.slice.call(arguments, 1))))
    }, qr.interpolateHcl = function(t, e) {
        t = qr.hcl(t), e = qr.hcl(e);
        var n = t.h,
            r = t.c,
            i = t.l,
            o = e.h - n,
            a = e.c - r,
            s = e.l - i;
        return isNaN(a) && (a = 0, r = isNaN(r) ? e.c : r), isNaN(o) ? (o = 0, n = isNaN(n) ? e.h : n) : o > 180 ? o -= 360 : -180 > o && (o += 360),
            function(t) {
                return X(n + o * t, r + a * t, i + s * t) + ""
            }
    }, qr.interpolateHsl = function(t, e) {
        t = qr.hsl(t), e = qr.hsl(e);
        var n = t.h,
            r = t.s,
            i = t.l,
            o = e.h - n,
            a = e.s - r,
            s = e.l - i;
        return isNaN(a) && (a = 0, r = isNaN(r) ? e.s : r), isNaN(o) ? (o = 0, n = isNaN(n) ? e.h : n) : o > 180 ? o -= 360 : -180 > o && (o += 360),
            function(t) {
                return G(n + o * t, r + a * t, i + s * t) + ""
            }
    }, qr.interpolateLab = function(t, e) {
        t = qr.lab(t), e = qr.lab(e);
        var n = t.l,
            r = t.a,
            i = t.b,
            o = e.l - n,
            a = e.a - r,
            s = e.b - i;
        return function(t) {
            return K(n + o * t, r + a * t, i + s * t) + ""
        }
    }, qr.interpolateRound = sn, qr.transform = function(t) {
        var e = Zr.createElementNS(qr.ns.prefix.svg, "g");
        return (qr.transform = function(t) {
            if (null != t) {
                e.setAttribute("transform", t);
                var n = e.transform.baseVal.consolidate()
            }
            return new un(n ? n.matrix : Yo)
        })(t)
    }, un.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
    };
    var Yo = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    qr.interpolateTransform = ln, qr.layout = {}, qr.layout.bundle = function() {
        return function(t) {
            for (var e = [], n = -1, r = t.length; ++n < r;) e.push(dn(t[n]));
            return e
        }
    }, qr.layout.chord = function() {
        function t() {
            var t, h, l, p, f, d = {},
                E = [],
                m = qr.range(o),
                g = [];
            for (n = [], r = [], t = 0, p = -1; ++p < o;) {
                for (h = 0, f = -1; ++f < o;) h += i[p][f];
                E.push(h), g.push(qr.range(o)), t += h
            }
            for (a && m.sort(function(t, e) {
                    return a(E[t], E[e])
                }), s && g.forEach(function(t, e) {
                    t.sort(function(t, n) {
                        return s(i[e][t], i[e][n])
                    })
                }), t = (bi - c * o) / t, h = 0, p = -1; ++p < o;) {
                for (l = h, f = -1; ++f < o;) {
                    var v = m[p],
                        y = g[v][f],
                        T = i[v][y],
                        R = h,
                        x = h += T * t;
                    d[v + "-" + y] = {
                        index: v,
                        subindex: y,
                        startAngle: R,
                        endAngle: x,
                        value: T
                    }
                }
                r[v] = {
                    index: v,
                    startAngle: l,
                    endAngle: h,
                    value: (h - l) / t
                }, h += c
            }
            for (p = -1; ++p < o;)
                for (f = p - 1; ++f < o;) {
                    var b = d[p + "-" + f],
                        H = d[f + "-" + p];
                    (b.value || H.value) && n.push(b.value < H.value ? {
                        source: H,
                        target: b
                    } : {
                        source: b,
                        target: H
                    })
                }
            u && e()
        }

        function e() {
            n.sort(function(t, e) {
                return u((t.source.value + t.target.value) / 2, (e.source.value + e.target.value) / 2)
            })
        }
        var n, r, i, o, a, s, u, h = {},
            c = 0;
        return h.matrix = function(t) {
            return arguments.length ? (o = (i = t) && i.length, n = r = null, h) : i
        }, h.padding = function(t) {
            return arguments.length ? (c = t, n = r = null, h) : c
        }, h.sortGroups = function(t) {
            return arguments.length ? (a = t, n = r = null, h) : a
        }, h.sortSubgroups = function(t) {
            return arguments.length ? (s = t, n = null, h) : s
        }, h.sortChords = function(t) {
            return arguments.length ? (u = t, n && e(), h) : u
        }, h.chords = function() {
            return n || t(), n
        }, h.groups = function() {
            return r || t(), r
        }, h
    }, qr.layout.force = function() {
        function t(t) {
            return function(e, n, r, i) {
                if (e.point !== t) {
                    var o = e.cx - t.x,
                        a = e.cy - t.y,
                        s = 1 / Math.sqrt(o * o + a * a);
                    if (E > (i - n) * s) {
                        var u = e.charge * s * s;
                        return t.px -= o * u, t.py -= a * u, !0
                    }
                    if (e.point && isFinite(s)) {
                        u = e.pointCharge * s * s;
                        t.px -= o * u, t.py -= a * u
                    }
                }
                return !e.charge
            }
        }

        function e(t) {
            t.px = qr.event.x, t.py = qr.event.y, s.resume()
        }
        var n, r, i, o, a, s = {},
            u = qr.dispatch("start", "tick", "end"),
            h = [1, 1],
            c = .9,
            l = Ko,
            p = Zo,
            f = -30,
            d = .1,
            E = .8,
            m = [],
            g = [];
        return s.tick = function() {
            if ((r *= .99) < .005) return u.end({
                type: "end",
                alpha: r = 0
            }), !0;
            var e, n, s, l, p, E, v, y, T, R = m.length,
                x = g.length;
            for (n = 0; x > n; ++n) l = (s = g[n]).source, (E = (y = (p = s.target).x - l.x) * y + (T = p.y - l.y) * T) && (y *= E = r * o[n] * ((E = Math.sqrt(E)) - i[n]) / E, T *= E, p.x -= y * (v = l.weight / (p.weight + l.weight)), p.y -= T * v, l.x += y * (v = 1 - v), l.y += T * v);
            if ((v = r * d) && (y = h[0] / 2, T = h[1] / 2, n = -1, v))
                for (; ++n < R;)(s = m[n]).x += (y - s.x) * v, s.y += (T - s.y) * v;
            if (f)
                for (function t(e, n, r) {
                        var i = 0,
                            o = 0;
                        if (e.charge = 0, !e.leaf)
                            for (var a, s = e.nodes, u = s.length, h = -1; ++h < u;) null != (a = s[h]) && (t(a, n, r), e.charge += a.charge, i += a.charge * a.cx, o += a.charge * a.cy);
                        if (e.point) {
                            e.leaf || (e.point.x += Math.random() - .5, e.point.y += Math.random() - .5);
                            var c = n * r[e.point.index];
                            e.charge += e.pointCharge = c, i += c * e.point.x, o += c * e.point.y
                        }
                        e.cx = i / e.charge, e.cy = o / e.charge
                    }(e = qr.geom.quadtree(m), r, a), n = -1; ++n < R;)(s = m[n]).fixed || e.visit(t(s));
            for (n = -1; ++n < R;)(s = m[n]).fixed ? (s.x = s.px, s.y = s.py) : (s.x -= (s.px - (s.px = s.x)) * c, s.y -= (s.py - (s.py = s.y)) * c);
            u.tick({
                type: "tick",
                alpha: r
            })
        }, s.nodes = function(t) {
            return arguments.length ? (m = t, s) : m
        }, s.links = function(t) {
            return arguments.length ? (g = t, s) : g
        }, s.size = function(t) {
            return arguments.length ? (h = t, s) : h
        }, s.linkDistance = function(t) {
            return arguments.length ? (l = "function" == typeof t ? t : +t, s) : l
        }, s.distance = s.linkDistance, s.linkStrength = function(t) {
            return arguments.length ? (p = "function" == typeof t ? t : +t, s) : p
        }, s.friction = function(t) {
            return arguments.length ? (c = +t, s) : c
        }, s.charge = function(t) {
            return arguments.length ? (f = "function" == typeof t ? t : +t, s) : f
        }, s.gravity = function(t) {
            return arguments.length ? (d = +t, s) : d
        }, s.theta = function(t) {
            return arguments.length ? (E = +t, s) : E
        }, s.alpha = function(t) {
            return arguments.length ? (t = +t, r ? r = t > 0 ? t : 0 : t > 0 && (u.start({
                type: "start",
                alpha: r = t
            }), qr.timer(s.tick)), s) : r
        }, s.start = function() {
            function t(t, n) {
                for (var r, i = e(), o = -1, a = i.length; ++o < a;)
                    if (!isNaN(r = i[o][t])) return r;
                return Math.random() * n
            }

            function e() {
                if (!u) {
                    for (u = [], r = 0; d > r; ++r) u[r] = [];
                    for (r = 0; E > r; ++r) {
                        var t = g[r];
                        u[t.source.index].push(t.target), u[t.target.index].push(t.source)
                    }
                }
                return u[n]
            }
            var n, r, u, c, d = m.length,
                E = g.length,
                v = h[0],
                y = h[1];
            for (n = 0; d > n; ++n)(c = m[n]).index = n, c.weight = 0;
            for (n = 0; E > n; ++n) "number" == typeof(c = g[n]).source && (c.source = m[c.source]), "number" == typeof c.target && (c.target = m[c.target]), ++c.source.weight, ++c.target.weight;
            for (n = 0; d > n; ++n) c = m[n], isNaN(c.x) && (c.x = t("x", v)), isNaN(c.y) && (c.y = t("y", y)), isNaN(c.px) && (c.px = c.x), isNaN(c.py) && (c.py = c.y);
            if (i = [], "function" == typeof l)
                for (n = 0; E > n; ++n) i[n] = +l.call(this, g[n], n);
            else
                for (n = 0; E > n; ++n) i[n] = l;
            if (o = [], "function" == typeof p)
                for (n = 0; E > n; ++n) o[n] = +p.call(this, g[n], n);
            else
                for (n = 0; E > n; ++n) o[n] = p;
            if (a = [], "function" == typeof f)
                for (n = 0; d > n; ++n) a[n] = +f.call(this, m[n], n);
            else
                for (n = 0; d > n; ++n) a[n] = f;
            return s.resume()
        }, s.resume = function() {
            return s.alpha(.1)
        }, s.stop = function() {
            return s.alpha(0)
        }, s.drag = function() {
            return n || (n = qr.behavior.drag().origin(lt).on("dragstart.force", mn).on("drag.force", e).on("dragend.force", gn)), arguments.length ? void this.on("mouseover.force", vn).on("mouseout.force", yn).call(n) : n
        }, qr.rebind(s, u, "on")
    };
    var Ko = 20,
        Zo = 1;
    qr.layout.hierarchy = function() {
        function t(o, a, s) {
            var u = r.call(e, o, a);
            if (o.depth = a, s.push(o), u && (h = u.length)) {
                for (var h, c, l = -1, p = o.children = [], f = 0, d = a + 1; ++l < h;)(c = t(u[l], d, s)).parent = o, p.push(c), f += c.value;
                n && p.sort(n), i && (o.value = f)
            } else i && (o.value = +i.call(e, o, a) || 0);
            return o
        }

        function e(e) {
            var n = [];
            return t(e, 0, n), n
        }
        var n = bn,
            r = Rn,
            i = xn;
        return e.sort = function(t) {
            return arguments.length ? (n = t, e) : n
        }, e.children = function(t) {
            return arguments.length ? (r = t, e) : r
        }, e.value = function(t) {
            return arguments.length ? (i = t, e) : i
        }, e.revalue = function(t) {
            return function t(n, r) {
                var o = n.children,
                    a = 0;
                if (o && (s = o.length))
                    for (var s, u = -1, h = r + 1; ++u < s;) a += t(o[u], h);
                else i && (a = +i.call(e, n, r) || 0);
                return i && (n.value = a), a
            }(t, 0), t
        }, e
    }, qr.layout.partition = function() {
        function t(t, r) {
            var i = e.call(this, t, r);
            return function t(e, n, r, i) {
                var o = e.children;
                if (e.x = n, e.y = e.depth * i, e.dx = r, e.dy = i, o && (a = o.length)) {
                    var a, s, u, h = -1;
                    for (r = e.value ? r / e.value : 0; ++h < a;) t(s = o[h], n, u = s.value * r, i), n += u
                }
            }(i[0], 0, n[0], n[1] / function t(e) {
                var n = e.children,
                    r = 0;
                if (n && (i = n.length))
                    for (var i, o = -1; ++o < i;) r = Math.max(r, t(n[o]));
                return 1 + r
            }(i[0])), i
        }
        var e = qr.layout.hierarchy(),
            n = [1, 1];
        return t.size = function(e) {
            return arguments.length ? (n = e, t) : n
        }, Tn(t, e)
    }, qr.layout.pie = function() {
        function t(o) {
            var a = o.map(function(n, r) {
                    return +e.call(t, n, r)
                }),
                s = +("function" == typeof r ? r.apply(this, arguments) : r),
                u = (("function" == typeof i ? i.apply(this, arguments) : i) - s) / qr.sum(a),
                h = qr.range(o.length);
            null != n && h.sort(n === Qo ? function(t, e) {
                return a[e] - a[t]
            } : function(t, e) {
                return n(o[t], o[e])
            });
            var c = [];
            return h.forEach(function(t) {
                var e;
                c[t] = {
                    data: o[t],
                    value: e = a[t],
                    startAngle: s,
                    endAngle: s += e * u
                }
            }), c
        }
        var e = Number,
            n = Qo,
            r = 0,
            i = bi;
        return t.value = function(n) {
            return arguments.length ? (e = n, t) : e
        }, t.sort = function(e) {
            return arguments.length ? (n = e, t) : n
        }, t.startAngle = function(e) {
            return arguments.length ? (r = e, t) : r
        }, t.endAngle = function(e) {
            return arguments.length ? (i = e, t) : i
        }, t
    };
    var Qo = {};
    qr.layout.stack = function() {
        function t(s, u) {
            var h = s.map(function(n, r) {
                    return e.call(t, n, r)
                }),
                c = h.map(function(e) {
                    return e.map(function(e, n) {
                        return [o.call(t, e, n), a.call(t, e, n)]
                    })
                }),
                l = n.call(t, c, u);
            h = qr.permute(h, l), c = qr.permute(c, l);
            var p, f, d, E = r.call(t, c, u),
                m = h.length,
                g = h[0].length;
            for (f = 0; g > f; ++f)
                for (i.call(t, h[0][f], d = E[f], c[0][f][1]), p = 1; m > p; ++p) i.call(t, h[p][f], d += c[p - 1][f][1], c[p][f][1]);
            return s
        }
        var e = lt,
            n = Sn,
            r = An,
            i = Mn,
            o = _n,
            a = wn;
        return t.values = function(n) {
            return arguments.length ? (e = n, t) : e
        }, t.order = function(e) {
            return arguments.length ? (n = "function" == typeof e ? e : Jo.get(e) || Sn, t) : n
        }, t.offset = function(e) {
            return arguments.length ? (r = "function" == typeof e ? e : $o.get(e) || An, t) : r
        }, t.x = function(e) {
            return arguments.length ? (o = e, t) : o
        }, t.y = function(e) {
            return arguments.length ? (a = e, t) : a
        }, t.out = function(e) {
            return arguments.length ? (i = e, t) : i
        }, t
    };
    var Jo = qr.map({
            "inside-out": function(t) {
                var e, n, r = t.length,
                    i = t.map(Cn),
                    o = t.map(Ln),
                    a = qr.range(r).sort(function(t, e) {
                        return i[t] - i[e]
                    }),
                    s = 0,
                    u = 0,
                    h = [],
                    c = [];
                for (e = 0; r > e; ++e) n = a[e], u > s ? (s += o[n], h.push(n)) : (u += o[n], c.push(n));
                return c.reverse().concat(h)
            },
            reverse: function(t) {
                return qr.range(t.length).reverse()
            },
            default: Sn
        }),
        $o = qr.map({
            silhouette: function(t) {
                var e, n, r, i = t.length,
                    o = t[0].length,
                    a = [],
                    s = 0,
                    u = [];
                for (n = 0; o > n; ++n) {
                    for (e = 0, r = 0; i > e; e++) r += t[e][n][1];
                    r > s && (s = r), a.push(r)
                }
                for (n = 0; o > n; ++n) u[n] = (s - a[n]) / 2;
                return u
            },
            wiggle: function(t) {
                var e, n, r, i, o, a, s, u, h, c = t.length,
                    l = t[0],
                    p = l.length,
                    f = [];
                for (f[0] = u = h = 0, n = 1; p > n; ++n) {
                    for (e = 0, i = 0; c > e; ++e) i += t[e][n][1];
                    for (e = 0, o = 0, s = l[n][0] - l[n - 1][0]; c > e; ++e) {
                        for (r = 0, a = (t[e][n][1] - t[e][n - 1][1]) / (2 * s); e > r; ++r) a += (t[r][n][1] - t[r][n - 1][1]) / s;
                        o += a * t[e][n][1]
                    }
                    f[n] = u -= i ? o / i * s : 0, h > u && (h = u)
                }
                for (n = 0; p > n; ++n) f[n] -= h;
                return f
            },
            expand: function(t) {
                var e, n, r, i = t.length,
                    o = t[0].length,
                    a = 1 / i,
                    s = [];
                for (n = 0; o > n; ++n) {
                    for (e = 0, r = 0; i > e; e++) r += t[e][n][1];
                    if (r)
                        for (e = 0; i > e; e++) t[e][n][1] /= r;
                    else
                        for (e = 0; i > e; e++) t[e][n][1] = a
                }
                for (n = 0; o > n; ++n) s[n] = 0;
                return s
            },
            zero: An
        });
    qr.layout.histogram = function() {
        function t(t, o) {
            for (var a, s, u = [], h = t.map(n, this), c = r.call(this, h, o), l = i.call(this, c, h, o), p = (o = -1, h.length), f = l.length - 1, d = e ? 1 : 1 / p; ++o < f;)(a = u[o] = []).dx = l[o + 1] - (a.x = l[o]), a.y = 0;
            if (f > 0)
                for (o = -1; ++o < p;)(s = h[o]) >= c[0] && s <= c[1] && ((a = u[qr.bisect(l, s, 1, f) - 1]).y += d, a.push(t[o]));
            return u
        }
        var e = !0,
            n = Number,
            r = Nn,
            i = Pn;
        return t.value = function(e) {
            return arguments.length ? (n = e, t) : n
        }, t.range = function(e) {
            return arguments.length ? (r = ct(e), t) : r
        }, t.bins = function(e) {
            return arguments.length ? (i = "number" == typeof e ? function(t) {
                return Dn(t, e)
            } : ct(e), t) : i
        }, t.frequency = function(n) {
            return arguments.length ? (e = !!n, t) : e
        }, t
    }, qr.layout.tree = function() {
        function t(t, o) {
            function a(t, e, r) {
                if (e) {
                    for (var i, o = t, a = t, s = e, u = t.parent.children[0], h = o._tree.mod, c = a._tree.mod, l = s._tree.mod, p = u._tree.mod; s = Vn(s), o = On(o), s && o;) u = On(u), (a = Vn(a))._tree.ancestor = t, (i = s._tree.prelim + l - o._tree.prelim - h + n(s, o)) > 0 && (jn(Wn(s, t, r), t, i), h += i, c += i), l += s._tree.mod, h += o._tree.mod, p += u._tree.mod, c += a._tree.mod;
                    s && !Vn(a) && (a._tree.thread = s, a._tree.mod += l - c), o && !On(u) && (u._tree.thread = o, u._tree.mod += h - p, r = t)
                }
                return r
            }
            var s = e.call(this, t, o),
                u = s[0];
            Gn(u, function(t, e) {
                    t._tree = {
                        ancestor: t,
                        prelim: 0,
                        mod: 0,
                        change: 0,
                        shift: 0,
                        number: e ? e._tree.number + 1 : 0
                    }
                }),
                function t(e, r) {
                    var i = e.children,
                        o = e._tree;
                    if (i && (s = i.length)) {
                        for (var s, u, h, c = i[0], l = c, p = -1; ++p < s;) t(h = i[p], u), l = a(h, u, l), u = h;
                        ! function(t) {
                            for (var e, n = 0, r = 0, i = t.children, o = i.length; --o >= 0;)(e = i[o]._tree).prelim += n, e.mod += n, n += e.shift + (r += e.change)
                        }(e);
                        var f = .5 * (c._tree.prelim + h._tree.prelim);
                        r ? (o.prelim = r._tree.prelim + n(e, r), o.mod = o.prelim - f) : o.prelim = f
                    } else r && (o.prelim = r._tree.prelim + n(e, r))
                }(u),
                function t(e, n) {
                    e.x = e._tree.prelim + n;
                    var r = e.children;
                    if (r && (i = r.length)) {
                        var i, o = -1;
                        for (n += e._tree.mod; ++o < i;) t(r[o], n)
                    }
                }(u, -u._tree.prelim);
            var h = Un(u, In),
                c = Un(u, Bn),
                l = Un(u, zn),
                p = h.x - n(h, c) / 2,
                f = c.x + n(c, h) / 2,
                d = l.depth || 1;
            return Gn(u, i ? function(t) {
                t.x *= r[0], t.y = t.depth * r[1], delete t._tree
            } : function(t) {
                t.x = (t.x - p) / (f - p) * r[0], t.y = t.depth / d * r[1], delete t._tree
            }), s
        }
        var e = qr.layout.hierarchy().sort(null).value(null),
            n = Fn,
            r = [1, 1],
            i = !1;
        return t.separation = function(e) {
            return arguments.length ? (n = e, t) : n
        }, t.size = function(e) {
            return arguments.length ? (i = null == (r = e), t) : i ? null : r
        }, t.nodeSize = function(e) {
            return arguments.length ? (i = null != (r = e), t) : i ? r : null
        }, Tn(t, e)
    }, qr.layout.pack = function() {
        function t(t, o) {
            var a = n.call(this, t, o),
                s = a[0],
                u = i[0],
                h = i[1],
                c = null == e ? Math.sqrt : "function" == typeof e ? e : function() {
                    return e
                };
            if (s.x = s.y = 0, Gn(s, function(t) {
                    t.r = +c(t.value)
                }), Gn(s, Zn), r) {
                var l = r * (e ? 1 : Math.max(2 * s.r / u, 2 * s.r / h)) / 2;
                Gn(s, function(t) {
                    t.r += l
                }), Gn(s, Zn), Gn(s, function(t) {
                    t.r -= l
                })
            }
            return function t(e, n, r, i) {
                var o = e.children;
                if (e.x = n += i * e.x, e.y = r += i * e.y, e.r *= i, o)
                    for (var a = -1, s = o.length; ++a < s;) t(o[a], n, r, i)
            }(s, u / 2, h / 2, e ? 1 : 1 / Math.max(2 * s.r / u, 2 * s.r / h)), a
        }
        var e, n = qr.layout.hierarchy().sort(Xn),
            r = 0,
            i = [1, 1];
        return t.size = function(e) {
            return arguments.length ? (i = e, t) : i
        }, t.radius = function(n) {
            return arguments.length ? (e = null == n || "function" == typeof n ? n : +n, t) : e
        }, t.padding = function(e) {
            return arguments.length ? (r = +e, t) : r
        }, Tn(t, n)
    }, qr.layout.cluster = function() {
        function t(t, o) {
            var a, s = e.call(this, t, o),
                u = s[0],
                h = 0;
            Gn(u, function(t) {
                var e = t.children;
                e && e.length ? (t.x = function(t) {
                    return t.reduce(function(t, e) {
                        return t + e.x
                    }, 0) / t.length
                }(e), t.y = function(t) {
                    return 1 + qr.max(t, function(t) {
                        return t.y
                    })
                }(e)) : (t.x = a ? h += n(t, a) : 0, t.y = 0, a = t)
            });
            var c = function t(e) {
                    var n = e.children;
                    return n && n.length ? t(n[0]) : e
                }(u),
                l = function t(e) {
                    var n, r = e.children;
                    return r && (n = r.length) ? t(r[n - 1]) : e
                }(u),
                p = c.x - n(c, l) / 2,
                f = l.x + n(l, c) / 2;
            return Gn(u, i ? function(t) {
                t.x = (t.x - u.x) * r[0], t.y = (u.y - t.y) * r[1]
            } : function(t) {
                t.x = (t.x - p) / (f - p) * r[0], t.y = (1 - (u.y ? t.y / u.y : 1)) * r[1]
            }), s
        }
        var e = qr.layout.hierarchy().sort(null).value(null),
            n = Fn,
            r = [1, 1],
            i = !1;
        return t.separation = function(e) {
            return arguments.length ? (n = e, t) : n
        }, t.size = function(e) {
            return arguments.length ? (i = null == (r = e), t) : i ? null : r
        }, t.nodeSize = function(e) {
            return arguments.length ? (i = null != (r = e), t) : i ? r : null
        }, Tn(t, e)
    }, qr.layout.treemap = function() {
        function t(t, e) {
            for (var n, r, i = -1, o = t.length; ++i < o;) r = (n = t[i]).value * (0 > e ? 0 : e), n.area = isNaN(r) || 0 >= r ? 0 : r
        }

        function e(n) {
            var o = n.children;
            if (o && o.length) {
                var a, s, u, h = l(n),
                    c = [],
                    p = o.slice(),
                    d = 1 / 0,
                    E = "slice" === f ? h.dx : "dice" === f ? h.dy : "slice-dice" === f ? 1 & n.depth ? h.dy : h.dx : Math.min(h.dx, h.dy);
                for (t(p, h.dx * h.dy / n.value), c.area = 0;
                    (u = p.length) > 0;) c.push(a = p[u - 1]), c.area += a.area, "squarify" !== f || (s = r(c, E)) <= d ? (p.pop(), d = s) : (c.area -= c.pop().area, i(c, E, h, !1), E = Math.min(h.dx, h.dy), c.length = c.area = 0, d = 1 / 0);
                c.length && (i(c, E, h, !0), c.length = c.area = 0), o.forEach(e)
            }
        }

        function n(e) {
            var r = e.children;
            if (r && r.length) {
                var o, a = l(e),
                    s = r.slice(),
                    u = [];
                for (t(s, a.dx * a.dy / e.value), u.area = 0; o = s.pop();) u.push(o), u.area += o.area, null != o.z && (i(u, o.z ? a.dx : a.dy, a, !s.length), u.length = u.area = 0);
                r.forEach(n)
            }
        }

        function r(t, e) {
            for (var n, r = t.area, i = 0, o = 1 / 0, a = -1, s = t.length; ++a < s;)(n = t[a].area) && (o > n && (o = n), n > i && (i = n));
            return e *= e, (r *= r) ? Math.max(e * i * d / r, r / (e * o * d)) : 1 / 0
        }

        function i(t, e, n, r) {
            var i, o = -1,
                a = t.length,
                s = n.x,
                h = n.y,
                c = e ? u(t.area / e) : 0;
            if (e == n.dx) {
                for ((r || c > n.dy) && (c = n.dy); ++o < a;)(i = t[o]).x = s, i.y = h, i.dy = c, s += i.dx = Math.min(n.x + n.dx - s, c ? u(i.area / c) : 0);
                i.z = !0, i.dx += n.x + n.dx - s, n.y += c, n.dy -= c
            } else {
                for ((r || c > n.dx) && (c = n.dx); ++o < a;)(i = t[o]).x = s, i.y = h, i.dx = c, h += i.dy = Math.min(n.y + n.dy - h, c ? u(i.area / c) : 0);
                i.z = !1, i.dy += n.y + n.dy - h, n.x += c, n.dx -= c
            }
        }

        function o(r) {
            var i = a || s(r),
                o = i[0];
            return o.x = 0, o.y = 0, o.dx = h[0], o.dy = h[1], a && s.revalue(o), t([o], o.dx * o.dy / o.value), (a ? n : e)(o), p && (a = i), i
        }
        var a, s = qr.layout.hierarchy(),
            u = Math.round,
            h = [1, 1],
            c = null,
            l = tr,
            p = !1,
            f = "squarify",
            d = .5 * (1 + Math.sqrt(5));
        return o.size = function(t) {
            return arguments.length ? (h = t, o) : h
        }, o.padding = function(t) {
            function e(e) {
                return er(e, t)
            }
            return arguments.length ? (l = null == (c = t) ? tr : "function" == (n = typeof t) ? function(e) {
                var n = t.call(o, e, e.depth);
                return null == n ? tr(e) : er(e, "number" == typeof n ? [n, n, n, n] : n)
            } : "number" === n ? (t = [t, t, t, t], e) : e, o) : c;
            var n
        }, o.round = function(t) {
            return arguments.length ? (u = t ? Math.round : Number, o) : u != Number
        }, o.sticky = function(t) {
            return arguments.length ? (p = t, a = null, o) : p
        }, o.ratio = function(t) {
            return arguments.length ? (d = t, o) : d
        }, o.mode = function(t) {
            return arguments.length ? (f = t + "", o) : f
        }, Tn(o, s)
    }, qr.random = {
        normal: function(t, e) {
            var n = arguments.length;
            return 2 > n && (e = 1), 1 > n && (t = 0),
                function() {
                    var n, r, i;
                    do {
                        i = (n = 2 * Math.random() - 1) * n + (r = 2 * Math.random() - 1) * r
                    } while (!i || i > 1);
                    return t + e * n * Math.sqrt(-2 * Math.log(i) / i)
                }
        },
        logNormal: function() {
            var t = qr.random.normal.apply(qr, arguments);
            return function() {
                return Math.exp(t())
            }
        },
        irwinHall: function(t) {
            return function() {
                for (var e = 0, n = 0; t > n; n++) e += Math.random();
                return e / t
            }
        }
    }, qr.scale = {};
    var ta = {
        floor: lt,
        ceil: lt
    };
    qr.scale.linear = function() {
        return function t(e, n, r, i) {
            function o() {
                var t = Math.min(e.length, n.length) > 2 ? ar : ir,
                    o = i ? fn : pn;
                return s = t(e, n, o, r), u = t(n, e, o, Ke), a
            }

            function a(t) {
                return s(t)
            }
            var s, u;
            return a.invert = function(t) {
                return u(t)
            }, a.domain = function(t) {
                return arguments.length ? (e = t.map(Number), o()) : e
            }, a.range = function(t) {
                return arguments.length ? (n = t, o()) : n
            }, a.rangeRound = function(t) {
                return a.range(t).interpolate(sn)
            }, a.clamp = function(t) {
                return arguments.length ? (i = t, o()) : i
            }, a.interpolate = function(t) {
                return arguments.length ? (r = t, o()) : r
            }, a.ticks = function(t) {
                return cr(e, t)
            }, a.tickFormat = function(t, n) {
                return lr(e, t, n)
            }, a.nice = function(t) {
                return ur(e, t), o()
            }, a.copy = function() {
                return t(e, n, r, i)
            }, o()
        }([0, 1], [0, 1], Ke, !1)
    }, qr.scale.log = function() {
        return function t(e, n, r, i) {
            function o(t) {
                return (r ? Math.log(0 > t ? 0 : t) : -Math.log(t > 0 ? 0 : -t)) / Math.log(n)
            }

            function a(t) {
                return r ? Math.pow(n, t) : -Math.pow(n, -t)
            }

            function s(t) {
                return e(o(t))
            }
            return s.invert = function(t) {
                return a(e.invert(t))
            }, s.domain = function(t) {
                return arguments.length ? (r = t[0] >= 0, e.domain((i = t.map(Number)).map(o)), s) : i
            }, s.base = function(t) {
                return arguments.length ? (n = +t, e.domain(i.map(o)), s) : n
            }, s.nice = function() {
                var t = or(i.map(o), r ? Math : na);
                return e.domain(t), i = t.map(a), s
            }, s.ticks = function() {
                var t = nr(i),
                    e = [],
                    s = t[0],
                    u = t[1],
                    h = Math.floor(o(s)),
                    c = Math.ceil(o(u)),
                    l = n % 1 ? 2 : n;
                if (isFinite(c - h)) {
                    if (r) {
                        for (; c > h; h++)
                            for (var p = 1; l > p; p++) e.push(a(h) * p);
                        e.push(a(h))
                    } else
                        for (e.push(a(h)); h++ < c;)
                            for (p = l - 1; p > 0; p--) e.push(a(h) * p);
                    for (h = 0; e[h] < s; h++);
                    for (c = e.length; e[c - 1] > u; c--);
                    e = e.slice(h, c)
                }
                return e
            }, s.tickFormat = function(t, e) {
                if (!arguments.length) return ea;
                arguments.length < 2 ? e = ea : "function" != typeof e && (e = qr.format(e));
                var n, i = Math.max(.1, t / s.ticks().length),
                    u = r ? (n = 1e-12, Math.ceil) : (n = -1e-12, Math.floor);
                return function(t) {
                    return t / a(u(o(t) + n)) <= i ? e(t) : ""
                }
            }, s.copy = function() {
                return t(e.copy(), n, r, i)
            }, sr(s, e)
        }(qr.scale.linear().domain([0, 1]), 10, !0, [1, 10])
    };
    var ea = qr.format(".0e"),
        na = {
            floor: function(t) {
                return -Math.ceil(-t)
            },
            ceil: function(t) {
                return -Math.floor(-t)
            }
        };
    qr.scale.pow = function() {
        return function t(e, n, r) {
            function i(t) {
                return e(o(t))
            }
            var o = pr(n),
                a = pr(1 / n);
            return i.invert = function(t) {
                return a(e.invert(t))
            }, i.domain = function(t) {
                return arguments.length ? (e.domain((r = t.map(Number)).map(o)), i) : r
            }, i.ticks = function(t) {
                return cr(r, t)
            }, i.tickFormat = function(t, e) {
                return lr(r, t, e)
            }, i.nice = function(t) {
                return i.domain(ur(r, t))
            }, i.exponent = function(t) {
                return arguments.length ? (o = pr(n = t), a = pr(1 / n), e.domain(r.map(o)), i) : n
            }, i.copy = function() {
                return t(e.copy(), n, r)
            }, sr(i, e)
        }(qr.scale.linear(), 1, [0, 1])
    }, qr.scale.sqrt = function() {
        return qr.scale.pow().exponent(.5)
    }, qr.scale.ordinal = function() {
        return function t(e, n) {
            function i(t) {
                return s[((a.get(t) || "range" === n.t && a.set(t, e.push(t))) - 1) % s.length]
            }

            function o(t, n) {
                return qr.range(e.length).map(function(e) {
                    return t + n * e
                })
            }
            var a, s, u;
            return i.domain = function(t) {
                if (!arguments.length) return e;
                e = [], a = new r;
                for (var o, s = -1, u = t.length; ++s < u;) a.has(o = t[s]) || a.set(o, e.push(o));
                return i[n.t].apply(i, n.a)
            }, i.range = function(t) {
                return arguments.length ? (s = t, u = 0, n = {
                    t: "range",
                    a: arguments
                }, i) : s
            }, i.rangePoints = function(t, r) {
                arguments.length < 2 && (r = 0);
                var a = t[0],
                    h = t[1],
                    c = (h - a) / (Math.max(1, e.length - 1) + r);
                return s = o(e.length < 2 ? (a + h) / 2 : a + c * r / 2, c), u = 0, n = {
                    t: "rangePoints",
                    a: arguments
                }, i
            }, i.rangeBands = function(t, r, a) {
                arguments.length < 2 && (r = 0), arguments.length < 3 && (a = r);
                var h = t[1] < t[0],
                    c = t[h - 0],
                    l = (t[1 - h] - c) / (e.length - r + 2 * a);
                return s = o(c + l * a, l), h && s.reverse(), u = l * (1 - r), n = {
                    t: "rangeBands",
                    a: arguments
                }, i
            }, i.rangeRoundBands = function(t, r, a) {
                arguments.length < 2 && (r = 0), arguments.length < 3 && (a = r);
                var h = t[1] < t[0],
                    c = t[h - 0],
                    l = t[1 - h],
                    p = Math.floor((l - c) / (e.length - r + 2 * a)),
                    f = l - c - (e.length - r) * p;
                return s = o(c + Math.round(f / 2), p), h && s.reverse(), u = Math.round(p * (1 - r)), n = {
                    t: "rangeRoundBands",
                    a: arguments
                }, i
            }, i.rangeBand = function() {
                return u
            }, i.rangeExtent = function() {
                return nr(n.a[0])
            }, i.copy = function() {
                return t(e, n)
            }, i.domain(e)
        }([], {
            t: "range",
            a: [
                []
            ]
        })
    }, qr.scale.category10 = function() {
        return qr.scale.ordinal().range(ra)
    }, qr.scale.category20 = function() {
        return qr.scale.ordinal().range(ia)
    }, qr.scale.category20b = function() {
        return qr.scale.ordinal().range(oa)
    }, qr.scale.category20c = function() {
        return qr.scale.ordinal().range(aa)
    };
    var ra = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(et),
        ia = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(et),
        oa = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(et),
        aa = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(et);
    qr.scale.quantile = function() {
        return function t(e, n) {
            function r() {
                var t = 0,
                    r = n.length;
                for (o = []; ++t < r;) o[t - 1] = qr.quantile(e, t / r);
                return i
            }

            function i(t) {
                return isNaN(t = +t) ? void 0 : n[qr.bisect(o, t)]
            }
            var o;
            return i.domain = function(t) {
                return arguments.length ? (e = t.filter(function(t) {
                    return !isNaN(t)
                }).sort(qr.ascending), r()) : e
            }, i.range = function(t) {
                return arguments.length ? (n = t, r()) : n
            }, i.quantiles = function() {
                return o
            }, i.invertExtent = function(t) {
                return 0 > (t = n.indexOf(t)) ? [NaN, NaN] : [t > 0 ? o[t - 1] : e[0], t < o.length ? o[t] : e[e.length - 1]]
            }, i.copy = function() {
                return t(e, n)
            }, r()
        }([], [])
    }, qr.scale.quantize = function() {
        return function t(e, n, r) {
            function i(t) {
                return r[Math.max(0, Math.min(s, Math.floor(a * (t - e))))]
            }

            function o() {
                return a = r.length / (n - e), s = r.length - 1, i
            }
            var a, s;
            return i.domain = function(t) {
                return arguments.length ? (e = +t[0], n = +t[t.length - 1], o()) : [e, n]
            }, i.range = function(t) {
                return arguments.length ? (r = t, o()) : r
            }, i.invertExtent = function(t) {
                return [t = 0 > (t = r.indexOf(t)) ? NaN : t / a + e, t + 1 / a]
            }, i.copy = function() {
                return t(e, n, r)
            }, o()
        }(0, 1, [0, 1])
    }, qr.scale.threshold = function() {
        return function t(e, n) {
            function r(t) {
                return t >= t ? n[qr.bisect(e, t)] : void 0
            }
            return r.domain = function(t) {
                return arguments.length ? (e = t, r) : e
            }, r.range = function(t) {
                return arguments.length ? (n = t, r) : n
            }, r.invertExtent = function(t) {
                return t = n.indexOf(t), [e[t - 1], e[t]]
            }, r.copy = function() {
                return t(e, n)
            }, r
        }([.5], [0, 1])
    }, qr.scale.identity = function() {
        return function t(e) {
            function n(t) {
                return +t
            }
            return n.invert = n, n.domain = n.range = function(t) {
                return arguments.length ? (e = t.map(n), n) : e
            }, n.ticks = function(t) {
                return cr(e, t)
            }, n.tickFormat = function(t, n) {
                return lr(e, t, n)
            }, n.copy = function() {
                return t(e)
            }, n
        }([0, 1])
    }, qr.svg.arc = function() {
        function t() {
            var t = e.apply(this, arguments),
                o = n.apply(this, arguments),
                a = r.apply(this, arguments) + sa,
                s = i.apply(this, arguments) + sa,
                u = (a > s && (u = a, a = s, s = u), s - a),
                h = xi > u ? "0" : "1",
                c = Math.cos(a),
                l = Math.sin(a),
                p = Math.cos(s),
                f = Math.sin(s);
            return u >= ua ? t ? "M0," + o + "A" + o + "," + o + " 0 1,1 0," + -o + "A" + o + "," + o + " 0 1,1 0," + o + "M0," + t + "A" + t + "," + t + " 0 1,0 0," + -t + "A" + t + "," + t + " 0 1,0 0," + t + "Z" : "M0," + o + "A" + o + "," + o + " 0 1,1 0," + -o + "A" + o + "," + o + " 0 1,1 0," + o + "Z" : t ? "M" + o * c + "," + o * l + "A" + o + "," + o + " 0 " + h + ",1 " + o * p + "," + o * f + "L" + t * p + "," + t * f + "A" + t + "," + t + " 0 " + h + ",0 " + t * c + "," + t * l + "Z" : "M" + o * c + "," + o * l + "A" + o + "," + o + " 0 " + h + ",1 " + o * p + "," + o * f + "L0,0Z"
        }
        var e = fr,
            n = dr,
            r = Er,
            i = mr;
        return t.innerRadius = function(n) {
            return arguments.length ? (e = ct(n), t) : e
        }, t.outerRadius = function(e) {
            return arguments.length ? (n = ct(e), t) : n
        }, t.startAngle = function(e) {
            return arguments.length ? (r = ct(e), t) : r
        }, t.endAngle = function(e) {
            return arguments.length ? (i = ct(e), t) : i
        }, t.centroid = function() {
            var t = (e.apply(this, arguments) + n.apply(this, arguments)) / 2,
                o = (r.apply(this, arguments) + i.apply(this, arguments)) / 2 + sa;
            return [Math.cos(o) * t, Math.sin(o) * t]
        }, t
    };
    var sa = -Hi,
        ua = bi - _i;
    qr.svg.line.radial = function() {
        var t = _e(gr);
        return t.radius = t.x, delete t.x, t.angle = t.y, delete t.y, t
    }, Ae.reverse = Ce, Ce.reverse = Ae, qr.svg.area = function() {
        return vr(lt)
    }, qr.svg.area.radial = function() {
        var t = vr(gr);
        return t.radius = t.x, delete t.x, t.innerRadius = t.x0, delete t.x0, t.outerRadius = t.x1, delete t.x1, t.angle = t.y, delete t.y, t.startAngle = t.y0, delete t.y0, t.endAngle = t.y1, delete t.y1, t
    }, qr.svg.chord = function() {
        function t(t, a) {
            var s = e(this, i, t, a),
                u = e(this, o, t, a);
            return "M" + s.p0 + n(s.r, s.p1, s.a1 - s.a0) + (function(t, e) {
                return t.a0 == e.a0 && t.a1 == e.a1
            }(s, u) ? r(s.r, s.p1, s.r, s.p0) : r(s.r, s.p1, u.r, u.p0) + n(u.r, u.p1, u.a1 - u.a0) + r(u.r, u.p1, s.r, s.p0)) + "Z"
        }

        function e(t, e, n, r) {
            var i = e.call(t, n, r),
                o = a.call(t, i, r),
                h = s.call(t, i, r) + sa,
                c = u.call(t, i, r) + sa;
            return {
                r: o,
                a0: h,
                a1: c,
                p0: [o * Math.cos(h), o * Math.sin(h)],
                p1: [o * Math.cos(c), o * Math.sin(c)]
            }
        }

        function n(t, e, n) {
            return "A" + t + "," + t + " 0 " + +(n > xi) + ",1 " + e
        }

        function r(t, e, n, r) {
            return "Q 0,0 " + r
        }
        var i = ge,
            o = ve,
            a = yr,
            s = Er,
            u = mr;
        return t.radius = function(e) {
            return arguments.length ? (a = ct(e), t) : a
        }, t.source = function(e) {
            return arguments.length ? (i = ct(e), t) : i
        }, t.target = function(e) {
            return arguments.length ? (o = ct(e), t) : o
        }, t.startAngle = function(e) {
            return arguments.length ? (s = ct(e), t) : s
        }, t.endAngle = function(e) {
            return arguments.length ? (u = ct(e), t) : u
        }, t
    }, qr.svg.diagonal = function() {
        function t(t, i) {
            var o = e.call(this, t, i),
                a = n.call(this, t, i),
                s = (o.y + a.y) / 2,
                u = [o, {
                    x: o.x,
                    y: s
                }, {
                    x: a.x,
                    y: s
                }, a];
            return "M" + (u = u.map(r))[0] + "C" + u[1] + " " + u[2] + " " + u[3]
        }
        var e = ge,
            n = ve,
            r = Tr;
        return t.source = function(n) {
            return arguments.length ? (e = ct(n), t) : e
        }, t.target = function(e) {
            return arguments.length ? (n = ct(e), t) : n
        }, t.projection = function(e) {
            return arguments.length ? (r = e, t) : r
        }, t
    }, qr.svg.diagonal.radial = function() {
        var t = qr.svg.diagonal(),
            e = Tr,
            n = t.projection;
        return t.projection = function(t) {
            return arguments.length ? n(function(t) {
                return function() {
                    var e = t.apply(this, arguments),
                        n = e[0],
                        r = e[1] + sa;
                    return [n * Math.cos(r), n * Math.sin(r)]
                }
            }(e = t)) : e
        }, t
    }, qr.svg.symbol = function() {
        function t(t, r) {
            return (ha.get(e.call(this, t, r)) || br)(n.call(this, t, r))
        }
        var e = xr,
            n = Rr;
        return t.type = function(n) {
            return arguments.length ? (e = ct(n), t) : e
        }, t.size = function(e) {
            return arguments.length ? (n = ct(e), t) : n
        }, t
    };
    var ha = qr.map({
        circle: br,
        cross: function(t) {
            var e = Math.sqrt(t / 5) / 2;
            return "M" + -3 * e + "," + -e + "H" + -e + "V" + -3 * e + "H" + e + "V" + -e + "H" + 3 * e + "V" + e + "H" + e + "V" + 3 * e + "H" + -e + "V" + e + "H" + -3 * e + "Z"
        },
        diamond: function(t) {
            var e = Math.sqrt(t / (2 * fa)),
                n = e * fa;
            return "M0," + -e + "L" + n + ",0 0," + e + " " + -n + ",0Z"
        },
        square: function(t) {
            var e = Math.sqrt(t) / 2;
            return "M" + -e + "," + -e + "L" + e + "," + -e + " " + e + "," + e + " " + -e + "," + e + "Z"
        },
        "triangle-down": function(t) {
            var e = Math.sqrt(t / pa),
                n = e * pa / 2;
            return "M0," + n + "L" + e + "," + -n + " " + -e + "," + -n + "Z"
        },
        "triangle-up": function(t) {
            var e = Math.sqrt(t / pa),
                n = e * pa / 2;
            return "M0," + -n + "L" + e + "," + n + " " + -e + "," + n + "Z"
        }
    });
    qr.svg.symbolTypes = ha.keys();
    var ca, la, pa = Math.sqrt(3),
        fa = Math.tan(30 * Mi),
        da = [],
        Ea = 0;
    da.call = di.call, da.empty = di.empty, da.node = di.node, da.size = di.size, qr.transition = function(t) {
        return arguments.length ? ca ? t.transition() : t : gi.transition()
    }, qr.transition.prototype = da, da.select = function(t) {
        var e, n, r, i = this.id,
            o = [];
        t = d(t);
        for (var a = -1, s = this.length; ++a < s;) {
            o.push(e = []);
            for (var u = this[a], h = -1, c = u.length; ++h < c;)(r = u[h]) && (n = t.call(r, r.__data__, h, a)) ? ("__data__" in r && (n.__data__ = r.__data__), Mr(n, h, i, r.__transition__[i]), e.push(n)) : e.push(null)
        }
        return Hr(o, i)
    }, da.selectAll = function(t) {
        var e, n, r, i, o, a = this.id,
            s = [];
        t = E(t);
        for (var u = -1, h = this.length; ++u < h;)
            for (var c = this[u], l = -1, p = c.length; ++l < p;)
                if (r = c[l]) {
                    o = r.__transition__[a], n = t.call(r, r.__data__, l, u), s.push(e = []);
                    for (var f = -1, d = n.length; ++f < d;)(i = n[f]) && Mr(i, f, a, o), e.push(i)
                }
        return Hr(s, a)
    }, da.filter = function(t) {
        var e, n, r = [];
        "function" != typeof t && (t = _(t));
        for (var i = 0, o = this.length; o > i; i++) {
            r.push(e = []);
            for (var a, s = 0, u = (a = this[i]).length; u > s; s++)(n = a[s]) && t.call(n, n.__data__, s) && e.push(n)
        }
        return Hr(r, this.id)
    }, da.tween = function(t, e) {
        var n = this.id;
        return arguments.length < 2 ? this.node().__transition__[n].tween.get(t) : w(this, null == e ? function(e) {
            e.__transition__[n].tween.remove(t)
        } : function(r) {
            r.__transition__[n].tween.set(t, e)
        })
    }, da.attr = function(t, e) {
        function n() {
            this.removeAttribute(o)
        }

        function r() {
            this.removeAttributeNS(o.space, o.local)
        }
        if (arguments.length < 2) {
            for (e in t) this.attr(e, t[e]);
            return this
        }
        var i = "transform" == t ? ln : Ke,
            o = qr.ns.qualify(t);
        return _r(this, "attr." + t, e, o.local ? function(t) {
            return null == t ? r : (t += "", function() {
                var e, n = this.getAttributeNS(o.space, o.local);
                return n !== t && (e = i(n, t), function(t) {
                    this.setAttributeNS(o.space, o.local, e(t))
                })
            })
        } : function(t) {
            return null == t ? n : (t += "", function() {
                var e, n = this.getAttribute(o);
                return n !== t && (e = i(n, t), function(t) {
                    this.setAttribute(o, e(t))
                })
            })
        })
    }, da.attrTween = function(t, e) {
        var n = qr.ns.qualify(t);
        return this.tween("attr." + t, n.local ? function(t, r) {
            var i = e.call(this, t, r, this.getAttributeNS(n.space, n.local));
            return i && function(t) {
                this.setAttributeNS(n.space, n.local, i(t))
            }
        } : function(t, r) {
            var i = e.call(this, t, r, this.getAttribute(n));
            return i && function(t) {
                this.setAttribute(n, i(t))
            }
        })
    }, da.style = function(t, e, n) {
        function r() {
            this.style.removeProperty(t)
        }
        var i = arguments.length;
        if (3 > i) {
            if ("string" != typeof t) {
                for (n in 2 > i && (e = ""), t) this.style(n, t[n], e);
                return this
            }
            n = ""
        }
        return _r(this, "style." + t, e, function(e) {
            return null == e ? r : (e += "", function() {
                var r, i = Jr.getComputedStyle(this, null).getPropertyValue(t);
                return i !== e && (r = Ke(i, e), function(e) {
                    this.style.setProperty(t, r(e), n)
                })
            })
        })
    }, da.styleTween = function(t, e, n) {
        return arguments.length < 3 && (n = ""), this.tween("style." + t, function(r, i) {
            var o = e.call(this, r, i, Jr.getComputedStyle(this, null).getPropertyValue(t));
            return o && function(e) {
                this.style.setProperty(t, o(e), n)
            }
        })
    }, da.text = function(t) {
        return _r(this, "text", t, wr)
    }, da.remove = function() {
        return this.each("end.transition", function() {
            var t;
            this.__transition__.count < 2 && (t = this.parentNode) && t.removeChild(this)
        })
    }, da.ease = function(t) {
        var e = this.id;
        return arguments.length < 1 ? this.node().__transition__[e].ease : ("function" != typeof t && (t = qr.ease.apply(qr, arguments)), w(this, function(n) {
            n.__transition__[e].ease = t
        }))
    }, da.delay = function(t) {
        var e = this.id;
        return w(this, "function" == typeof t ? function(n, r, i) {
            n.__transition__[e].delay = +t.call(n, n.__data__, r, i)
        } : (t = +t, function(n) {
            n.__transition__[e].delay = t
        }))
    }, da.duration = function(t) {
        var e = this.id;
        return w(this, "function" == typeof t ? function(n, r, i) {
            n.__transition__[e].duration = Math.max(1, t.call(n, n.__data__, r, i))
        } : (t = Math.max(1, t), function(n) {
            n.__transition__[e].duration = t
        }))
    }, da.each = function(t, e) {
        var n = this.id;
        if (arguments.length < 2) {
            var r = la,
                i = ca;
            ca = n, w(this, function(e, r, i) {
                la = e.__transition__[n], t.call(e, e.__data__, r, i)
            }), la = r, ca = i
        } else w(this, function(r) {
            var i = r.__transition__[n];
            (i.event || (i.event = qr.dispatch("start", "end"))).on(t, e)
        });
        return this
    }, da.transition = function() {
        for (var t, e, n, r = this.id, i = ++Ea, o = [], a = 0, s = this.length; s > a; a++) {
            o.push(t = []);
            for (var u, h = 0, c = (u = this[a]).length; c > h; h++)(e = u[h]) && ((n = Object.create(e.__transition__[r])).delay += n.duration, Mr(e, h, i, n)), t.push(e)
        }
        return Hr(o, i)
    }, qr.svg.axis = function() {
        function t(t) {
            t.each(function() {
                var t, h = qr.select(this),
                    c = this.__chart__ || n,
                    l = this.__chart__ = n.copy(),
                    p = null == u ? l.ticks ? l.ticks.apply(l, s) : l.domain() : u,
                    f = null == e ? l.tickFormat ? l.tickFormat.apply(l, s) : lt : e,
                    d = h.selectAll(".tick").data(p, l),
                    E = d.enter().insert("g", ".domain").attr("class", "tick").style("opacity", _i),
                    m = qr.transition(d.exit()).style("opacity", _i).remove(),
                    g = qr.transition(d).style("opacity", 1),
                    v = rr(l),
                    y = h.selectAll(".domain").data([0]),
                    T = (y.enter().append("path").attr("class", "domain"), qr.transition(y));
                E.append("line"), E.append("text");
                var R = E.select("line"),
                    x = g.select("line"),
                    b = d.select("text").text(f),
                    H = E.select("text"),
                    _ = g.select("text");
                switch (r) {
                    case "bottom":
                        t = Sr, R.attr("y2", i), H.attr("y", Math.max(i, 0) + a), x.attr("x2", 0).attr("y2", i), _.attr("x", 0).attr("y", Math.max(i, 0) + a), b.attr("dy", ".71em").style("text-anchor", "middle"), T.attr("d", "M" + v[0] + "," + o + "V0H" + v[1] + "V" + o);
                        break;
                    case "top":
                        t = Sr, R.attr("y2", -i), H.attr("y", -(Math.max(i, 0) + a)), x.attr("x2", 0).attr("y2", -i), _.attr("x", 0).attr("y", -(Math.max(i, 0) + a)), b.attr("dy", "0em").style("text-anchor", "middle"), T.attr("d", "M" + v[0] + "," + -o + "V0H" + v[1] + "V" + -o);
                        break;
                    case "left":
                        t = Ar, R.attr("x2", -i), H.attr("x", -(Math.max(i, 0) + a)), x.attr("x2", -i).attr("y2", 0), _.attr("x", -(Math.max(i, 0) + a)).attr("y", 0), b.attr("dy", ".32em").style("text-anchor", "end"), T.attr("d", "M" + -o + "," + v[0] + "H0V" + v[1] + "H" + -o);
                        break;
                    case "right":
                        t = Ar, R.attr("x2", i), H.attr("x", Math.max(i, 0) + a), x.attr("x2", i).attr("y2", 0), _.attr("x", Math.max(i, 0) + a).attr("y", 0), b.attr("dy", ".32em").style("text-anchor", "start"), T.attr("d", "M" + o + "," + v[0] + "H0V" + v[1] + "H" + o)
                }
                if (l.rangeBand) {
                    var w = l.rangeBand() / 2,
                        M = function(t) {
                            return l(t) + w
                        };
                    E.call(t, M), g.call(t, M)
                } else E.call(t, c), g.call(t, l), m.call(t, l)
            })
        }
        var e, n = qr.scale.linear(),
            r = ma,
            i = 6,
            o = 6,
            a = 3,
            s = [10],
            u = null;
        return t.scale = function(e) {
            return arguments.length ? (n = e, t) : n
        }, t.orient = function(e) {
            return arguments.length ? (r = e in ga ? e + "" : ma, t) : r
        }, t.ticks = function() {
            return arguments.length ? (s = arguments, t) : s
        }, t.tickValues = function(e) {
            return arguments.length ? (u = e, t) : u
        }, t.tickFormat = function(n) {
            return arguments.length ? (e = n, t) : e
        }, t.tickSize = function(e) {
            var n = arguments.length;
            return n ? (i = +e, o = +arguments[n - 1], t) : i
        }, t.innerTickSize = function(e) {
            return arguments.length ? (i = +e, t) : i
        }, t.outerTickSize = function(e) {
            return arguments.length ? (o = +e, t) : o
        }, t.tickPadding = function(e) {
            return arguments.length ? (a = +e, t) : a
        }, t.tickSubdivide = function() {
            return arguments.length && t
        }, t
    };
    var ma = "bottom",
        ga = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        };
    qr.svg.brush = function() {
        function t(o) {
            o.each(function() {
                var o = qr.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", i).on("touchstart.brush", i),
                    a = o.selectAll(".background").data([0]);
                a.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"), o.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var s = o.selectAll(".resize").data(m, lt);
                s.exit().remove(), s.enter().append("g").attr("class", function(t) {
                    return "resize " + t
                }).style("cursor", function(t) {
                    return va[t]
                }).append("rect").attr("x", function(t) {
                    return /[ew]$/.test(t) ? -3 : null
                }).attr("y", function(t) {
                    return /^[ns]/.test(t) ? -3 : null
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden"), s.style("display", t.empty() ? "none" : null);
                var c, l = qr.transition(o),
                    p = qr.transition(a);
                u && (c = rr(u), p.attr("x", c[0]).attr("width", c[1] - c[0]), n(l)), h && (c = rr(h), p.attr("y", c[0]).attr("height", c[1] - c[0]), r(l)), e(l)
            })
        }

        function e(t) {
            t.selectAll(".resize").attr("transform", function(t) {
                return "translate(" + l[+/e$/.test(t)] + "," + f[+/^s/.test(t)] + ")"
            })
        }

        function n(t) {
            t.select(".extent").attr("x", l[0]), t.selectAll(".extent,.n>rect,.s>rect").attr("width", l[1] - l[0])
        }

        function r(t) {
            t.select(".extent").attr("y", f[0]), t.selectAll(".extent,.e>rect,.w>rect").attr("height", f[1] - f[0])
        }

        function i() {
            function i() {
                var t = qr.mouse(y),
                    i = !1;
                v && (t[0] += v[0], t[1] += v[1]), w || (qr.event.altKey ? (g || (g = [(l[0] + l[1]) / 2, (f[0] + f[1]) / 2]), S[0] = l[+(t[0] < g[0])], S[1] = f[+(t[1] < g[1])]) : g = null), H && p(t, u, 0) && (n(x), i = !0), _ && p(t, h, 1) && (r(x), i = !0), i && (e(x), R({
                    type: "brush",
                    mode: w ? "move" : "resize"
                }))
            }

            function p(t, e, n) {
                var r, i, s = rr(e),
                    u = s[0],
                    h = s[1],
                    c = S[n],
                    p = n ? f : l,
                    m = p[1] - p[0];
                return w && (u -= c, h -= m + c), r = (n ? E : d) ? Math.max(u, Math.min(h, t[n])) : t[n], w ? i = (r += c) + m : (g && (c = Math.max(u, Math.min(h, 2 * g[n] - r))), r > c ? (i = r, r = c) : i = c), p[0] != r || p[1] != i ? (n ? a = null : o = null, p[0] = r, p[1] = i, !0) : void 0
            }

            function m() {
                i(), x.style("pointer-events", "all").selectAll(".resize").style("display", t.empty() ? "none" : null), qr.select("body").style("cursor", null), A.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null), M(), R({
                    type: "brushend"
                })
            }
            var g, v, y = this,
                T = qr.select(qr.event.target),
                R = s.of(y, arguments),
                x = qr.select(y),
                b = T.datum(),
                H = !/^(n|s)$/.test(b) && u,
                _ = !/^(e|w)$/.test(b) && h,
                w = T.classed("extent"),
                M = k(),
                S = qr.mouse(y),
                A = qr.select(Jr).on("keydown.brush", function() {
                    32 == qr.event.keyCode && (w || (g = null, S[0] -= l[1], S[1] -= f[1], w = 2), c())
                }).on("keyup.brush", function() {
                    32 == qr.event.keyCode && 2 == w && (S[0] += l[1], S[1] += f[1], w = 0, c())
                });
            if (qr.event.changedTouches ? A.on("touchmove.brush", i).on("touchend.brush", m) : A.on("mousemove.brush", i).on("mouseup.brush", m), x.interrupt().selectAll("*").interrupt(), w) S[0] = l[0] - S[0], S[1] = f[0] - S[1];
            else if (b) {
                var C = +/w$/.test(b),
                    L = +/^n/.test(b);
                v = [l[1 - C] - S[0], f[1 - L] - S[1]], S[0] = l[C], S[1] = f[L]
            } else qr.event.altKey && (g = S.slice());
            x.style("pointer-events", "none").selectAll(".resize").style("display", null), qr.select("body").style("cursor", T.style("cursor")), R({
                type: "brushstart"
            }), i()
        }
        var o, a, s = p(t, "brushstart", "brush", "brushend"),
            u = null,
            h = null,
            l = [0, 0],
            f = [0, 0],
            d = !0,
            E = !0,
            m = ya[0];
        return t.event = function(t) {
            t.each(function() {
                var t = s.of(this, arguments),
                    e = {
                        x: l,
                        y: f,
                        i: o,
                        j: a
                    },
                    n = this.__chart__ || e;
                this.__chart__ = e, ca ? qr.select(this).transition().each("start.brush", function() {
                    o = n.i, a = n.j, l = n.x, f = n.y, t({
                        type: "brushstart"
                    })
                }).tween("brush:brush", function() {
                    var n = Ze(l, e.x),
                        r = Ze(f, e.y);
                    return o = a = null,
                        function(i) {
                            l = e.x = n(i), f = e.y = r(i), t({
                                type: "brush",
                                mode: "resize"
                            })
                        }
                }).each("end.brush", function() {
                    o = e.i, a = e.j, t({
                        type: "brush",
                        mode: "resize"
                    }), t({
                        type: "brushend"
                    })
                }) : (t({
                    type: "brushstart"
                }), t({
                    type: "brush",
                    mode: "resize"
                }), t({
                    type: "brushend"
                }))
            })
        }, t.x = function(e) {
            return arguments.length ? (m = ya[!(u = e) << 1 | !h], t) : u
        }, t.y = function(e) {
            return arguments.length ? (m = ya[!u << 1 | !(h = e)], t) : h
        }, t.clamp = function(e) {
            return arguments.length ? (u && h ? (d = !!e[0], E = !!e[1]) : u ? d = !!e : h && (E = !!e), t) : u && h ? [d, E] : u ? d : h ? E : null
        }, t.extent = function(e) {
            var n, r, i, s, c;
            return arguments.length ? (u && (n = e[0], r = e[1], h && (n = n[0], r = r[0]), o = [n, r], u.invert && (n = u(n), r = u(r)), n > r && (c = n, n = r, r = c), (n != l[0] || r != l[1]) && (l = [n, r])), h && (i = e[0], s = e[1], u && (i = i[1], s = s[1]), a = [i, s], h.invert && (i = h(i), s = h(s)), i > s && (c = i, i = s, s = c), (i != f[0] || s != f[1]) && (f = [i, s])), t) : (u && (o ? (n = o[0], r = o[1]) : (n = l[0], r = l[1], u.invert && (n = u.invert(n), r = u.invert(r)), n > r && (c = n, n = r, r = c))), h && (a ? (i = a[0], s = a[1]) : (i = f[0], s = f[1], h.invert && (i = h.invert(i), s = h.invert(s)), i > s && (c = i, i = s, s = c))), u && h ? [
                [n, i],
                [r, s]
            ] : u ? [n, r] : h && [i, s])
        }, t.clear = function() {
            return t.empty() || (l = [0, 0], f = [0, 0], o = a = null), t
        }, t.empty = function() {
            return !!u && l[0] == l[1] || !!h && f[0] == f[1]
        }, qr.rebind(t, s, "on")
    };
    var va = {
            n: "ns-resize",
            e: "ew-resize",
            s: "ns-resize",
            w: "ew-resize",
            nw: "nwse-resize",
            ne: "nesw-resize",
            se: "nwse-resize",
            sw: "nesw-resize"
        },
        ya = [
            ["n", "e", "s", "w", "nw", "ne", "se", "sw"],
            ["e", "w"],
            ["n", "s"],
            []
        ],
        Ta = qr.time = {},
        Ra = Date;
    Cr.prototype = {
        getDate: function() {
            return this._.getUTCDate()
        },
        getDay: function() {
            return this._.getUTCDay()
        },
        getFullYear: function() {
            return this._.getUTCFullYear()
        },
        getHours: function() {
            return this._.getUTCHours()
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds()
        },
        getMinutes: function() {
            return this._.getUTCMinutes()
        },
        getMonth: function() {
            return this._.getUTCMonth()
        },
        getSeconds: function() {
            return this._.getUTCSeconds()
        },
        getTime: function() {
            return this._.getTime()
        },
        getTimezoneOffset: function() {
            return 0
        },
        valueOf: function() {
            return this._.valueOf()
        },
        setDate: function() {
            xa.setUTCDate.apply(this._, arguments)
        },
        setDay: function() {
            xa.setUTCDay.apply(this._, arguments)
        },
        setFullYear: function() {
            xa.setUTCFullYear.apply(this._, arguments)
        },
        setHours: function() {
            xa.setUTCHours.apply(this._, arguments)
        },
        setMilliseconds: function() {
            xa.setUTCMilliseconds.apply(this._, arguments)
        },
        setMinutes: function() {
            xa.setUTCMinutes.apply(this._, arguments)
        },
        setMonth: function() {
            xa.setUTCMonth.apply(this._, arguments)
        },
        setSeconds: function() {
            xa.setUTCSeconds.apply(this._, arguments)
        },
        setTime: function() {
            xa.setTime.apply(this._, arguments)
        }
    };
    var xa = Date.prototype,
        ba = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        Ha = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        _a = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        wa = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    Ta.year = Lr(function(t) {
        return (t = Ta.day(t)).setMonth(0, 1), t
    }, function(t, e) {
        t.setFullYear(t.getFullYear() + e)
    }, function(t) {
        return t.getFullYear()
    }), Ta.years = Ta.year.range, Ta.years.utc = Ta.year.utc.range, Ta.day = Lr(function(t) {
        var e = new Ra(2e3, 0);
        return e.setFullYear(t.getFullYear(), t.getMonth(), t.getDate()), e
    }, function(t, e) {
        t.setDate(t.getDate() + e)
    }, function(t) {
        return t.getDate() - 1
    }), Ta.days = Ta.day.range, Ta.days.utc = Ta.day.utc.range, Ta.dayOfYear = function(t) {
        var e = Ta.year(t);
        return Math.floor((t - e - 6e4 * (t.getTimezoneOffset() - e.getTimezoneOffset())) / 864e5)
    }, ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"].forEach(function(t, e) {
        t = t.toLowerCase(), e = 7 - e;
        var n = Ta[t] = Lr(function(t) {
            return (t = Ta.day(t)).setDate(t.getDate() - (t.getDay() + e) % 7), t
        }, function(t, e) {
            t.setDate(t.getDate() + 7 * Math.floor(e))
        }, function(t) {
            var n = Ta.year(t).getDay();
            return Math.floor((Ta.dayOfYear(t) + (n + e) % 7) / 7) - (n !== e)
        });
        Ta[t + "s"] = n.range, Ta[t + "s"].utc = n.utc.range, Ta[t + "OfYear"] = function(t) {
            var n = Ta.year(t).getDay();
            return Math.floor((Ta.dayOfYear(t) + (n + e) % 7) / 7)
        }
    }), Ta.week = Ta.sunday, Ta.weeks = Ta.sunday.range, Ta.weeks.utc = Ta.sunday.utc.range, Ta.weekOfYear = Ta.sundayOfYear, Ta.format = Pr;
    var Ma = Nr(ba),
        Sa = Fr(ba),
        Aa = Nr(Ha),
        Ca = Fr(Ha),
        La = Nr(_a),
        ka = Fr(_a),
        Pa = Nr(wa),
        Da = Fr(wa),
        Na = /^%/,
        Fa = {
            "-": "",
            _: " ",
            0: "0"
        },
        Oa = {
            a: function(t) {
                return Ha[t.getDay()]
            },
            A: function(t) {
                return ba[t.getDay()]
            },
            b: function(t) {
                return wa[t.getMonth()]
            },
            B: function(t) {
                return _a[t.getMonth()]
            },
            c: Pr("%a %b %e %X %Y"),
            d: function(t, e) {
                return Or(t.getDate(), e, 2)
            },
            e: function(t, e) {
                return Or(t.getDate(), e, 2)
            },
            H: function(t, e) {
                return Or(t.getHours(), e, 2)
            },
            I: function(t, e) {
                return Or(t.getHours() % 12 || 12, e, 2)
            },
            j: function(t, e) {
                return Or(1 + Ta.dayOfYear(t), e, 3)
            },
            L: function(t, e) {
                return Or(t.getMilliseconds(), e, 3)
            },
            m: function(t, e) {
                return Or(t.getMonth() + 1, e, 2)
            },
            M: function(t, e) {
                return Or(t.getMinutes(), e, 2)
            },
            p: function(t) {
                return t.getHours() >= 12 ? "PM" : "AM"
            },
            S: function(t, e) {
                return Or(t.getSeconds(), e, 2)
            },
            U: function(t, e) {
                return Or(Ta.sundayOfYear(t), e, 2)
            },
            w: function(t) {
                return t.getDay()
            },
            W: function(t, e) {
                return Or(Ta.mondayOfYear(t), e, 2)
            },
            x: Pr("%m/%d/%Y"),
            X: Pr("%H:%M:%S"),
            y: function(t, e) {
                return Or(t.getFullYear() % 100, e, 2)
            },
            Y: function(t, e) {
                return Or(t.getFullYear() % 1e4, e, 4)
            },
            Z: function(t) {
                var e = t.getTimezoneOffset(),
                    n = e > 0 ? "-" : "+",
                    r = ~~(Math.abs(e) / 60),
                    i = Math.abs(e) % 60;
                return n + Or(r, "0", 2) + Or(i, "0", 2)
            },
            "%": function() {
                return "%"
            }
        },
        Va = {
            a: function(t, e, n) {
                Aa.lastIndex = 0;
                var r = Aa.exec(e.substring(n));
                return r ? (t.w = Ca.get(r[0].toLowerCase()), n + r[0].length) : -1
            },
            A: function(t, e, n) {
                Ma.lastIndex = 0;
                var r = Ma.exec(e.substring(n));
                return r ? (t.w = Sa.get(r[0].toLowerCase()), n + r[0].length) : -1
            },
            b: function(t, e, n) {
                Pa.lastIndex = 0;
                var r = Pa.exec(e.substring(n));
                return r ? (t.m = Da.get(r[0].toLowerCase()), n + r[0].length) : -1
            },
            B: function(t, e, n) {
                La.lastIndex = 0;
                var r = La.exec(e.substring(n));
                return r ? (t.m = ka.get(r[0].toLowerCase()), n + r[0].length) : -1
            },
            c: function(t, e, n) {
                return Dr(t, Oa.c.toString(), e, n)
            },
            d: Vr,
            e: Vr,
            H: Ur,
            I: Ur,
            j: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 3));
                return r ? (t.j = +r[0], n + r[0].length) : -1
            },
            L: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 3));
                return r ? (t.L = +r[0], n + r[0].length) : -1
            },
            m: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 2));
                return r ? (t.m = r[0] - 1, n + r[0].length) : -1
            },
            M: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 2));
                return r ? (t.M = +r[0], n + r[0].length) : -1
            },
            p: function(t, e, n) {
                var r = Ba.get(e.substring(n, n += 2).toLowerCase());
                return null == r ? -1 : (t.p = r, n)
            },
            S: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 2));
                return r ? (t.S = +r[0], n + r[0].length) : -1
            },
            U: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n));
                return r ? (t.U = +r[0], n + r[0].length) : -1
            },
            w: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 1));
                return r ? (t.w = +r[0], n + r[0].length) : -1
            },
            W: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n));
                return r ? (t.W = +r[0], n + r[0].length) : -1
            },
            x: function(t, e, n) {
                return Dr(t, Oa.x.toString(), e, n)
            },
            X: function(t, e, n) {
                return Dr(t, Oa.X.toString(), e, n)
            },
            y: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 2));
                return r ? (t.y = function(t) {
                    return t + (t > 68 ? 1900 : 2e3)
                }(+r[0]), n + r[0].length) : -1
            },
            Y: function(t, e, n) {
                Ua.lastIndex = 0;
                var r = Ua.exec(e.substring(n, n + 4));
                return r ? (t.y = +r[0], n + r[0].length) : -1
            },
            Z: function(t, e, n) {
                return /^[+-]\d{4}$/.test(e = e.substring(n, n + 5)) ? (t.Z = +e, n + 5) : -1
            },
            "%": function(t, e, n) {
                Na.lastIndex = 0;
                var r = Na.exec(e.substring(n, n + 1));
                return r ? n + r[0].length : -1
            }
        },
        Ua = /^\s*\d+/,
        Ba = qr.map({
            am: 0,
            pm: 1
        });
    Pr.utc = Br;
    var Ia = Br("%Y-%m-%dT%H:%M:%S.%LZ");
    Pr.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? Ir : Ia, Ir.parse = function(t) {
        var e = new Date(t);
        return isNaN(e) ? null : e
    }, Ir.toString = Ia.toString, Ta.second = Lr(function(t) {
        return new Ra(1e3 * Math.floor(t / 1e3))
    }, function(t, e) {
        t.setTime(t.getTime() + 1e3 * Math.floor(e))
    }, function(t) {
        return t.getSeconds()
    }), Ta.seconds = Ta.second.range, Ta.seconds.utc = Ta.second.utc.range, Ta.minute = Lr(function(t) {
        return new Ra(6e4 * Math.floor(t / 6e4))
    }, function(t, e) {
        t.setTime(t.getTime() + 6e4 * Math.floor(e))
    }, function(t) {
        return t.getMinutes()
    }), Ta.minutes = Ta.minute.range, Ta.minutes.utc = Ta.minute.utc.range, Ta.hour = Lr(function(t) {
        var e = t.getTimezoneOffset() / 60;
        return new Ra(36e5 * (Math.floor(t / 36e5 - e) + e))
    }, function(t, e) {
        t.setTime(t.getTime() + 36e5 * Math.floor(e))
    }, function(t) {
        return t.getHours()
    }), Ta.hours = Ta.hour.range, Ta.hours.utc = Ta.hour.utc.range, Ta.month = Lr(function(t) {
        return (t = Ta.day(t)).setDate(1), t
    }, function(t, e) {
        t.setMonth(t.getMonth() + e)
    }, function(t) {
        return t.getMonth()
    }), Ta.months = Ta.month.range, Ta.months.utc = Ta.month.utc.range;
    var za = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6],
        Ga = [
            [Ta.second, 1],
            [Ta.second, 5],
            [Ta.second, 15],
            [Ta.second, 30],
            [Ta.minute, 1],
            [Ta.minute, 5],
            [Ta.minute, 15],
            [Ta.minute, 30],
            [Ta.hour, 1],
            [Ta.hour, 3],
            [Ta.hour, 6],
            [Ta.hour, 12],
            [Ta.day, 1],
            [Ta.day, 2],
            [Ta.week, 1],
            [Ta.month, 1],
            [Ta.month, 3],
            [Ta.year, 1]
        ],
        ja = jr([
            [Pr("%Y"), Ut],
            [Pr("%B"), function(t) {
                return t.getMonth()
            }],
            [Pr("%b %d"), function(t) {
                return 1 != t.getDate()
            }],
            [Pr("%a %d"), function(t) {
                return t.getDay() && 1 != t.getDate()
            }],
            [Pr("%I %p"), function(t) {
                return t.getHours()
            }],
            [Pr("%I:%M"), function(t) {
                return t.getMinutes()
            }],
            [Pr(":%S"), function(t) {
                return t.getSeconds()
            }],
            [Pr(".%L"), function(t) {
                return t.getMilliseconds()
            }]
        ]);
    Ga.year = Ta.year, Ta.scale = function() {
        return zr(qr.scale.linear(), Ga, ja)
    };
    var Wa = {
            range: function(t, e, n) {
                return qr.range(+t, +e, n).map(Gr)
            }
        },
        Xa = Ga.map(function(t) {
            return [t[0].utc, t[1]]
        }),
        qa = jr([
            [Br("%Y"), Ut],
            [Br("%B"), function(t) {
                return t.getUTCMonth()
            }],
            [Br("%b %d"), function(t) {
                return 1 != t.getUTCDate()
            }],
            [Br("%a %d"), function(t) {
                return t.getUTCDay() && 1 != t.getUTCDate()
            }],
            [Br("%I %p"), function(t) {
                return t.getUTCHours()
            }],
            [Br("%I:%M"), function(t) {
                return t.getUTCMinutes()
            }],
            [Br(":%S"), function(t) {
                return t.getUTCSeconds()
            }],
            [Br(".%L"), function(t) {
                return t.getUTCMilliseconds()
            }]
        ]);
    return Xa.year = Ta.year.utc, Ta.scale.utc = function() {
        return zr(qr.scale.linear(), Xa, qa)
    }, qr.text = pt(function(t) {
        return t.responseText
    }), qr.json = function(t, e) {
        return ft(t, "application/json", Wr, e)
    }, qr.html = function(t, e) {
        return ft(t, "text/html", Xr, e)
    }, qr.xml = pt(function(t) {
        return t.responseXML
    }), qr
}(), define("d3", function() {});
var Stats = function() {
    function t(t) {
        return r.appendChild(t.dom), t
    }

    function e(t) {
        for (var e = 0; e < r.children.length; e++) r.children[e].style.display = e === t ? "block" : "none";
        n = t
    }
    var n = 0,
        r = document.createElement("div");
    r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(t) {
        t.preventDefault(), e(++n % r.children.length)
    }, !1);
    var i = (performance || Date).now(),
        o = i,
        a = 0,
        s = t(new Stats.Panel("FPS", "#0ff", "#002")),
        u = t(new Stats.Panel("MS", "#0f0", "#020"));
    if (self.performance && self.performance.memory) var h = t(new Stats.Panel("MB", "#f08", "#201"));
    return e(0), {
        REVISION: 16,
        dom: r,
        addPanel: t,
        showPanel: e,
        begin: function() {
            i = (performance || Date).now()
        },
        end: function() {
            a++;
            var t = (performance || Date).now();
            if (u.update(t - i, 200), t > o + 1e3 && (s.update(1e3 * a / (t - o), 100), o = t, a = 0, h)) {
                var e = performance.memory;
                h.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
            }
            return t
        },
        update: function() {
            i = this.end()
        },
        domElement: r,
        setMode: e
    }
};
Stats.Panel = function(t, e, n) {
    var r = 1 / 0,
        i = 0,
        o = Math.round,
        a = o(window.devicePixelRatio || 1),
        s = 80 * a,
        u = 48 * a,
        h = 3 * a,
        c = 2 * a,
        l = 3 * a,
        p = 15 * a,
        f = 74 * a,
        d = 30 * a,
        E = document.createElement("canvas");
    E.width = s, E.height = u, E.style.cssText = "width:80px;height:48px";
    var m = E.getContext("2d");
    return m.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", m.textBaseline = "top", m.fillStyle = n, m.fillRect(0, 0, s, u), m.fillStyle = e, m.fillText(t, h, c), m.fillRect(l, p, f, d), m.fillStyle = n, m.globalAlpha = .9, m.fillRect(l, p, f, d), {
        dom: E,
        update: function(u, g) {
            r = Math.min(r, u), i = Math.max(i, u), m.fillStyle = n, m.globalAlpha = 1, m.fillRect(0, 0, s, p), m.fillStyle = e, m.fillText(o(u) + " " + t + " (" + o(r) + "-" + o(i) + ")", h, c), m.drawImage(E, l + a, p, f - a, d, l, p, f - a, d), m.fillRect(l + f - a, p, a, d), m.fillStyle = n, m.globalAlpha = .9, m.fillRect(l + f - a, p, a, o((1 - u / g) * d))
        }
    }
}, "object" == typeof module && (module.exports = Stats), define("libs/stats", function() {}), define("graph/render/g9/animate", ["utils/utils", "../g9/lightUp", "d3", "libs/three", "libs/stats"], function(t, e, n) {
    "use strict";
    var r, i, o, a, s, u, h;
    new THREE.Vector2, new THREE.Clock;
    var c = function(t) {
            h.lights.forEach(function(t) {
                t.visible = !1
            }), 1 === t ? (h.lights[0].visible = !0, h.lights[1].visible = !0, h.lights[2].visible = !0) : (h.lights[3].visible = !0, h.lights[4].visible = !0)
        },
        l = null;

    function p(t) {
        "object" == typeof t && (l = t), requestAnimationFrame(p), a.render(o, i), u.update(), TWEEN.update(), l && l.renderUpdates && l.renderUpdates.length && l.renderUpdates.forEach(function(t) {
            t()
        })
    }
    return function(t) {
        ! function(t) {
            function n() {
                i.aspect = s.innerWidth() / s.innerHeight(), i.updateProjectionMatrix(), a.setSize(s.innerWidth(), s.innerHeight())
            }
            s = $(t), (i = new THREE.PerspectiveCamera(40, s.innerWidth() / s.innerHeight(), 1, 1e5)).position.z = 3e3, (a = new THREE.WebGLRenderer({
                antialias: !0,
                alpha: !0
            })).setClearColor(0, 0), a.setSize(s.innerWidth(), s.innerHeight()), a.domElement.style.position = "absolute", s.append(a.domElement), (u = new THREE.TrackballControls(i, a.domElement)).noPan = !0, u.rotateSpeed = .8, u.minDistance = 100, u.maxDistance = 15e3, o = new THREE.Scene, h = new e(o, s), (r = new Stats).domElement.style.position = "absolute", r.domElement.style.top = "0px", r.domElement.id = "stats", new THREE.AxisHelper(1e3), window.addEventListener("resize", n, !1), $(s).on("click", ".fullscreenControl", function() {
                setTimeout(n, 1e3)
            })
        }(t), this.scene = o, this.camera = i, this.renderer = a, this.renderUpdates = [], this.containerEle = s, this.controls = u, this.setScreenLighting = c, p(this)
    }
}), define("graph/render/g9/screen", [], function() {
    "use strict";
    return function(t) {
        var e = t.animate,
            n = this;
        e.controls.enabled = !1;
        var r = Date.now();
        this.isTableLoaded = !1, this.changeScreen = function(t) {
            this.OnScreenChange && "function" == typeof this.OnScreenChange && this.OnScreenChange(t)
        }, this.initScreen = function() {
            this.changeScreen(1)
        }, this.logTime = function(t, e) {
            var n = e || r;
            console.log(t + " : ", Date.now() - n)
        }, this.setCamera = function(t) {
            if (e.controls.reset(), 2 === t) {
                var n = new THREE.Vector3,
                    r = new THREE.Vector3(-2196.9444248900513, -5783.6378311519475, 4047.1373557078664),
                    i = new THREE.Vector3(.20125934594291095, .5091274844898959, .8368296602102624);
                e.controls.resetTo(n, r, i)
            }
        }, this.setZoom = function() {}, this.onFinshTableAnimation = function() {
            n.isTableLoaded = !0, e.controls.enabled = !0, t.info.switchScreen(1)
        }
    }
}), define("graph/render/g9/dal", ["utils/utils"], function(t) {
    "use strict";
    return function() {}
}), define("graph/render/g9/table", ["libs/three"], function() {
    "use strict";
    var t = function(t) {
        var e = this;
        this.app = t;
        var n = t.data;
        this.elements = n.elements, this.screen = null, this.stage = new THREE.Group;
        var r, i = [],
            o = [],
            a = [],
            s = [],
            u = new THREE.Raycaster,
            h = new THREE.Vector2(-5e3, -5e3),
            c = null;
        this.activeElement = null, this.activeNumber = 0;
        var l = [],
            p = [];
        this.subscribe = function(t) {
            l.push(t)
        }, this.subscribeClick = function(t) {
            p.push(t)
        }, this.addAtomCenterAnimation = function() {}, this.addElements = function(t, e) {
            this.screen = e;
            var n, r = e.scene,
                u = t,
                l = this,
                p = (n = new THREE.SphereGeometry(65, 20, 20), function(t, e) {
                    var r = new THREE.Mesh(n, new THREE.MeshBasicMaterial);
                    r.position.x = 140 * u[t][3] - 1330, r.position.y = -180 * u[t][4] + 900, r.position.z = 0, r.aNumber = e + 1;
                    var s = new THREE.BoxHelper(r);
                    return s.name = "boxHelper", s.material = new THREE.LineBasicMaterial({
                        color: 16777215,
                        opacity: .25,
                        transparent: !0
                    }), s.aNumber = e + 1, i.push(s), o.push(r), a.push(r.position), s
                }),
                f = function() {
                    var e = new THREE.PlaneGeometry(100, 100, 1, 1);
                    return function(n, r) {
                        var i = d(t[n], r + 1),
                            o = new THREE.Mesh(e, i);
                        return o.position.x = a[r].x, o.position.y = a[r].y, o.position.z = 0, o
                    }
                }(),
                d = function(t, e) {
                    var n = document.createElement("canvas"),
                        r = n.getContext("2d");
                    n.width = 128, n.height = 128, r.beginPath(), r.font = "Bold 64px Arial", r.fillStyle = "#fdfdfd", r.textAlign = "center", r.fillText(t[0], 64, 70), r.font = "Bold 20px Arial", r.fillText(t[1], 64, 110), r.font = "Bold 15px Arial", r.fillStyle = "#ffffff", r.fillText(t[2], 64, 125), r.font = "Bold 25px Arial", r.fillStyle = "#ffffff", r.fillText(e, 105, 20);
                    var i = new THREE.Texture(n);
                    return i.needsUpdate = !0, new THREE.MeshLambertMaterial({
                        map: i,
                        side: THREE.DoubleSide,
                        depthTest: !0,
                        transparent: !0
                    })
                };
            Object.keys(t).forEach(function(t, e) {
                var n = new THREE.Group;
                n.aNumber = t;
                var r, i, o = p(t, e),
                    a = f(t, e);
                n.add(o), n.add(a), s.push(n), n.position.setZ((r = -1e4, i = 1e4, Math.random() * (i - r + 1) + r)), l.stage.add(n)
            }), r.add(this.stage);
            var E = e.renderer.domElement;
            $(E).on("mousemove", function(t) {
                t.preventDefault();
                var e = E.getBoundingClientRect(),
                    n = e.top,
                    r = e.left,
                    i = t.clientX - r,
                    o = t.clientY - n;
                h.x = i / e.width * 2 - 1, h.y = -o / e.height * 2 + 1, h.cx = i, h.cy = o
            }), $(E).on("click", function() {
                c && l.clickElement(c)
            }), $(E).on("touchend", function(t) {
                t.preventDefault();
                var e = E.getBoundingClientRect(),
                    n = e.top,
                    r = e.left,
                    i = t.originalEvent.changedTouches[0].clientX - r,
                    o = t.originalEvent.changedTouches[0].clientY - n;
                h.x = i / e.width * 2 - 1, h.y = -o / e.height * 2 + 1, h.cx = i, h.cy = o, setTimeout(function() {
                    c && l.clickElement(c)
                }, 10)
            })
        }, this.hoverElement = function(t, e) {
            var n = this;
            t ? (this.activeElement = t, this.activeNumber = t.aNumber, document.body.style.cursor = "pointer") : (this.activeElement = null, this.activeNumber = 0, document.body.style.cursor = "default"), this.activeNumber !== c && (this.addHoverEffect(this.activeNumber), l.forEach(function(t) {
                t(n.activeNumber, e)
            }), c = this.activeNumber)
        }, this.addHoverEffect = function(t) {
            var e = Number(t);
            (i.forEach(function(t) {
                t.material.opacity = .25
            }), 0 !== e) && (i[e - 1].material.opacity = 1)
        }, this.higlightElemnts = function(t) {
            TWEEN.removeAll(), t ? (s.forEach(function(t) {
                t.traverse(function(t) {
                    t.material && "boxHelper" !== t.name && (t.material.opacity = .25)
                })
            }), t.forEach(function(t) {
                var e = s[t - 1],
                    n = e.position.z;
                new TWEEN.Tween(e.position).to({
                    z: n + 100
                }, 1500).easing(TWEEN.Easing.Exponential.Out).start(), e.traverse(function(t) {
                    if (t.material && "boxHelper" !== t.name) {
                        var e = {
                            opacity: t.material.opacity
                        };
                        new TWEEN.Tween(e).to({
                            opacity: 1
                        }, 1500).easing(TWEEN.Easing.Exponential.Out).onUpdate(function() {
                            t.material.opacity = this.opacity
                        }).start()
                    }
                })
            })) : s.forEach(function(t) {
                var e = s[t.aNumber - 1];
                new TWEEN.Tween(e.position).to({
                    z: 0
                }, 1500).easing(TWEEN.Easing.Exponential.Out).start(), t.traverse(function(t) {
                    if (t.material && "boxHelper" !== t.name) {
                        var e = {
                            opacity: t.material.opacity
                        };
                        new TWEEN.Tween(e).to({
                            opacity: 1
                        }, 1e3).easing(TWEEN.Easing.Exponential.Out).onUpdate(function() {
                            t.material.opacity = this.opacity
                        }).start()
                    }
                })
            })
        };
        var f = !1;
        this.clickElement = function(t) {
            f || (f = !0, e.hoverElement(!1), p.forEach(function(e) {
                e(t, h)
            }), f = !1)
        }, this.show = function() {
            this.stage.visible = !0, new TWEEN.Tween(this.stage.position).to({
                z: 0
            }, 2e3).easing(TWEEN.Easing.Exponential.Out).start()
        }, this.hide = function() {
            e.stage.visible = !1, e.stage.position.z = -5e3
        }, this.startTableAniamtion = function(t) {
            var e = 0;

            function n() {
                ++e == s.length && t()
            }
            s.forEach(function(t) {
                new TWEEN.Tween(t.position).to({
                    z: 0
                }, 3500).easing(TWEEN.Easing.Exponential.InOut).onComplete(n).start()
            })
        }, this.render = function() {
            u.setFromCamera(h, e.screen.camera);
            var t = u.intersectObjects(o);
            t.length > 0 && e.app.screen.isTableLoaded ? r != t[0].object && (r = t[0].object, e.hoverElement(r, h)) : (e.hoverElement(!1, h), r = null)
        }, this.renderUpdates = [this.render]
    };
    return t.prototype.addTable = function(t, e) {
        this.addElements(this.elements, t, e)
    }, t
}), define("graph/render/g9/electrons", ["libs/three", "d3"], function(t) {
    "use strict";
    var e = function(t, e) {
        this.stage = e;
        var n = this,
            r = t.electronstring,
            i = t.electronstringNotations,
            o = {},
            a = null,
            s = [null, "K", "L", "M", "N", "O", "P", "Q"];
        this.electronsUi = {}, this.electronsPos = {}, this.spin = !0, this.showShellsLabel = !1, this.shellsLabel = function(t) {
            t ? ($(".shellInfo").fadeIn(400), n.showShellsLabel = !0) : ($(".shellInfo").hide(), n.showShellsLabel = !1)
        };
        var u, h = new THREE.SphereGeometry(10, 100, 100),
            c = (new THREE.MeshLambertMaterial({
                color: "#2c9037"
            }), {
                K: 500,
                L: 900,
                M: 1400,
                N: 2e3,
                O: 2700,
                P: 3400,
                Q: 4200
            }),
            l = {
                K: .02,
                L: .022,
                M: .028,
                N: .03,
                O: .035,
                P: .04,
                Q: .045
            },
            p = (new THREE.TextureLoader).load("../templates/images/g9/electron.png"),
            f = new THREE.BufferGeometry,
            d = 0,
            E = [],
            m = new THREE.MeshBasicMaterial({
                color: "#005f0b"
            });
        this.resetVars = function() {
            o = {}, a = null, this.electronsUi = {}, this.electronsPos = {}, this.spin = !0, f = new THREE.BufferGeometry, d = 0, E = [], u = []
        }, this.getConfiguration = function() {
            return a || (a = {}, Object.keys(r).forEach(function(t) {
                var e = r[t],
                    n = e.split(" ").shift(),
                    o = e;
                n && n.indexOf("[") > -1 && (o = e.replace(n, i[n])), a[t] = o
            }), a)
        }, this.getLevelSplitConfiguration = function(t) {
            var e = {};
            return t.split(" ").forEach(function(t) {
                var n = t[0],
                    r = s[n];
                e[r] ? e[r].push(t) : e[r] = [t]
            }), e
        }, this.getLevelConfiguration = function(t) {
            var e = {};
            return t.split(" ").forEach(function(t) {
                var n = t.split(/[a-z]/),
                    r = n[0],
                    i = s[r];
                e[i] ? e[i] += Number(n[1]) : e[i] = Number(n[1])
            }), e
        }, this.getSpherePositions = function(t, e) {
            for (var n = [], r = 2 * Math.PI / t, i = 0, o = 0; o < t; o++) {
                var a = {
                    x: e * Math.cos(i),
                    y: e * Math.sin(i),
                    z: 0
                };
                n.push(a), i += r
            }
            return n
        }, this.getCurrentAngle = function(t, e) {
            var n = t,
                r = e;
            return Math.atan2(r, n)
        }, this.addUi_electrons = function(t, e) {
            this.electronsUi[t] = [];
            var n = e.length;
            d += n, E = E.concat(e);
            for (var r = 0, i = 0; r < n; r++, i += 3) {
                var o = new THREE.Mesh(h, m),
                    a = new THREE.Vector3(e[r].x, e[r].y, e[r].z);
                o.position.add(a), o.initAngle = this.getCurrentAngle(e[r].x, e[r].y), o.currentAngle = o.initAngle, this.electronsUi[t].push(o), this.stage.add(o)
            }
            this.addElectronsLevelPath(t)
        }, this.addElectronsToScreen = function() {
            var t = {
                    amplitude: {
                        type: "f",
                        value: 1
                    },
                    color: {
                        type: "c",
                        value: new THREE.Color("#fff")
                    },
                    texture: {
                        type: "t",
                        value: p
                    }
                },
                e = ["uniform float amplitude;", "attribute float size;", "attribute vec3 customColor;", "varying vec3 vColor;", "void main() {", "vColor = customColor;", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );", " gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
                n = ["uniform vec3 color;", "uniform sampler2D texture;", "varying vec3 vColor;", "void main() {", "gl_FragColor = vec4( color * vColor, 1.0 );", "gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );", "}"].join("\n"),
                r = new THREE.ShaderMaterial({
                    uniforms: t,
                    vertexShader: e,
                    fragmentShader: n,
                    blending: THREE.AdditiveBlending,
                    transparent: !0
                });
            u = new Float32Array(3 * d);
            for (var i = new Float32Array(3 * d), o = new Float32Array(d), a = new THREE.Color, s = 0, h = 0; s < d; s++, h += 3) u[h + 0] = E[s].x, u[h + 1] = E[s].y, u[h + 2] = 0, a.setStyle("#3498DB"), i[h + 0] = a.r, i[h + 1] = a.g, i[h + 2] = a.b, o[s] = 500;
            var c = new THREE.Points(f, r);
            c.sortParticles = !0, f.addAttribute("position", new THREE.BufferAttribute(u, 3)), f.addAttribute("customColor", new THREE.BufferAttribute(i, 3)), f.addAttribute("size", new THREE.BufferAttribute(o, 1)), this.stage.add(c)
        }, this.addElectronsLevelPath = function(t) {
            var e = this.getOribitalRadius(t),
                n = this.electronsUi[t].length,
                r = e * (n > 10 ? 8 : 2.5),
                i = new THREE.CircleGeometry(e, r);
            i.vertices.shift();
            for (var a = new THREE.LineBasicMaterial({
                    opacity: 1,
                    transparent: !0,
                    vertexColors: THREE.VertexColors
                }), s = i.vertices, u = [], h = s.length / n, c = d3.scale.linear().domain([0, h]).range(["#04f5ff", "#3498DB"]), l = 0, p = 0; l < s.length; l++, p++) {
                p >= h && (p = 0);
                var f = new THREE.Color(c(p));
                u.push(f)
            }
            i.colors = u, i.verticesNeedUpdate = !0;
            var d = new THREE.Line(i, a);
            o[t] = d, this.stage.add(d)
        }, this.addElectronGuidLine = function(t, e) {
            var n = e.camera,
                r = e.renderer.domElement;
            var i = new THREE.Vector3(0, 0, 0),
                o = [],
                a = [];
            return t.forEach(function(t) {
                var n = $('<div class="marker shellInfo">' + t + "</div>");
                e.containerEle.append(n), o.push({
                    level: t,
                    element: n
                });
                var r = $('<div class="line shellInfo" />');
                e.containerEle.append(r), a.push(r)
            }), this.update = function() {
                this.showShellsLabel && o.forEach(function(t, e) {
                    (i = new THREE.Vector3(c[t.level], 0, 0)).project(n), i.x = Math.round((i.x + 1) * r.width / 2), i.y = Math.round((1 - i.y) * r.height / 2), i.z = 0;
                    var o = i.x + 50,
                        s = i.y - 150;
                    t.element.css({
                            transform: "translate3d(" + o + "px, " + s + "px, 0px)"
                        }),
                        function(t, e) {
                            var n = t.x1,
                                r = t.y1,
                                i = t.x2,
                                o = t.y2,
                                a = Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)),
                                s = (n + i) / 2 - a / 2,
                                u = (r + o) / 2 - .5,
                                h = Math.atan2(r - o, n - i) * (180 / Math.PI);
                            e.css({
                                transform: "rotate(" + h + "deg)",
                                left: s + "px",
                                top: u + "px",
                                width: a + "px"
                            })
                        }({
                            x1: o,
                            y1: s + 42,
                            x2: i.x,
                            y2: i.y
                        }, a[e])
                })
            }, this
        }, this.spinElectrons = function() {
            for (var t = Object.keys(n.electronsPos), e = 0, r = 0; r < t.length; r++)
                for (var i = t[r], o = n.electronsUi[i], a = n.getOribitalRadius(i), s = l[i], h = 0; h < o.length; h++, e += 3) o[h].currentAngle = o[h].currentAngle - s, o[h].position.x = Math.cos(o[h].currentAngle) * a, o[h].position.y = Math.sin(o[h].currentAngle) * a, o[h].position.z = 0, u[e + 0] = Math.cos(o[h].currentAngle) * a, u[e + 1] = Math.sin(o[h].currentAngle) * a, u[e + 2] = 0
        }, this.spinColors = function(t, e) {
            o[t].rotation.z -= e
        }, this.getOribitalRadius = function(t) {
            return c[t]
        }, this.render = function() {
            if (n.guidlines.update(), n.spin) {
                for (var t = Object.keys(n.electronsPos), e = 0; e < t.length; e++) {
                    var r = t[e];
                    n.spinColors(r, l[r])
                }
                n.spinElectrons(), f.attributes.position.needsUpdate = !0, f.attributes.customColor.needsUpdate = !0
            }
        }, this.renderUpdates = [this.render]
    };
    return e.prototype.bhorModel = function(t, e) {
        if (t) {
            this.resetVars();
            var n = this.getConfiguration(),
                r = this.getLevelConfiguration(n[t]);
            e.atomicConfig = r;
            for (var i = Object.keys(r), o = 0; o < i.length; o++) {
                var a = i[o],
                    s = this.getOribitalRadius(a);
                this.electronsPos[a] = this.getSpherePositions(r[a], s), this.addUi_electrons(a, this.electronsPos[a])
            }
            this.addElectronsToScreen(), this.guidlines = this.addElectronGuidLine(i, e.animate), window.addEventListener("resize", this.guidlines.onResize, !1)
        } else console.log("Error loading atomic data", t)
    }, e
}), define("graph/render/g9/atom", ["../g9/electrons", "libs/three", "d3"], function(t, e) {
    "use strict";
    return function(e) {
        this.app = e, this.stage = new THREE.Group;
        var n = [],
            r = 1,
            i = {
                x: 0,
                y: 0,
                z: 0
            },
            o = e.data,
            a = [],
            s = this;
        this.protonRadius = 50, this.resetVars = function() {
            n = [], r = 1, i = {
                x: 0,
                y: 0,
                z: 0
            }, a = []
        }, this.normalizeNucleus = function(t) {
            if (0 !== r) {
                for (var e = 0; e < t.length; e++) {
                    t[e].x = t[e].x + (i.x - t[e].x) * (.1 * r), t[e].y = t[e].y + (i.y - t[e].y) * (.1 * r), t[e].z = t[e].z + (i.z - t[e].z) * (.1 * r);
                    for (var n = 0; n < t.length; n++)
                        if (e !== n) {
                            var o = t[e].radius + t[n].radius,
                                s = t[e].x - t[n].x,
                                u = t[e].y - t[n].y,
                                h = t[e].z - t[n].z,
                                c = Math.sqrt(s * s + u * u + h * h);
                            c < o && (c = (c - o) / c * .5, t[e].x -= s *= c, t[e].y -= u *= c, t[e].z -= h *= c, t[n].x += s, t[n].y += u, t[n].z += h)
                        }
                    a[e].position.x = t[e].x, a[e].position.y = t[e].y, a[e].position.z = t[e].z
                }
                r > 0 ? r -= .001 : r = 0
            }
        }, this.createNucleus = function(t) {
            n = function(t, e, n) {
                for (var r = [], i = Math.PI / 180, o = 360 / Math.sqrt(t), a = o, s = 1; s < 360; s += o)
                    for (var u = 1; u < 360; u += a) {
                        var h = {},
                            c = Math.sin(i * s) * e;
                        h.x = Math.cos(u * i) * c, h.y = Math.cos(i * s) * e, h.z = Math.sin(u * i) * c, h.radius = n, r.push(h)
                    }
                return r.length > t ? r.slice(r.length - t) : r
            }(1 == t ? t : 2 * t, 10, this.protonRadius)
        }, this.ui_addNucleus = function(t) {
            for (var e = new THREE.SphereGeometry(this.protonRadius, 20, 20), r = ["#ff6060", "#5c81d6"], i = 0; i < n.length; i++) {
                var o = new THREE.Mesh(e, new THREE.MeshLambertMaterial({
                        color: r[i % r.length]
                    })),
                    s = new THREE.Vector3(n[i].x, n[i].y, n[i].z);
                o.position.add(s), a.push(o), this.stage.add(o)
            }
            this.stage.position.x = 5e3, this.stage.position.y = 1e4, this.stage.visible = !1
        }, this.show = function() {
            this.stage.visible = !0, new TWEEN.Tween(this.stage.position).to({
                x: 0,
                y: 0
            }, 2e3).easing(TWEEN.Easing.Exponential.Out).start()
        }, this.hide = function() {
            s.stage.visible = !1, s.stage.position.z = 0, s.stage.position.x = 5e3, s.stage.position.y = 1e4
        }, this.moveTo = function(t) {
            r = 1, i.x = t.x, i.y = t.y, i.z = t.z
        };
        s = this;
        this.render = function() {
            s.normalizeNucleus(n)
        }, this.electrons = new t(o, this.stage), this.renderUpdates = [this.render].concat(this.electrons.renderUpdates), this.reset = function(t) {
            t.remove(this.stage), this.stage = new THREE.Group, this.electrons.stage = this.stage, this.resetVars()
        }, this.showNext = function() {
            s.app.atomicNumber = s.app.atomicNumber + 1, s.app.atomicNumber > 118 ? s.app.atomicNumber = 118 : s.app.setAtomScreen()
        }, this.showPrevious = function() {
            s.app.atomicNumber = s.app.atomicNumber - 1, s.app.atomicNumber < 1 ? s.app.atomicNumber = 1 : s.app.setAtomScreen()
        }, this.create = function(t, e) {
            t ? (this.reset(e), this.createNucleus(t), this.ui_addNucleus(e)) : console.log("Error loading atomic data", t)
        }
    }
}), define("graph/render/g9/info", ["utils/utils"], function(t) {
    "use strict";
    return function(t) {
        this.app = t, this.data = t.data;
        var e, n, r, i, o = this.ele = t.animate.containerEle,
            a = !1,
            s = !1;
        this.addUi = function(s) {
            e = $('                      <div class="elementInfo">                         <p class="aNumber-w">                             <span class="label">Atomic number :</span>                             <span class="prop num"></span>                         </p>                         <p class="aName-w">                             <span class="label">Name :</span>                             <span class="prop n"></span>                         </p>                         <p class="aSymbol-w">                             <span class="label">Symbol :</span>                             <span class="prop s"></span>                          </p>                         <p class="aWeight-w">                             <span class="label">Atomic weight :</span>                             <span class="prop w"></span>                         </p>                         <p class="eConfig">                             <span class="label">Electronic configuration</span>                              <span class="prop lc"></span>                         </p>                         <div class="close-icon"></div>                         <div class="goDetail-icon"><span class="explodeEff">Explore atom</span></div>                     </div>'), o.append(e);
            var u = $('<div class="levelsPath">                             <div class="levels K"></div>                             <div class="levels L"></div>                             <div class="levels M"></div>                             <div class="levels N"></div>                             <div class="levels O"></div>                             <div class="levels P"></div>                             <div class="levels Q"></div>                         </div>');
            e.find(".eConfig").append(u), n = $('<div class="infoPlanel"></div>'), r = $('<div class="elementInfoWrapper"></div>'), o.append(r), o.append(n);
            var h = s.data.tree,
                c = {};
            Object.keys(h).forEach(function(t) {
                var e = $("<div />").addClass("parent"),
                    r = $('<div class="parentName" />').text(t);
                e.append(r), Object.keys(h[t]).forEach(function(n) {
                    var r = $("<div />").addClass("childs").attr("group-name", n.replace(/ /g, "-").toLowerCase()).text(n);
                    e.append(r), c[n.replace(/ /g, "-").toLowerCase()] = h[t][n]
                }), n.append(e)
            }), $(".parent .childs").on("mouseover", function() {
                s.highlghtGroup(c[$(this).attr("group-name")])
            }), $(".parent .childs").on("mouseout", function() {
                s.highlghtGroup(0)
            }), $(e).find(".close-icon").on("click", function() {
                $(e).removeClass("active"), a = !1, s.addElemntInfo(0), r.hide()
            }), $(e).find(".goDetail-icon").on("click", function() {
                a = !1, s.addElemntInfo(0), r.hide(), t.screen.changeScreen(2), $(e).addClass("inScreen").css({
                    zIndex: 0,
                    opacity: 1,
                    transform: "translate3d(0,0,0)"
                })
            });
            var l = $('<div class="eleInfo leftArr"></div><div class="eleInfo rightArr"></div>'),
                p = '                         <div class="controls eleInfo">                             <div class="cntlrRow"><div class="onoffswitch"><input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="showShellsLabel"><label class="onoffswitch-label" for="showShellsLabel"></label></div><span>Show electrons shell info</span></div>                             <div class="cntlrRow"><div class="onoffswitch"><input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="spinElectrons" checked><label class="onoffswitch-label" for="spinElectrons"></label></div><span>Spin electrons</span></div>                         </div>';
            p = $(p), o.append(p), o.append(l);
            var f = $('<div class="eleInfo close-icon closeAtomScreen"></div>');
            o.append(f), $(f).on("click", function() {
                a = !1, s.addElemntInfo(0), r.hide(), t.screen.changeScreen(1), $(e).removeClass("active").removeClass("inScreen")
            }), $("#spinElectrons").on("change", function() {
                $(this).is(":checked") ? s.app.atom.electrons.spin = !0 : s.app.atom.electrons.spin = !1
            }), $("#showShellsLabel").on("change", function() {
                $(this).is(":checked") ? s.app.atom.electrons.shellsLabel(!0) : s.app.atom.electrons.shellsLabel(!1), $(o).find(".levels").removeClass("active")
            }), $(o).find(".leftArr").on("click", function() {
                s.app.atom.showPrevious(), s.setAtomicData(s.app.atomicNumber), s.addShellInfo(s.app.atomicNumber)
            }), $(o).find(".rightArr").on("click", function() {
                s.app.atom.showNext(), s.setAtomicData(s.app.atomicNumber), s.addShellInfo(s.app.atomicNumber)
            }), $(".g9-footer .devInfo").on("click", function() {
                $(this).toggleClass("active")
            }), $(o).on("mouseover", ".marker", function() {
                var t = $(this).text();
                $(o).find("." + t).addClass("active")
            }), $(o).on("mouseout", ".marker", function() {
                $(o).find(".levels").removeClass("active")
            }), !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) && $(o).addClass("iphoneDevice"), (i = $('<div class="androidLink">\n            <p>Please support us by downloading the Periodic Table 3D app from google play store.</p>\n                <a id="googlePlayApp" target="_blank" href=\'https://play.google.com/store/apps/details?id=com.graphoverflow.periodictable3dPro\'><img alt=\'Get it on Google Play\' src=\'https://play.google.com/intl/en_us/badges/images/generic/en_badge_web_generic.png\'/></a>\n                <div id="no-thanks">No thanks, continue to site</div></div>\n                ')).hide(), $(o).append(i), $("#no-thanks").on("click", () => {
                r.hide(), i.hide(), ga("send", "event", "button", "click", "googleplay:continuesite")
            }), $("#googlePlayApp").on("click", () => {
                ga("send", "event", "button", "click", "googleplay")
            })
        }(this), this.highlghtGroup = function(t) {
            if (t) {
                var e = [];
                if ("G" === t[0]) {
                    var n = this.data.elements;
                    Object.keys(n).forEach(function(r) {
                        t[1] === n[r][4] && e.push(Number(r))
                    })
                } else e = t;
                this.app.table.higlightElemnts(e)
            } else this.app.table.higlightElemnts(0)
        }, this.setAtomicData = function(n) {
            var r = t.atom.electrons.getConfiguration(),
                i = t.atom.electrons.getLevelConfiguration(r[n]);
            i = Object.keys(i).map(function(t) {
                return i[t]
            });
            var o = this.data.elements[n];
            e.find(".n").text(o[1]), e.find(".s").text(o[0]), e.find(".w").text(o[2]), e.find(".num").text(n), e.find(".lc").html(i.join("</br>"))
        }, this.addShellInfo = function(n) {
            var r = t.atom.electrons.getConfiguration(),
                i = t.atom.electrons.getLevelSplitConfiguration(r[n]);
            e.find(".levels").hide(), Object.keys(i).forEach(function(t) {
                e.find("." + t).text(i[t].join().split(",").join(", ")).show()
            })
        }, this.addElemntInfo = function(t, n) {
            if (!a)
                if (t) {
                    this.setAtomicData(t);
                    var r = n.cx,
                        i = n.cy,
                        s = o[0].offsetWidth,
                        u = o[0].offsetHeight;
                    r = r + 250 > s ? r - 250 : r + 50, i = i + 250 > u ? i - 250 : i + 50, e.css({
                        zIndex: 30,
                        opacity: 1,
                        transform: "translate3d(" + r + "px, " + i + "px, 0px)"
                    })
                } else e.css({
                    opacity: 0,
                    zIndex: 0
                })
        }, this.showElementInfo = function(t) {
            this.addShellInfo(t), e.addClass("active").css({
                zIndex: 30,
                opacity: 1,
                transform: "translate3d(-50%, 90%, 0)"
            }), a = !0, r.show()
        }, this.showInfoPanel = function() {
            this.app.screen.isTableLoaded && ($(".infoPlanel").fadeIn(1e3), $(".g9-footer").addClass("show"))
        }, this.hideInfoPanel = function() {
            $(".infoPlanel").fadeOut()
        }, this.switchScreen = function(t) {
            $(".line").remove(), $(".marker").remove(), 1 === t ? (this.showInfoPanel(), $(".eleInfo").hide(), o.addClass("tableScreen").removeClass("atomScreen"), s || this.showAndroidLink()) : (this.hideInfoPanel(), this.addElemntInfo(0), $(".eleInfo").show(), o.removeClass("tableScreen").addClass("atomScreen"), $(e).addClass("active").addClass("inScreen").css({
                zIndex: 0,
                opacity: 1,
                transform: "translate3d(0,0,0)"
            }), $("#spinElectrons").prop("checked", !0), $("#showShellsLabel").prop("checked", !1))
        }, this.loadingScreen = {
            remove: function() {
                $(".loader").remove()
            }
        }, this.hideAll = function() {
            this.hideInfoPanel(), this.addElemntInfo(0), $(".eleInfo").hide()
        }, this.showAndroidLink = function() {
            r.show(), i.show(), s = !0
        }
    }
}), void 0 === Date.now && (Date.now = function() {
    return (new Date).valueOf()
});
var TWEEN = TWEEN || function() {
    var t = [];
    return {
        REVISION: "14",
        getAll: function() {
            return t
        },
        removeAll: function() {
            t = []
        },
        add: function(e) {
            t.push(e)
        },
        remove: function(e) {
            var n = t.indexOf(e); - 1 !== n && t.splice(n, 1)
        },
        update: function(e) {
            if (0 === t.length) return !1;
            var n = 0;
            for (e = void 0 !== e ? e : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); n < t.length;) t[n].update(e) ? n++ : t.splice(n, 1);
            return !0
        }
    }
}();
TWEEN.Tween = function(t) {
    var e = t,
        n = {},
        r = {},
        i = {},
        o = 1e3,
        a = 0,
        s = !1,
        u = !1,
        h = !1,
        c = 0,
        l = null,
        p = TWEEN.Easing.Linear.None,
        f = TWEEN.Interpolation.Linear,
        d = [],
        E = null,
        m = !1,
        g = null,
        v = null,
        y = null;
    for (var T in t) n[T] = parseFloat(t[T], 10);
    this.to = function(t, e) {
        return void 0 !== e && (o = e), r = t, this
    }, this.start = function(t) {
        for (var o in TWEEN.add(this), u = !0, m = !1, l = void 0 !== t ? t : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(), l += c, r) {
            if (r[o] instanceof Array) {
                if (0 === r[o].length) continue;
                r[o] = [e[o]].concat(r[o])
            }
            n[o] = e[o], n[o] instanceof Array == 0 && (n[o] *= 1), i[o] = n[o] || 0
        }
        return this
    }, this.stop = function() {
        return u ? (TWEEN.remove(this), u = !1, null !== y && y.call(e), this.stopChainedTweens(), this) : this
    }, this.stopChainedTweens = function() {
        for (var t = 0, e = d.length; e > t; t++) d[t].stop()
    }, this.delay = function(t) {
        return c = t, this
    }, this.repeat = function(t) {
        return a = t, this
    }, this.yoyo = function(t) {
        return s = t, this
    }, this.easing = function(t) {
        return p = t, this
    }, this.interpolation = function(t) {
        return f = t, this
    }, this.chain = function() {
        return d = arguments, this
    }, this.onStart = function(t) {
        return E = t, this
    }, this.onUpdate = function(t) {
        return g = t, this
    }, this.onComplete = function(t) {
        return v = t, this
    }, this.onStop = function(t) {
        return y = t, this
    }, this.update = function(t) {
        var u;
        if (l > t) return !0;
        !1 === m && (null !== E && E.call(e), m = !0);
        var y = (t - l) / o,
            T = p(y = y > 1 ? 1 : y);
        for (u in r) {
            var R = n[u] || 0,
                x = r[u];
            x instanceof Array ? e[u] = f(x, T) : ("string" == typeof x && (x = R + parseFloat(x, 10)), "number" == typeof x && (e[u] = R + (x - R) * T))
        }
        if (null !== g && g.call(e, T), 1 == y) {
            if (a > 0) {
                for (u in isFinite(a) && a--, i) {
                    if ("string" == typeof r[u] && (i[u] = i[u] + parseFloat(r[u], 10)), s) {
                        var b = i[u];
                        i[u] = r[u], r[u] = b
                    }
                    n[u] = i[u]
                }
                return s && (h = !h), l = t + c, !0
            }
            null !== v && v.call(e);
            for (var H = 0, _ = d.length; _ > H; H++) d[H].start(t);
            return !1
        }
        return !0
    }
}, TWEEN.Easing = {
    Linear: {
        None: function(t) {
            return t
        }
    },
    Quadratic: {
        In: function(t) {
            return t * t
        },
        Out: function(t) {
            return t * (2 - t)
        },
        InOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
        }
    },
    Cubic: {
        In: function(t) {
            return t * t * t
        },
        Out: function(t) {
            return --t * t * t + 1
        },
        InOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
        }
    },
    Quartic: {
        In: function(t) {
            return t * t * t * t
        },
        Out: function(t) {
            return 1 - --t * t * t * t
        },
        InOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
        }
    },
    Quintic: {
        In: function(t) {
            return t * t * t * t * t
        },
        Out: function(t) {
            return --t * t * t * t * t + 1
        },
        InOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
        }
    },
    Sinusoidal: {
        In: function(t) {
            return 1 - Math.cos(t * Math.PI / 2)
        },
        Out: function(t) {
            return Math.sin(t * Math.PI / 2)
        },
        InOut: function(t) {
            return .5 * (1 - Math.cos(Math.PI * t))
        }
    },
    Exponential: {
        In: function(t) {
            return 0 === t ? 0 : Math.pow(1024, t - 1)
        },
        Out: function(t) {
            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
        },
        InOut: function(t) {
            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
        }
    },
    Circular: {
        In: function(t) {
            return 1 - Math.sqrt(1 - t * t)
        },
        Out: function(t) {
            return Math.sqrt(1 - --t * t)
        },
        InOut: function(t) {
            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        }
    },
    Elastic: {
        In: function(t) {
            var e, n = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / .4))
        },
        Out: function(t) {
            var e, n = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / .4) + 1)
        },
        InOut: function(t) {
            var e, n = .1;
            return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / .4) : n * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / .4) * .5 + 1)
        }
    },
    Back: {
        In: function(t) {
            var e = 1.70158;
            return t * t * ((e + 1) * t - e)
        },
        Out: function(t) {
            var e = 1.70158;
            return --t * t * ((e + 1) * t + e) + 1
        },
        InOut: function(t) {
            var e = 2.5949095;
            return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
        }
    },
    Bounce: {
        In: function(t) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - t)
        },
        Out: function(t) {
            return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        },
        InOut: function(t) {
            return .5 > t ? .5 * TWEEN.Easing.Bounce.In(2 * t) : .5 * TWEEN.Easing.Bounce.Out(2 * t - 1) + .5
        }
    }
}, TWEEN.Interpolation = {
    Linear: function(t, e) {
        var n = t.length - 1,
            r = n * e,
            i = Math.floor(r),
            o = TWEEN.Interpolation.Utils.Linear;
        return 0 > e ? o(t[0], t[1], r) : e > 1 ? o(t[n], t[n - 1], n - r) : o(t[i], t[i + 1 > n ? n : i + 1], r - i)
    },
    Bezier: function(t, e) {
        var n, r = 0,
            i = t.length - 1,
            o = Math.pow,
            a = TWEEN.Interpolation.Utils.Bernstein;
        for (n = 0; i >= n; n++) r += o(1 - e, i - n) * o(e, n) * t[n] * a(i, n);
        return r
    },
    CatmullRom: function(t, e) {
        var n = t.length - 1,
            r = n * e,
            i = Math.floor(r),
            o = TWEEN.Interpolation.Utils.CatmullRom;
        return t[0] === t[n] ? (0 > e && (i = Math.floor(r = n * (1 + e))), o(t[(i - 1 + n) % n], t[i], t[(i + 1) % n], t[(i + 2) % n], r - i)) : 0 > e ? t[0] - (o(t[0], t[0], t[1], t[1], -r) - t[0]) : e > 1 ? t[n] - (o(t[n], t[n], t[n - 1], t[n - 1], r - n) - t[n]) : o(t[i ? i - 1 : 0], t[i], t[i + 1 > n ? n : i + 1], t[i + 2 > n ? n : i + 2], r - i)
    },
    Utils: {
        Linear: function(t, e, n) {
            return (e - t) * n + t
        },
        Bernstein: function(t, e) {
            var n = TWEEN.Interpolation.Utils.Factorial;
            return n(t) / n(e) / n(t - e)
        },
        Factorial: function() {
            var t = [1];
            return function(e) {
                var n, r = 1;
                if (t[e]) return t[e];
                for (n = e; n > 1; n--) r *= n;
                return t[e] = r
            }
        }(),
        CatmullRom: function(t, e, n, r, i) {
            var o = .5 * (n - t),
                a = .5 * (r - e),
                s = i * i;
            return (2 * e - 2 * n + o + a) * (i * s) + (-3 * e + 3 * n - 2 * o - a) * s + o * i + e
        }
    }
}, "undefined" != typeof module && module.exports && (module.exports = TWEEN), define("libs/tween", function() {});
var App = {};
define("graph/render/g9/app", ["utils/utils", "../g9/animate", "../g9/screen", "../g9/dal", "../g9/table", "../g9/atom", "../g9/info", "d3", "libs/three", "libs/stats", "libs/tween"], function(t, e, n, r, i, o, a, s) {
    "use strict";
    return function(t, s) {
        App.animate = new e(s), App.screen = new n(App), App.data = t, App.dal = new r, App.table = new i(App), App.atom = new o(App), App.info = new a(App), App.animate.renderUpdates = [], App.atomicNumber = 38, App.atomicConfig = null, App.table.subscribe(function(t, e) {
            App.screen.isTableLoaded && App.info.addElemntInfo(t, e)
        }), App.table.subscribeClick(function(t) {
            App.screen.isTableLoaded && (App.atomicNumber = t, App.info.showElementInfo(App.atomicNumber))
        }), App.table.addTable(App.animate), App.table.hide(), App.atom.hide(), App.info.hideAll(), App.setTableScreen = function() {
            App.info.switchScreen(1), App.screen.setCamera(1), App.screen.isTableLoaded ? App.table.show() : (App.table.stage.visible = !0, App.table.stage.position.z = 0), App.atom.hide(), App.animate.renderUpdates = App.table.renderUpdates
        }, App.setAtomScreen = function() {
            App.table.hide(), App.info.switchScreen(2), App.atom.create(App.atomicNumber, App.animate.scene), App.atom.electrons.bhorModel(App.atomicNumber, App), App.atom.show(), App.screen.setCamera(2), App.screen.setZoom(App.atomicNumber), App.animate.renderUpdates = App.atom.renderUpdates, App.animate.scene.add(App.atom.stage)
        }, App.screen.OnScreenChange = function(t) {
            1 === t ? App.setTableScreen() : App.setAtomScreen(), App.animate.setScreenLighting(t)
        }, window.App = App, setTimeout(function() {
            App.info.loadingScreen.remove(), App.screen.initScreen(), App.table.startTableAniamtion(App.screen.onFinshTableAnimation)
        }, 10)
    }
}), define("graph/render/g9", ["graph/render/g9/app"], function(t) {
    return t
});