###
# @usage   整理《寿星万年历》算法，将其转化为python语言，至此应有C++, Java, Python版本各一份
# @author  mw
# @date    2016年05月31日  星期二  08:21:18 
# @param
# @return
#
###
import math;
import decimal;
import time;
class SolarTerm():
    def __init__(self):
        # ========角度变换===============
        self._rad = 180 * 3600 / math.pi; # 每弧度的角秒数
        self._RAD = 180 / math.pi; # 每弧度的角度数
        # ================日历计算===============
        self._J2000 = 2451545; # 2000年前儒略日数(2000-1-1 12:00:00格林威治平时)
        # =========黄赤交角及黄赤坐标变换===========
        self._hcjjB = [84381.448, -46.8150, -0.00059, 0.001813];# 黄赤交角系数表
        self._preceB = [0, 50287.92262, 111.24406, 0.07699, -0.23479, -0.00178, 0.00018, 0.00001];# Date黄道上的岁差p
        self._Y = 2000; 
        self._M = 1;
        self._D = 1;
        self._h = 12;
        self._m = 0;
        self._s = 0;
        self._dts = [
            # 世界时与原子时之差计算表
            # 共101项
            -4000, 108371.7, -13036.80, 392.000, 0.0000,
            -500, 17201.0, -627.82, 16.170, -0.3413,
            -150, 12200.6, -346.41, 5.403, -0.1593,
            150, 9113.8, -328.13, -1.647, 0.0377,
            500, 5707.5, -391.41, 0.915, 0.3145,
            900, 2203.4, -283.45, 13.034, -0.1778,
            1300, 490.1, -57.35,  2.085, -0.0072,
            1600, 120.0, -9.81, -1.532, 0.1403,
            1700, 10.2, -0.91, 0.510, -0.0370,
            1800, 13.4, -0.72, 0.202, -0.0193,
            1830, 7.8, -1.81, 0.416, -0.0247,
            1860, 8.3, -0.13, -0.406, 0.0292,
            1880, -5.4, 0.32, -0.183, 0.0173,
            1900, -2.3, 2.06, 0.169, -0.0135,
            1920, 21.2, 1.69, -0.304, 0.0167,
            1940, 24.2, 1.22, -0.064, 0.0031,
            1960, 33.2, 0.51, 0.231, -0.0109,
            1980, 51.0, 1.29, -0.026, 0.0032,
            2000, 64.7, -1.66, 5.224, -0.2905,
            2150, 279.4, 732.95, 429.579, 0.0158,
            6000
        ];

        RAD = self._RAD;
        rad = self._rad;

        # ===============光行差==================
        self._GXC_e = [0.016708634, -0.000042037, -0.0000001267 ]; # 离心率
        self._GXC_p = [102.93735 / RAD, 1.71946 / RAD, 0.00046 / RAD ]; # 近点
        self._GXC_l = [280.4664567 / RAD,
                 36000.76982779 / RAD,
                 0.0003032028 / RAD,
                 1 / 49931000 / RAD,
                 -1 / 153000000 / RAD ]; # 太平黄经
        self._GXC_k = 20.49552 / rad; # 光行差常数

        # ===============章动计算==================
        self._nutB = [# 章动表，共90项
            2.1824391966, -33.757045954, 0.0000362262, 3.7340E-08, -2.8793E-10,
            -171996, -1742, 92025, 89, 3.5069406862, 1256.663930738,
            0.0000105845, 6.9813E-10, -2.2815E-10, -13187, -16, 5736, -31,
            1.3375032491, 16799.418221925, -0.0000511866, 6.4626E-08,
            -5.3543E-10, -2274, -2, 977, -5, 4.3648783932, -67.514091907,
            0.0000724525, 7.4681E-08, -5.7586E-10, 2062, 2, -895, 5,
            0.0431251803, -628.301955171, 0.0000026820, 6.5935E-10, 5.5705E-11,
            -1426, 34, 54, -1, 2.3555557435, 8328.691425719, 0.0001545547,
            2.5033E-07, -1.1863E-09, 712, 1, -7, 0, 3.4638155059,
            1884.965885909, 0.0000079025, 3.8785E-11, -2.8386E-10, -517, 12,
            224, -6, 5.4382493597, 16833.175267879, -0.0000874129, 2.7285E-08,
            -2.4750E-10, -386, -4, 200, 0, 3.6930589926, 25128.109647645,
            0.0001033681, 3.1496E-07, -1.7218E-09, -301, 0, 129, -1,
            3.5500658664, 628.361975567, 0.0000132664, 1.3575E-09, -1.7245E-10,
            217, -5, -95, 3 ];

        # ==================日位置计算===================
        self._EnnT = 0; # 调用Enn前先设置EnnT时间变量

        # ==================月位置计算===================
        self._MnnT = 0; # 调用Mnn前先设置MnnT时间变量

        

        #=================以下是月球及地球运动参数表===================
        '''
        /***************************************
        * 如果用记事本查看此代码,请在"格式"菜单中去除"自动换行"
        * E10是关于地球的,格式如下:
        *    它是一个数组,每3个数看作一条记录,每条记录的3个数记为A,B,C
        *    rec=A*cos(B+C*t);  式中t是J2000起算的儒略千年数
        *    每条记录的计算结果(即rec)取和即得地球的日心黄经的周期量L0
        * E11格式如下: rec = A*cos*(B+C*t) *t,     取和后得泊松量L1
        * E12格式如下: rec = A*cos*(B+C*t) *t*t,   取和后得泊松量L2
        * E13格式如下: rec = A*cos*(B+C*t) *t*t*t, 取和后得泊松量L3
        * 最后地球的地心黄经:L = L0+L1+L2+L3+...
        * E20,E21,E22,E23...用于计算黄纬
        * M10,M11等是关于月球的,参数的用法请阅读Mnn()函数
        *****************************************/
        '''
        #names = ['E10', 'E11', 'E12', 'E13', 'E14', 'E15', 'E20', 'E21', 'E30', 'E31', 'E32', 'E33'];
        #E10：180项， E11：60项， E12：30项， E13：9项， E14：9项， E15：3项，
        #E20：30项， E21：6项，
        #E30：24项， E31：9项， E32：3项， E33：3项，
        #地球运动VSOP87参数
        self._E10 = [ #黄经周期项
        1.75347045673, 0.00000000000,     0.0000000000,  0.03341656456, 4.66925680417,  6283.0758499914,  0.00034894275, 4.62610241759, 12566.1516999828,  0.00003417571, 2.82886579606,     3.5231183490,
        0.00003497056, 2.74411800971,  5753.3848848968,  0.00003135896, 3.62767041758, 77713.7714681205,  0.00002676218, 4.41808351397,  7860.4193924392,  0.00002342687, 6.13516237631,  3930.2096962196,
        0.00001273166, 2.03709655772,   529.6909650946,  0.00001324292, 0.74246356352, 11506.7697697936,  0.00000901855, 2.04505443513,    26.2983197998,  0.00001199167, 1.10962944315,  1577.3435424478,
        0.00000857223, 3.50849156957,   398.1490034082,  0.00000779786, 1.17882652114,  5223.6939198022,  0.00000990250, 5.23268129594,  5884.9268465832,  0.00000753141, 2.53339053818,  5507.5532386674,
        0.00000505264, 4.58292563052, 18849.2275499742,  0.00000492379, 4.20506639861,   775.5226113240,  0.00000356655, 2.91954116867,     0.0673103028,  0.00000284125, 1.89869034186,   796.2980068164,
        0.00000242810, 0.34481140906,  5486.7778431750,  0.00000317087, 5.84901952218, 11790.6290886588,  0.00000271039, 0.31488607649, 10977.0788046990,  0.00000206160, 4.80646606059,  2544.3144198834,
        0.00000205385, 1.86947813692,  5573.1428014331,  0.00000202261, 2.45767795458,  6069.7767545534,  0.00000126184, 1.08302630210,    20.7753954924,  0.00000155516, 0.83306073807,   213.2990954380,
        0.00000115132, 0.64544911683,     0.9803210682,  0.00000102851, 0.63599846727,  4694.0029547076,  0.00000101724, 4.26679821365,     7.1135470008,  0.00000099206, 6.20992940258,  2146.1654164752,
        0.00000132212, 3.41118275555,  2942.4634232916,  0.00000097607, 0.68101272270,   155.4203994342,  0.00000085128, 1.29870743025,  6275.9623029906,  0.00000074651, 1.75508916159,  5088.6288397668,
        0.00000101895, 0.97569221824, 15720.8387848784,  0.00000084711, 3.67080093025, 71430.6956181291,  0.00000073547, 4.67926565481,   801.8209311238,  0.00000073874, 3.50319443167,  3154.6870848956,
        0.00000078756, 3.03698313141, 12036.4607348882,  0.00000079637, 1.80791330700, 17260.1546546904,  0.00000085803, 5.98322631256,161000.6857376741,  0.00000056963, 2.78430398043,  6286.5989683404,
        0.00000061148, 1.81839811024,  7084.8967811152,  0.00000069627, 0.83297596966,  9437.7629348870,  0.00000056116, 4.38694880779, 14143.4952424306,  0.00000062449, 3.97763880587,  8827.3902698748,
        0.00000051145, 0.28306864501,  5856.4776591154,  0.00000055577, 3.47006009062,  6279.5527316424,  0.00000041036, 5.36817351402,  8429.2412664666,  0.00000051605, 1.33282746983,  1748.0164130670,
        0.00000051992, 0.18914945834, 12139.5535091068,  0.00000049000, 0.48735065033,  1194.4470102246,  0.00000039200, 6.16832995016, 10447.3878396044,  0.00000035566, 1.77597314691,  6812.7668150860,
        0.00000036770, 6.04133859347, 10213.2855462110,  0.00000036596, 2.56955238628,  1059.3819301892,  0.00000033291, 0.59309499459, 17789.8456197850,  0.00000035954, 1.70876111898,  2352.8661537718];
        self._E11 = [ #黄经泊松1项
        6283.31966747491,0.00000000000,     0.0000000000,  0.00206058863, 2.67823455584,  6283.0758499914,  0.00004303430, 2.63512650414, 12566.1516999828,  0.00000425264, 1.59046980729,     3.5231183490,
        0.00000108977, 2.96618001993,  1577.3435424478,  0.00000093478, 2.59212835365, 18849.2275499742,  0.00000119261, 5.79557487799,    26.2983197998,  0.00000072122, 1.13846158196,   529.6909650946,
        0.00000067768, 1.87472304791,   398.1490034082,  0.00000067327, 4.40918235168,  5507.5532386674,  0.00000059027, 2.88797038460,  5223.6939198022,  0.00000055976, 2.17471680261,   155.4203994342,
        0.00000045407, 0.39803079805,   796.2980068164,  0.00000036369, 0.46624739835,   775.5226113240,  0.00000028958, 2.64707383882,     7.1135470008,  0.00000019097, 1.84628332577,  5486.7778431750,
        0.00000020844, 5.34138275149,     0.9803210682,  0.00000018508, 4.96855124577,   213.2990954380,  0.00000016233, 0.03216483047,  2544.3144198834,  0.00000017293, 2.99116864949,  6275.9623029906];
        self._E12 = [ #黄经泊松2项
        0.00052918870, 0.00000000000,     0.0000000000,  0.00008719837, 1.07209665242,  6283.0758499914,  0.00000309125, 0.86728818832, 12566.1516999828,  0.00000027339, 0.05297871691,     3.5231183490,
        0.00000016334, 5.18826691036,    26.2983197998,  0.00000015752, 3.68457889430,   155.4203994342,  0.00000009541, 0.75742297675, 18849.2275499742,  0.00000008937, 2.05705419118, 77713.7714681205,
        0.00000006952, 0.82673305410,   775.5226113240,  0.00000005064, 4.66284525271,  1577.3435424478];
        self._E13 = [ 0.00000289226, 5.84384198723,  6283.0758499914,  0.00000034955, 0.00000000000,     0.0000000000, 0.00000016819, 5.48766912348, 12566.1516999828];
        self._E14 = [  0.00000114084, 3.14159265359,     0.0000000000,  0.00000007717, 4.13446589358,  6283.0758499914, 0.00000000765, 3.83803776214, 12566.1516999828];
        self._E15 = [  0.00000000878, 3.14159265359,     0.0000000000 ];


        self._E20 = [  #黄纬周期项
        0.00000279620, 3.19870156017, 84334.6615813083,  0.00000101643, 5.42248619256,  5507.5532386674,  0.00000080445, 3.88013204458,  5223.6939198022,  0.00000043806, 3.70444689758,  2352.8661537718,
        0.00000031933, 4.00026369781,  1577.3435424478,  0.00000022724, 3.98473831560,  1047.7473117547,  0.00000016392, 3.56456119782,  5856.4776591154,  0.00000018141, 4.98367470263,  6283.0758499914,
        0.00000014443, 3.70275614914,  9437.7629348870,  0.00000014304, 3.41117857525, 10213.2855462110];
        self._E21 = [  0.00000009030, 3.89729061890,  5507.5532386674,  0.00000006177, 1.73038850355,  5223.6939198022];

        self._E30 = [  #距离周期项
        1.00013988799, 0.00000000000,     0.0000000000,  0.01670699626, 3.09846350771,  6283.0758499914,  0.00013956023, 3.05524609620, 12566.1516999828,  0.00003083720, 5.19846674381, 77713.7714681205,
        0.00001628461, 1.17387749012,  5753.3848848968,  0.00001575568, 2.84685245825,  7860.4193924392,  0.00000924799, 5.45292234084, 11506.7697697936,  0.00000542444, 4.56409149777,  3930.2096962196];
        self._E31 = [  0.00103018608, 1.10748969588,  6283.0758499914,  0.00001721238, 1.06442301418, 12566.1516999828, 0.00000702215, 3.14159265359,     0.0000000000];
        self._E32 = [  0.00004359385, 5.78455133738,  6283.0758499914 ];
        self._E33 = [  0.00000144595, 4.27319435148,  6283.0758499914 ];
    

        #names = ['M10', 'M11', 'M12', 'M20', 'M21', 'M30', 'M31', 'M1n'];
        #M10：330项， M11：48项， M12：18项，
        #M20：330项， M21：48项，
        #M30：330项， M31：48项，
        #M1n：5项， 
        #月球运动参数
        self._M10 = [ # 月球黄经周期项
        22639.5858800,  2.3555545723,  8328.6914247251, 1.5231275E-04, 2.5041111E-07,-1.1863391E-09, 4586.4383203,  8.0413790709,  7214.0628654588,-2.1850087E-04,-1.8646419E-07, 8.7760973E-10, 2369.9139357, 10.3969336431, 15542.7542901840,-6.6188121E-05, 6.3946925E-08,-3.0872935E-10,  769.0257187,  4.7111091445, 16657.3828494503, 3.0462550E-04, 5.0082223E-07,-2.3726782E-09,
        -666.4175399, -0.0431256817,   628.3019552485,-2.6638815E-06, 6.1639211E-10,-5.4439728E-11, -411.5957339,  3.2558104895, 16866.9323152810,-1.2804259E-04,-9.8998954E-09, 4.0433461E-11,  211.6555524,  5.6858244986, -1114.6285592663,-3.7081362E-04,-4.3687530E-07, 2.0639488E-09,  205.4359530,  8.0845047526,  6585.7609102104,-2.1583699E-04,-1.8708058E-07, 9.3204945E-10,
        191.9561973, 12.7524882154, 23871.4457149091, 8.6124629E-05, 3.1435804E-07,-1.4950684E-09,  164.7286185, 10.4400593249, 14914.4523349355,-6.3524240E-05, 6.3330532E-08,-2.5428962E-10, -147.3213842, -2.3986802540, -7700.3894694766,-1.5497663E-04,-2.4979472E-07, 1.1318993E-09, -124.9881185,  5.1984668216,  7771.3771450920,-3.3094061E-05, 3.1973462E-08,-1.5436468E-10,
        -109.3803637,  2.3124288905,  8956.9933799736, 1.4964887E-04, 2.5102751E-07,-1.2407788E-09,   55.1770578,  7.1411231536, -1324.1780250970, 6.1854469E-05, 7.3846820E-08,-3.4916281E-10,  -45.0996092,  5.6113650618, 25195.6237400061, 2.4270161E-05, 2.4051122E-07,-1.1459056E-09,   39.5333010, -0.9002559173, -8538.2408905558, 2.8035534E-04, 2.6031101E-07,-1.2267725E-09,
        38.4298346, 18.4383127140, 22756.8171556428,-2.8468899E-04,-1.2251727E-07, 5.6888037E-10,   36.1238141,  7.0666637168, 24986.0742741754, 4.5693825E-04, 7.5123334E-07,-3.5590172E-09,   30.7725751, 16.0827581417, 14428.1257309177,-4.3700174E-04,-3.7292838E-07, 1.7552195E-09,  -28.3971008,  7.9982533891,  7842.3648207073,-2.2116475E-04,-1.8584780E-07, 8.2317000E-10,
        -24.3582283, 10.3538079614, 16171.0562454324,-6.8852003E-05, 6.4563317E-08,-3.6316908E-10,  -18.5847068,  2.8429122493,  -557.3142796331,-1.8540681E-04,-2.1843765E-07, 1.0319744E-09,   17.9544674,  5.1553411398,  8399.6791003405,-3.5757942E-05, 3.2589854E-08,-2.0880440E-10,   14.5302779, 12.7956138971, 23243.1437596606, 8.8788511E-05, 3.1374165E-07,-1.4406287E-09,
        14.3796974, 15.1080427876, 32200.1371396342, 2.3843738E-04, 5.6476915E-07,-2.6814075E-09,   14.2514576,-24.0810366320,    -2.3011998397, 1.5231275E-04, 2.5041111E-07,-1.1863391E-09,   13.8990596, 20.7938672862, 31085.5085803679,-1.3237624E-04, 1.2789385E-07,-6.1745870E-10,   13.1940636,  3.3302699264, -9443.3199839914,-5.2312637E-04,-6.8728642E-07, 3.2502879E-09,
        -9.6790568, -4.7542348263,-16029.0808942018,-3.0728938E-04,-5.0020584E-07, 2.3182384E-09,   -9.3658635, 11.2971895604, 24080.9951807398,-3.4654346E-04,-1.9636409E-07, 9.1804319E-10,    8.6055318,  5.7289501804, -1742.9305145148,-3.6814974E-04,-4.3749170E-07, 2.1183885E-09,   -8.4530982,  7.5540213938, 16100.0685698171, 1.1921869E-04, 2.8238458E-07,-1.3407038E-09,
        8.0501724, 10.4831850066, 14286.1503796870,-6.0860358E-05, 6.2714140E-08,-1.9984990E-10,   -7.6301553,  4.6679834628, 17285.6848046987, 3.0196162E-04, 5.0143862E-07,-2.4271179E-09,   -7.4474952, -0.0862513635,  1256.6039104970,-5.3277630E-06, 1.2327842E-09,-1.0887946E-10,    7.3712011,  8.1276304344,  5957.4589549619,-2.1317311E-04,-1.8769697E-07, 9.8648918E-10,
        7.0629900,  0.9591375719,    33.7570471374,-3.0829302E-05,-3.6967043E-08, 1.7385419E-10,   -6.3831491,  9.4966777258,  7004.5133996281, 2.1416722E-04, 3.2425793E-07,-1.5355019E-09,   -5.7416071, 13.6527441326, 32409.6866054649,-1.9423071E-04, 5.4047029E-08,-2.6829589E-10,    4.3740095, 18.4814383957, 22128.5152003943,-2.8202511E-04,-1.2313366E-07, 6.2332010E-10,
        -3.9976134,  7.9669196340, 33524.3151647312, 1.7658291E-04, 4.9092233E-07,-2.3322447E-09,   -3.2096876, 13.2398458924, 14985.4400105508,-2.5159493E-04,-1.5449073E-07, 7.2324505E-10,   -2.9145404, 12.7093625336, 24499.7476701576, 8.3460748E-05, 3.1497443E-07,-1.5495082E-09,    2.7318890, 16.1258838235, 13799.8237756692,-4.3433786E-04,-3.7354477E-07, 1.8096592E-09,
        -2.5679459, -2.4418059357, -7072.0875142282,-1.5764051E-04,-2.4917833E-07, 1.0774596E-09,   -2.5211990,  7.9551277074,  8470.6667759558,-2.2382863E-04,-1.8523141E-07, 7.6873027E-10,    2.4888871,  5.6426988169,  -486.3266040178,-3.7347750E-04,-4.3625891E-07, 2.0095091E-09,    2.1460741,  7.1842488353, -1952.4799803455, 6.4518350E-05, 7.3230428E-08,-2.9472308E-10,
        1.9777270, 23.1494218585, 39414.2000050930, 1.9936508E-05, 3.7830496E-07,-1.8037978E-09,    1.9336825,  9.4222182890, 33314.7656989005, 6.0925100E-04, 1.0016445E-06,-4.7453563E-09,    1.8707647, 20.8369929680, 30457.2066251194,-1.2971236E-04, 1.2727746E-07,-5.6301898E-10,   -1.7529659,  0.4873576771, -8886.0057043583,-3.3771956E-04,-4.6884877E-07, 2.2183135E-09,
        -1.4371624,  7.0979974718,  -695.8760698485, 5.9190587E-05, 7.4463212E-08,-4.0360254E-10,   -1.3725701,  1.4552986550,  -209.5494658307, 4.3266809E-04, 5.1072212E-07,-2.4131116E-09,    1.2618162,  7.5108957121, 16728.3705250656, 1.1655481E-04, 2.8300097E-07,-1.3951435E-09];
        self._M11 = [ #月球黄经泊松一项
        1.6768000, -0.0431256817,   628.3019552485,-2.6638815E-06, 6.1639211E-10,-5.4439728E-11,    0.5164200, 11.2260974062,  6585.7609102104,-2.1583699E-04,-1.8708058E-07, 9.3204945E-10,    0.4138300, 13.5816519784, 14914.4523349355,-6.3524240E-05, 6.3330532E-08,-2.5428962E-10,    0.3711500,  5.5402729076,  7700.3894694766, 1.5497663E-04, 2.4979472E-07,-1.1318993E-09,
        0.2756000,  2.3124288905,  8956.9933799736, 1.4964887E-04, 2.5102751E-07,-1.2407788E-09,    0.2459863,-25.6198212459,    -2.3011998397, 1.5231275E-04, 2.5041111E-07,-1.1863391E-09,    0.0711800,  7.9982533891,  7842.3648207073,-2.2116475E-04,-1.8584780E-07, 8.2317000E-10,    0.0612800, 10.3538079614, 16171.0562454324,-6.8852003E-05, 6.4563317E-08,-3.6316908E-10];
        self._M12 = [  0.0048700, -0.0431256817,   628.3019552485,-2.6638815E-06, 6.1639211E-10,-5.4439728E-11,  0.0022800,-27.1705318325,    -2.3011998397, 1.5231275E-04, 2.5041111E-07,-1.1863391E-09,  0.0015000, 11.2260974062,  6585.7609102104,-2.1583699E-04,-1.8708058E-07, 9.3204945E-10];
        self._M20 = [ #月球黄纬周期项
        18461.2400600,  1.6279052448,  8433.4661576405,-6.4021295E-05,-4.9499477E-09, 2.0216731E-11, 1010.1671484,  3.9834598170, 16762.1575823656, 8.8291456E-05, 2.4546117E-07,-1.1661223E-09,  999.6936555,  0.7276493275,  -104.7747329154, 2.1633405E-04, 2.5536106E-07,-1.2065558E-09,  623.6524746,  8.7690283983,  7109.2881325435,-2.1668263E-06, 6.8896872E-08,-3.2894608E-10,
        199.4837596,  9.6692843156, 15647.5290230993,-2.8252217E-04,-1.9141414E-07, 8.9782646E-10,  166.5741153,  6.4134738261, -1219.4032921817,-1.5447958E-04,-1.8151424E-07, 8.5739300E-10,  117.2606951, 12.0248388879, 23976.2204478244,-1.3020942E-04, 5.8996977E-08,-2.8851262E-10,   61.9119504,  6.3390143893, 25090.8490070907, 2.4060421E-04, 4.9587228E-07,-2.3524614E-09,
        33.3572027, 11.1245829706, 15437.9795572686, 1.5014592E-04, 3.1930799E-07,-1.5152852E-09,   31.7596709,  3.0832038997,  8223.9166918098, 3.6864680E-04, 5.0577218E-07,-2.3928949E-09,   29.5766003,  8.8121540801,  6480.9861772950, 4.9705523E-07, 6.8280480E-08,-2.7450635E-10,   15.5662654,  4.0579192538, -9548.0947169068,-3.0679233E-04,-4.3192536E-07, 2.0437321E-09,
        15.1215543, 14.3803934601, 32304.9118725496, 2.2103334E-05, 3.0940809E-07,-1.4748517E-09,  -12.0941511,  8.7259027166,  7737.5900877920,-4.8307078E-06, 6.9513264E-08,-3.8338581E-10,    8.8681426,  9.7124099974, 15019.2270678508,-2.7985829E-04,-1.9203053E-07, 9.5226618E-10,    8.0450400,  0.6687636586,  8399.7091105030,-3.3191993E-05, 3.2017096E-08,-1.5363746E-10,
        7.9585542, 12.0679645696, 23347.9184925760,-1.2754553E-04, 5.8380585E-08,-2.3407289E-10,    7.4345550,  6.4565995078, -1847.7052474301,-1.5181570E-04,-1.8213063E-07, 9.1183272E-10,   -6.7314363, -4.0265854988,-16133.8556271171,-9.0955337E-05,-2.4484477E-07, 1.1116826E-09,    6.5795750, 16.8104074692, 14323.3509980023,-2.2066770E-04,-1.1756732E-07, 5.4866364E-10,
        -6.4600721,  1.5847795630,  9061.7681128890,-6.6685176E-05,-4.3335556E-09,-3.4222998E-11,   -6.2964773,  4.8837157343, 25300.3984729215,-1.9206388E-04,-1.4849843E-08, 6.0650192E-11,   -5.6323538, -0.7707750092,   733.0766881638,-2.1899793E-04,-2.5474467E-07, 1.1521161E-09,   -5.3683961,  6.8263720663, 16204.8433027325,-9.7115356E-05, 2.7023515E-08,-1.3414795E-10,
        -5.3112784,  3.9403341353, 17390.4595376141, 8.5627574E-05, 2.4607756E-07,-1.2205621E-09,   -5.0759179,  0.6845236457,   523.5272223331, 2.1367016E-04, 2.5597745E-07,-1.2609955E-09,   -4.8396143, -1.6710309265, -7805.1642023920, 6.1357413E-05, 5.5663398E-09,-7.4656459E-11,   -4.8057401,  3.5705615768,  -662.0890125485, 3.0927234E-05, 3.6923410E-08,-1.7458141E-10,
        3.9840545,  8.6945689615, 33419.5404318159, 3.9291696E-04, 7.4628340E-07,-3.5388005E-09,    3.6744619, 19.1659620415, 22652.0424227274,-6.8354947E-05, 1.3284380E-07,-6.3767543E-10,    2.9984815, 20.0662179587, 31190.2833132833,-3.4871029E-04,-1.2746721E-07, 5.8909710E-10,    2.7986413, -2.5281611620,-16971.7070481963, 3.4437664E-04, 2.6526096E-07,-1.2469893E-09,
        2.4138774, 17.7106633865, 22861.5918885581,-5.0102304E-04,-3.7787833E-07, 1.7754362E-09,    2.1863132,  5.5132179088, -9757.6441827375, 1.2587576E-04, 7.8796768E-08,-3.6937954E-10,    2.1461692, 13.4801375428, 23766.6709819937, 3.0245868E-04, 5.6971910E-07,-2.7016242E-09,    1.7659832, 11.1677086523, 14809.6776020201, 1.5280981E-04, 3.1869159E-07,-1.4608454E-09,
        -1.6244212,  7.3137297434,  7318.8375983742,-4.3483492E-04,-4.4182525E-07, 2.0841655E-09,    1.5813036,  5.4387584720, 16552.6081165349, 5.2095955E-04, 7.5618329E-07,-3.5792340E-09,    1.5197528, 16.7359480324, 40633.6032972747, 1.7441609E-04, 5.5981921E-07,-2.6611908E-09,    1.5156341,  1.7023646816,-17876.7861416319,-4.5910508E-04,-6.8233647E-07, 3.2300712E-09,
        1.5102092,  5.4977296450,  8399.6847301375,-3.3094061E-05, 3.1973462E-08,-1.5436468E-10,   -1.3178223,  9.6261586339, 16275.8309783478,-2.8518605E-04,-1.9079775E-07, 8.4338673E-10,   -1.2642739, 11.9817132061, 24604.5224030729,-1.3287330E-04, 5.9613369E-08,-3.4295235E-10,    1.1918723, 22.4217725310, 39518.9747380084,-1.9639754E-04, 1.2294390E-07,-5.9724197E-10,
        1.1346110, 14.4235191419, 31676.6099173011, 2.4767216E-05, 3.0879170E-07,-1.4204120E-09,    1.0857810,  8.8552797618,  5852.6842220465, 3.1609367E-06, 6.7664088E-08,-2.2006663E-10,   -1.0193852,  7.2392703065, 33629.0898976466,-3.9751134E-05, 2.3556127E-07,-1.1256889E-09,   -0.8227141, 11.0814572888, 16066.2815125171, 1.4748204E-04, 3.1992438E-07,-1.5697249E-09,
        0.8042238,  3.5274358950,   -33.7870573000, 2.8263353E-05, 3.7539802E-08,-2.2902113E-10,    0.8025939,  6.7832463846, 16833.1452579809,-9.9779237E-05, 2.7639907E-08,-1.8858767E-10,   -0.7931866, -6.3821400710,-24462.5470518423,-2.4326809E-04,-4.9525589E-07, 2.2980217E-09,   -0.7910153,  6.3703481443,  -591.1013369332,-1.5714346E-04,-1.8089785E-07, 8.0295327E-10,
        -0.6674056,  9.1819266386, 24533.5347274576, 5.5197395E-05, 2.7743463E-07,-1.3204870E-09,    0.6502226,  4.1010449356,-10176.3966721553,-3.0412845E-04,-4.3254175E-07, 2.0981718E-09,   -0.6388131,  6.2958887075, 25719.1509623392, 2.3794032E-04, 4.9648867E-07,-2.4069012E-09];
        self._M21 = [ #月球黄纬泊松一项
        0.0743000, 11.9537467337,  6480.9861772950, 4.9705523E-07, 6.8280480E-08,-2.7450635E-10,    0.0304300,  8.7259027166,  7737.5900877920,-4.8307078E-06, 6.9513264E-08,-3.8338581E-10,    0.0222900, 12.8540026510, 15019.2270678508,-2.7985829E-04,-1.9203053E-07, 9.5226618E-10,    0.0199900, 15.2095572232, 23347.9184925760,-1.2754553E-04, 5.8380585E-08,-2.3407289E-10,
        0.0186900,  9.5981921614, -1847.7052474301,-1.5181570E-04,-1.8213063E-07, 9.1183272E-10,    0.0169600,  7.1681781524, 16133.8556271171, 9.0955337E-05, 2.4484477E-07,-1.1116826E-09,    0.0162300,  1.5847795630,  9061.7681128890,-6.6685176E-05,-4.3335556E-09,-3.4222998E-11,    0.0141900, -0.7707750092,   733.0766881638,-2.1899793E-04,-2.5474467E-07, 1.1521161E-09];
        self._M30 = [ #月球距离周期项
        385000.5290396,  1.5707963268,     0.0000000000, 0.0000000E+00, 0.0000000E+00, 0.0000000E+00,-20905.3551378, 3.9263508990,  8328.6914247251, 1.5231275E-04, 2.5041111E-07,-1.1863391E-09,-3699.1109330,  9.6121753977,  7214.0628654588,-2.1850087E-04,-1.8646419E-07, 8.7760973E-10,-2955.9675626, 11.9677299699, 15542.7542901840,-6.6188121E-05, 6.3946925E-08,-3.0872935E-10,
        -569.9251264,  6.2819054713, 16657.3828494503, 3.0462550E-04, 5.0082223E-07,-2.3726782E-09,  246.1584797,  7.2566208254, -1114.6285592663,-3.7081362E-04,-4.3687530E-07, 2.0639488E-09, -204.5861179, 12.0108556517, 14914.4523349355,-6.3524240E-05, 6.3330532E-08,-2.5428962E-10, -170.7330791, 14.3232845422, 23871.4457149091, 8.6124629E-05, 3.1435804E-07,-1.4950684E-09,
        -152.1378118,  9.6553010794,  6585.7609102104,-2.1583699E-04,-1.8708058E-07, 9.3204945E-10, -129.6202242, -0.8278839272, -7700.3894694766,-1.5497663E-04,-2.4979472E-07, 1.1318993E-09,  108.7427014,  6.7692631483,  7771.3771450920,-3.3094061E-05, 3.1973462E-08,-1.5436468E-10,  104.7552944,  3.8832252173,  8956.9933799736, 1.4964887E-04, 2.5102751E-07,-1.2407788E-09,
        79.6605685,  0.6705404095, -8538.2408905558, 2.8035534E-04, 2.6031101E-07,-1.2267725E-09,   48.8883284,  1.5276706450,   628.3019552485,-2.6638815E-06, 6.1639211E-10,-5.4439728E-11,  -34.7825237, 20.0091090408, 22756.8171556428,-2.8468899E-04,-1.2251727E-07, 5.6888037E-10,   30.8238599, 11.9246042882, 16171.0562454324,-6.8852003E-05, 6.4563317E-08,-3.6316908E-10,
        24.2084985,  9.5690497159,  7842.3648207073,-2.2116475E-04,-1.8584780E-07, 8.2317000E-10,  -23.2104305,  8.6374600436, 24986.0742741754, 4.5693825E-04, 7.5123334E-07,-3.5590172E-09,  -21.6363439, 17.6535544685, 14428.1257309177,-4.3700174E-04,-3.7292838E-07, 1.7552195E-09,  -16.6747239,  6.7261374666,  8399.6791003405,-3.5757942E-05, 3.2589854E-08,-2.0880440E-10,
        14.4026890,  4.9010662531, -9443.3199839914,-5.2312637E-04,-6.8728642E-07, 3.2502879E-09,  -12.8314035, 14.3664102239, 23243.1437596606, 8.8788511E-05, 3.1374165E-07,-1.4406287E-09,  -11.6499478, 22.3646636130, 31085.5085803679,-1.3237624E-04, 1.2789385E-07,-6.1745870E-10,  -10.4447578, 16.6788391144, 32200.1371396342, 2.3843738E-04, 5.6476915E-07,-2.6814075E-09,
        10.3211071,  8.7119194804, -1324.1780250970, 6.1854469E-05, 7.3846820E-08,-3.4916281E-10,   10.0562033,  7.2997465071, -1742.9305145148,-3.6814974E-04,-4.3749170E-07, 2.1183885E-09,   -9.8844667, 12.0539813334, 14286.1503796870,-6.0860358E-05, 6.2714140E-08,-1.9984990E-10,    8.7515625,  6.3563649081, -9652.8694498221,-9.0458282E-05,-1.7656429E-07, 8.3717626E-10,
        -8.3791067,  4.4137085761,  -557.3142796331,-1.8540681E-04,-2.1843765E-07, 1.0319744E-09,   -7.0026961, -3.1834384995,-16029.0808942018,-3.0728938E-04,-5.0020584E-07, 2.3182384E-09,    6.3220032,  9.1248177206, 16100.0685698171, 1.1921869E-04, 2.8238458E-07,-1.3407038E-09,    5.7508579,  6.2387797896, 17285.6848046987, 3.0196162E-04, 5.0143862E-07,-2.4271179E-09,
        -4.9501349,  9.6984267611,  5957.4589549619,-2.1317311E-04,-1.8769697E-07, 9.8648918E-10,   -4.4211770,  3.0260949818,  -209.5494658307, 4.3266809E-04, 5.1072212E-07,-2.4131116E-09,    4.1311145, 11.0674740526,  7004.5133996281, 2.1416722E-04, 3.2425793E-07,-1.5355019E-09,   -3.9579827, 20.0522347225, 22128.5152003943,-2.8202511E-04,-1.2313366E-07, 6.2332010E-10,
        3.2582371, 14.8106422192, 14985.4400105508,-2.5159493E-04,-1.5449073E-07, 7.2324505E-10,   -3.1483020,  4.8266068163, 16866.9323152810,-1.2804259E-04,-9.8998954E-09, 4.0433461E-11,    2.6164092, 14.2801588604, 24499.7476701576, 8.3460748E-05, 3.1497443E-07,-1.5495082E-09,    2.3536310,  9.5259240342,  8470.6667759558,-2.2382863E-04,-1.8523141E-07, 7.6873027E-10,
        -2.1171283, -0.8710096090, -7072.0875142282,-1.5764051E-04,-2.4917833E-07, 1.0774596E-09,   -1.8970368, 17.6966801503, 13799.8237756692,-4.3433786E-04,-3.7354477E-07, 1.8096592E-09,   -1.7385258,  2.0581540038, -8886.0057043583,-3.3771956E-04,-4.6884877E-07, 2.2183135E-09,   -1.5713944, 22.4077892948, 30457.2066251194,-1.2971236E-04, 1.2727746E-07,-5.6301898E-10,
        -1.4225541, 24.7202181853, 39414.2000050930, 1.9936508E-05, 3.7830496E-07,-1.8037978E-09,   -1.4189284, 17.1661967915, 23314.1314352759,-9.9282182E-05, 9.5920387E-08,-4.6309403E-10,    1.1655364,  3.8400995356,  9585.2953352221, 1.4698499E-04, 2.5164390E-07,-1.2952185E-09,   -1.1169371, 10.9930146158, 33314.7656989005, 6.0925100E-04, 1.0016445E-06,-4.7453563E-09,
        1.0656723,  1.4845449633,  1256.6039104970,-5.3277630E-06, 1.2327842E-09,-1.0887946E-10,    1.0586190, 11.9220903668,  8364.7398411275,-2.1850087E-04,-1.8646419E-07, 8.7760973E-10,   -0.9333176,  9.0816920389, 16728.3705250656, 1.1655481E-04, 2.8300097E-07,-1.3951435E-09,    0.8624328, 12.4550876470,  6656.7485858257,-4.0390768E-04,-4.0490184E-07, 1.9095841E-09,
        0.8512404,  4.3705828944,    70.9876756153,-1.8807069E-04,-2.1782126E-07, 9.7753467E-10,   -0.8488018, 16.7219647962, 31571.8351843857, 2.4110126E-04, 5.6415276E-07,-2.6269678E-09,   -0.7956264,  3.5134526588, -9095.5551701890, 9.4948529E-05, 4.1873358E-08,-1.9479814E-10];
        self._M31 = [ #
        0.5139500, 12.0108556517, 14914.4523349355,-6.3524240E-05, 6.3330532E-08,-2.5428962E-10,    0.3824500,  9.6553010794,  6585.7609102104,-2.1583699E-04,-1.8708058E-07, 9.3204945E-10,    0.3265400,  3.9694765808,  7700.3894694766, 1.5497663E-04, 2.4979472E-07,-1.1318993E-09,    0.2639600,  0.7416325637,  8956.9933799736, 1.4964887E-04, 2.5102751E-07,-1.2407788E-09,
        0.1230200, -1.6139220085,   628.3019552485,-2.6638815E-06, 6.1639211E-10,-5.4439728E-11,    0.0775400,  8.7830116346, 16171.0562454324,-6.8852003E-05, 6.4563317E-08,-3.6316908E-10,    0.0606800,  6.4274570623,  7842.3648207073,-2.2116475E-04,-1.8584780E-07, 8.2317000E-10,    0.0497000, 12.0539813334, 14286.1503796870,-6.0860358E-05, 6.2714140E-08,-1.9984990E-10];
        self._M1n = [ #月球平黄经系数
            3.81034392032, 8.39968473021E+03,-3.31919929753E-05, 3.20170955005E-08,-1.53637455544E-10];

    #取整数部分
    def int2(self, v):
        v = math.floor(v);
        if (v < 0):
            return v+1;

        return v;

    # 对超过0-2PI的角度转为0-2PI
    def rad2mrad(self, v):
        v = v%(2*math.pi);
        if (v < 0):
            return v + 2*math.pi;
        return v;

    # 计算世界时与原子时之差,传入年
    def deltatT(self, y):
        dts = self._dts;
        for i in range(0, 100, 5):
            if (y < dts[i+5] or i == 95):
                break;
        #print('i = ', i, ', year = ', y, '>>>');
        t1 = (y - dts[i]) / (dts[i + 5] - dts[i]) * 10;
        t2 = t1 * t1;
        t3 = t2 * t1;
        return dts[i + 1] + dts[i + 2] * t1 + dts[i + 3] * t2 + dts[i + 4] * t3;
        

    # 传入儒略日(J2000起算),计算UTC与原子时的差(单位:日)
    def deltatT2(self, jd):
        return self.deltatT(jd / 365.2425 + 2000) / 86400.0; #一天86400秒


    # 公历转儒略日,UTC=1表示原日期是UTC
    # UTC是布尔值，取值为0或1
    def toJD(self, UTC):
        y = self._Y; # 取出年月
        m = self._M;
        n = 0;
        if (m <= 2):
            m += 12;
            y -= 1;

        if (self._Y * 372 + self._M * 31 + self._D >= 588829):
            # 判断是否为格里高利历日1582*372+10*31+15
            n = self.int2(y / 100);
            n = 2 - n + self.int2(n / 4);# 加百年闰

        n += self.int2(365.2500001 * (y + 4716)); # 加上年引起的偏移日数
        n += self.int2(30.6 * (m + 1)) + self._D; # 加上月引起的偏移日数及日偏移数
        n += ((self._s / 60 + self._m) / 60 + self._h) / 24 - 1524.5;
        if (UTC):
            return n + self.deltatT2(n - self._J2000);
        return n;

    # 公历转儒略日,UTC=1表示原日期是UTC
    # UTC是布尔值，取值为0或1
    # array 为[Y, M, D, h, m, s]的格式化时间阵列
    def arrayToJD(self, array, UTC = True):
        Y = array[0]; # 取出年月
        M = array[1];
        D = array[2];
        h = array[3];
        m = array[4];
        s = array[5];
        
        n = 0;
        if (M <= 2):
            M += 12;
            Y -= 1;

        if (Y * 372 + M * 31 + D >= 588829):
            # 判断是否为格里高利历日1582*372+10*31+15
            n = self.int2(Y / 100);
            n = 2 - n + self.int2(n / 4);# 加百年闰

        n += self.int2(365.2500001 * (Y + 4716)); # 加上年引起的偏移日数
        n += self.int2(30.6 * (M + 1)) + D; # 加上月引起的偏移日数及日偏移数
        n += ((s / 60 + m) / 60 + h) / 24 - 1524.5;
        if (UTC):
            return n + self.deltatT2(n - self._J2000);
        return n;   

    # 儒略日数转公历,UTC=1表示目标公历是UTC
    #boolean UTC
    def setFromJD(self, jd, UTC):
        if (UTC):
            jd -= self.deltatT2(jd - self._J2000);
        jd += 0.5;
        # 取得日数的整数部份A及小数部分F
        A = self.int2(jd);
        F = jd - A;
        D = 0;
        if (A > 2299161):
            D = self.int2((A - 1867216.25) / 36524.25);
            A += 1 + D - self.int2(D / 4);

        A += 1524; # 向前移4年零2个月
        self._Y = self.int2((A - 122.1) / 365.25);# 年
        D = A - self.int2(365.25 * self._Y); # 去除整年日数后余下日数
        self._M = self.int2(D / 30.6001); # 月数
        self._D = D - self.int2(self._M * 30.6001);# 去除整月日数后余下日数
        self._Y -= 4716;
        self._M-=1;
        if (self._M > 12):
            self._M -= 12;
        if (self._M <= 2):
            self._Y+=1;
        # 日的小数转为时分秒
        F *= 24;
        self._h = self.int2(F);
        F -= self._h;
        F *= 60;
        self._m = self.int2(F);
        F -= self._m;
        F *= 60;
        self._s = F;

    # 设置时间,参数例:"20000101 120000"或"20000101"
    def setFromStr(self, s):
        self._Y = decimal.Decimal(s[0:4]);
        self._M = decimal.Decimal(s[4:6]);
        self._D = decimal.Decimal(s[6:8]);

        if (len(s) > 9):
            self._h = decimal.Decimal(s[9:11]);
            self._m = decimal.Decimal(s[11:13]);
            self._s = decimal.Decimal(s[13:15]); # 将5改为了2
        else:
            self._h = decimal.Decimal('00');
            self._m = decimal.Decimal('00');
            self._s = decimal.Decimal('00'); # 将5改为了2

        self._Y = float(self._Y);
        self._M = float(self._M);
        self._D = float(self._D);
        self._h = float(self._h);
        self._m = float(self._m);
        self._s = float(self._s);


    # 日期转为串
    def toStr(self):
        Y = "     " + str(int(self._Y));#四个空格
        M = "0" + str(int(self._M));
        D = "0" + str(int(self._D));
        h = self._h;
        m = self._m;
        s = math.floor(self._s + 0.5);
        if (s >= 60):
            s -= 60;
            m+=1;

        if (m >= 60):
            m -= 60;
            h+=1;

        sh = "0" + str(int(h));
        sm = "0" + str(int(m));
        ss = "0" + str(int(s));

        Y = Y[len(Y)-5:2*len(Y)-5];
        M = M[len(M)-2:2*len(M)-2];
        D = D[len(D)-2:2*len(D)-2];
        sh = sh[len(sh)-2:2*len(sh)-2];
        sm = sm[len(sm)-2:2*len(sm)-2];
        ss = ss[len(ss)-2:2*len(ss)-2];

        return Y + "-" + M + "-" + D + " " + sh + ":" + sm + ":" + ss;

    #日期转为数组
    def toArray(self):
        Y = int(self._Y);
        M = int(self._M);
        D = int(self._D);
        h = int(self._h);
        m = int(self._m);
        s = math.floor(self._s + 0.5);

        return [Y, M, D, h, m, s];


    
    
    # 算出:jd转到当地UTC后,UTC日数的整数部分或小数部分
    # 基于J2000力学时jd的起算点是12:00:00时,所以跳日时刻发生在12:00:00,这与日历计算发生矛盾
    # 把jd改正为00:00:00起算,这样儒略日的跳日动作就与日期的跳日同步
    # 改正方法为jd=jd+0.5-deltatT+shiqu/24
    # 把儒略日的起点移动-0.5(即前移12小时)
    # 式中shiqu是时区,北京的起算点是-8小时,shiqu取8
    # 参数类型：double jd, int shiqu, boolean dec
    def Dint_dec(self, jd, shiqu, dec = 1):
        u = jd + 0.5 - self.deltatT2(jd) + shiqu / 24;
        if (dec):
            return math.floor(u); # 返回整数部分
        else:
            return u - math.floor(u); # 返回小数部分

    # 计算两个日期的相差的天数,输入字串格式日期,如:"20080101"
    def d1_d2(self, d1, d2):
        Y = self._Y;
        M = self._M;
        D = self._D;
        h = self._h;
        m = self._m
        s = self._s; # 备份原来的数据
        
        self.setFromStr(d1[0:8] + " 120000");
        jd1 = self.toJD(False);
        self.setFromStr(d2[0:8] + " 120000");
        jd2 = self.toJD(False);
        self._Y = Y;
        self._M = M;
        self._D = D;
        self._h = h;
        self._m = m;
        self._s = s; # 还原
        if (jd1 > jd2):
            return math.floor(jd1 - jd2 + .0001);
        else:
            return -math.floor(jd2 - jd1 + .0001);


    # 返回黄赤交角(常规精度),短期精度很高
    def hcjj1(self, t):
        hcjjB = self._hcjjB;
        rad = self._rad;
        
        t1 = t / 36525;
        t2 = t1 * t1;
        t3 = t2 * t1;
        return (hcjjB[0] + hcjjB[1] * t1 + hcjjB[2] * t2 + hcjjB[3] * t3) / rad;


    # 黄赤转换(黄赤坐标旋转)
    #传入经纬度数组，运算后传出
    def HCconv(self, JW, E):
        # 黄道赤道坐标变换,赤到黄E取负
        HJ = self.rad2mrad(JW[0]);
        HW = JW[1];
        sinE = math.sin(E);
        cosE = math.cos(E);
        sinW = cosE * math.sin(HW) + sinE * math.cos(HW) * math.sin(HJ);
        #如果出了错，一定要来看看这个atan2的处理
        J = math.atan2(math.sin(HJ) * cosE - math.tan(HW) * sinE, math
        .cos(HJ));
        JW[0] = self.rad2mrad(J);
        JW[1] = math.asin(sinW);
        return JW;

    # 补岁差
    #double jd, double[] zb
    def addPrece(self, jd, zb):
        rad = self._rad;
        preceB = self._preceB;
        
        t = 1;
        v = 0;
        t1 = jd / 365250;
        for i in range(1, 8): 
            t *= t1;
            v += preceB[i] * t;

        zb[0] = self.rad2mrad(zb[0] + (v + 2.9965 * t1) / rad);
        return zb;

    # 恒星周年光行差计算(黄道坐标中)
    def addGxc(self, t, zb):
        GXC_l = self._GXC_l;
        GXC_p = self._GXC_p;
        GXC_e = self._GXC_e;
        GXC_k = self._GXC_k;     
        
        
        t1 = t / 36525;
        t2 = t1 * t1;
        t3 = t2 * t1;
        t4 = t3 * t1;
        L = GXC_l[0] + GXC_l[1] * t1 + GXC_l[2] * t2 + GXC_l[3] * t3 + GXC_l[4] * t4;
        p = GXC_p[0] + GXC_p[1] * t1 + GXC_p[2] * t2;
        e = GXC_e[0] + GXC_e[1] * t1 + GXC_e[2] * t2;
        dL = L - zb[0];
        dP = p - zb[0];
        zb[0] -= GXC_k * (math.cos(dL) - e * math.cos(dP)) / math.cos(zb[1]);
        zb[1] -= GXC_k * math.sin(zb[1]) * (math.sin(dL) - e * math.sin(dP));
        zb[0] = self.rad2mrad(zb[0]);

        return zb;

    # 计算黄经章动及交角章动
    # 返回章动结构体[lon, obl]这个数值对
    def nutation(self, t):
        nutB = self._nutB;
        rad = self._rad;       


        #这个是传回的章动量
        d = [0]*2;
        d[0] = 0;
        d[1] = 0;
        t /= 36525;
        
        c = 0;
        t1 = t;
        t2 = t1 * t1;
        t3 = t2 * t1;
        t4 = t3 * t1;# t5=t4*t1;

        for i in range(0, len(nutB), 9):
            c = nutB[i] + nutB[i + 1] * t1 + nutB[i + 2] * t2 + nutB[i + 3] * t3 + nutB[i + 4] * t4;
            d[0] += (nutB[i + 5] + nutB[i + 6] * t / 10) * math.sin(c); # 黄经章动
            d[1] += (nutB[i + 7] + nutB[i + 8] * t / 10) * math.cos(c); # 交角章动

        d[0] /= rad * 10000; # 黄经章动
        d[1] /= rad * 10000; # 交角章动
        return d;


    # 本函数计算赤经章动及赤纬章动
    #传入和传出zb
    def nutationRaDec(self, t, zb):
        Ra = zb[0];
        Dec = zb[1];
        E = self.hcjj1(t);
        sinE = math.sin(E);
        cosE = math.cos(E); # 计算黄赤交角

        #章动
        d = self.nutation(t); # 计算黄经章动及交角章动
        cosRa = math.cos(Ra);
        sinRa = math.sin(Ra);
        tanDec = math.tan(Dec);
        zb[0] += (cosE + sinE * sinRa * tanDec) * d[0] - cosRa * tanDec * d[1]; # 赤经章动
        zb[1] += sinE * cosRa * d[0] + sinRa * d[1]; # 赤纬章动
        zb[0] = self.rad2mrad(zb[0]);
        return zb;


    # 计算E10,E11,E20等,即:某一组周期项或泊松项算出,计算前先设置EnnT时间
    #传入F
    def Enn(self, F):
        v = 0;
        EnnT = self._EnnT;

        for i in range(0, len(F), 3):
            v += F[i] * math.cos(F[i + 1] + EnnT * F[i + 2]);
        return v;

    # 返回地球位置,日心Date黄道分点坐标
    def earCal(self, jd):
        E10 = self._E10;
        E11 = self._E11;
        E12 = self._E12;
        E13 = self._E13;
        E14 = self._E14;
        E15 = self._E15;

        E20 = self._E20;
        E21 = self._E21;

        E30 = self._E30;
        E31 = self._E31;
        E32 = self._E32;
        E33 = self._E33;
        
        #设置
        self._EnnT = jd / 365250;
        EnnT = self._EnnT;
        llr = [0]*3;

        t1 = EnnT;
        t2 = t1 * t1;
        t3 = t2 * t1;
        t4 = t3 * t1;
        t5 = t4 * t1;
        llr[0] = self.Enn(E10) + self.Enn(E11) * t1 + self.Enn(E12) * t2 + self.Enn(E13) * t3 + self.Enn(E14) * t4 + self.Enn(E15) * t5;
        llr[1] = self.Enn(E20) + self.Enn(E21) * t1;
        llr[2] = self.Enn(E30) + self.Enn(E31) * t1 + self.Enn(E32) * t2 + self.Enn(E33) * t3;
        llr[0] = self.rad2mrad(llr[0]);
        return llr;

    # 传回jd时刻太阳的地心视黄经及黄纬
    def sunCal2(self, jd):
        sun = self.earCal(jd);
        sun[0] += math.pi;
        sun[1] = -sun[1]; # 计算太阳真位置

        #章动
        d = self.nutation(jd);
        sun[0] = self.rad2mrad(sun[0] + d[0]); # 补章动
        sun = self.addGxc(jd, sun); # 补周年黄经光行差
        return sun; # 返回太阳视位置


   
    # 计算M10,M11,M20等,计算前先设置MnnT时间
    def Mnn(self, F):
        v = 0;
        t1 = self._MnnT;
        t2 = t1 * t1;
        t3 = t2 * t1;
        t4 = t3 * t1;

        for i in range(0, len(F), 6):
            v += F[i] * math.sin(F[i + 1] + t1 * F[i + 2] + t2 * F[i + 3] + t3 * F[i + 4] + t4 * F[i + 5]);
        return v;

    # 返回月球位置,返回地心Date黄道坐标
    def moonCal(self, jd):
        M10 = self._M10;
        M11 = self._M11;
        M12 = self._M12;

        M20 = self._M20;
        M21 = self._M21;

        M30 = self._M30;
        M31 = self._M31;
        M1n = self._M1n;
        
        self._MnnT = jd / 36525;
        MnnT = self._MnnT;
        rad = self._rad;
        
        t1 = MnnT;
        t2 = t1 * t1;
        t3 = t2 * t1;
        t4 = t3 * t1;

        llr = [0]*3;
        llr[0] = (self.Mnn(M10) + self.Mnn(M11) * t1 + self.Mnn(M12) * t2) / rad;
        llr[1] = (self.Mnn(M20) + self.Mnn(M21) * t1) / rad;
        llr[2] = (self.Mnn(M30) + self.Mnn(M31) * t1) * 0.999999949827;
        llr[0] = llr[0] + M1n[0] + M1n[1] * t1 + M1n[2] * t2 + M1n[3] * t3 + M1n[4] * t4;
        llr[0] = self.rad2mrad(llr[0]); # 地心Date黄道原点坐标(不含岁差)
        llr = self.addPrece(jd, llr); # 补岁差
        return llr;

    # 传回月球的地心视黄经及视黄纬
    def moonCal2(self, jd):
        moon = self.moonCal(jd);
        #章动
        d = self.nutation(jd);
        moon[0] = self.rad2mrad(moon[0] + d[0]); # 补章动
        return moon;

    # 传回月球的地心视赤经及视赤纬
    def moonCal3(self, jd):
        moon = self.moonCal(jd);
        moon = self.HCconv(moon, self.hcjj1(jd));
        moon = self.nutationRaDec(jd, moon); # 补赤经及赤纬章动
        # 如果黄赤转换前补了黄经章动及交章动,就不能再补赤经赤纬章动
        return moon;



    # ==================地心坐标中的日月位置计算===================
    def jiaoCai(self, lx, t, jiao):
        # lx=1时计算t时刻日月角距与jiao的差, lx=0计算t时刻太阳黄经与jiao的差
        sun = self.earCal(t); # 计算太阳真位置(先算出日心坐标中地球的位置)
        sun[0] += math.pi;
        sun[1] = -sun[1]; # 转为地心坐标
        sun = self.addGxc(t, sun); # 补周年光行差
        if (lx == 0):
            #章动
            d = self.nutation(t);
            sun[0] += d[0]; # 补黄经章动
            return self.rad2mrad(jiao - sun[0]);

        moon = self.moonCal(t); # 日月角差与章动无关
        return self.rad2mrad(jiao - (moon[0] - sun[0]));


    # ==================已知位置反求时间===================
    def jiaoCal(self, t1, jiao, lx):
        # t1是J2000起算儒略日数
        # 已知角度(jiao)求时间(t)
        # lx=0是太阳黄经达某角度的时刻计算(用于节气计算)
        # lx=1是日月角距达某角度的时刻计算(用于定朔望等)
        # 传入的t1是指定角度对应真时刻t的前一些天
        # 对于节气计算,应满足t在t1到t1+360天之间,对于Y年第n个节气(n=0是春分),t1可取值Y*365.2422+n*15.2
        # 对于朔望计算,应满足t在t1到t1+25天之间,在此范围之外,求右边的根
        t2 = t1;
        t = 0;
        v = 0;
        if (lx == 0):
            t2 += 360; # 在t1到t2范围内求解(范气360天范围),结果置于t
        else:
            t2 += 25;
        jiao *= math.pi / 180; # 待搜索目标角
        # 利用截弦法计算
        v1 = self.jiaoCai(lx, t1, jiao); # v1,v2为t1,t2时对应的黄经
        v2 = self.jiaoCai(lx, t2, jiao);
        if (v1 < v2):
            v2 -= 2 * math.pi; # 减2pi作用是将周期性角度转为连续角度
        k = 1;
        k2 = 0; # k是截弦的斜率

        for i in range(10): # 快速截弦求根,通常截弦三四次就已达所需精度
            k2 = (v2 - v1) / (t2 - t1); # 算出斜率
            if (abs(k2) > 1e-15):
                k = k2; # 差商可能为零,应排除
            t = t1 - v1 / k;
            v = self.jiaoCai(lx, t, jiao);# 直线逼近法求根(直线方程的根)
            if (v > 1):
                v -= 2 * math.pi; # 一次逼近后,v1就已接近0,如果很大,则应减1周
            if (abs(v) < 1e-8):
                break; # 已达精度
            t1 = t2;
            v1 = v2;
            t2 = t;
            v2 = v; # 下一次截弦

        return t;

    # 节气使计算范例,y是年分,这是个测试函数
    def JQtest(self, y):
        J2000 = self._J2000;

        jqB = [ #节气表
        "春分","清明","谷雨","立夏","小满","芒种","夏至","小暑","大暑","立秋","处暑","白露",
        "秋分","寒露","霜降","立冬","小雪","大雪","冬至","小寒","大寒","立春","雨水","惊蛰"];
        
        jd = 365.2422 * (y - 2000);
        q = 0;
        s1 = '';
        s2 = '';

        for i in range(24):
            q = self.jiaoCal(jd + i * 15.2, i * 15, 0);
            q = q + J2000 + 8 / 24; # 计算第i个节气(i=0是春风),结果转为北京时
            self.setFromJD(q, True);
            s1 = self.toStr(); # 将儒略日转成世界时
            self.setFromJD(q, False);
            s2 = self.toStr(); # 将儒略日转成日期格式(输出日期形式的力学时)
            print(jqB[i] + " : " + s1 + " " + s2); # 显示

    # =================定朔弦望计算========================
    def dingSuo(self, y, arc): # 这是个测试函数
        J2000 = self._J2000;

        
        jd = 365.2422 * (y - 2000);
        q = 0;
        
        s1 = '';
        s2 = '';
        
        print("月份:世界时  原子时");
        for i in range(12):
            q = self.jiaoCal(jd + 29.5 * i, arc, 1) + J2000 + 8 / 24; # 计算第i个节气(i=0是春风),结果转为北京时
            self.setFromJD(q, True);
            s1 = self.toStr(); # 将儒略日转成世界时
            self.setFromJD(q, False);
            s2 = self.toStr(); # 将儒略日转成日期格式(输出日期形式的力学时)
            print(str(i + 1) + "月 : " + s1 + " " + s2); # 显示


    #=================农历计算========================
    '''
    /*****
    * 1.冬至所在的UTC日期保存在A[0],根据"规定1"得知在A[0]之前(含A[0])的那个UTC朔日定为年首日期
    * 冬至之后的中气分保存在A[1],A[2],A[3]...A[13],其中A[12]又回到了冬至,共计算13次中气
    * 2.连续计算冬至后14个朔日,即起算时间时A[0]+1 14个朔日编号为0,1...12,保存在C[0],C[1]...C[13]
    * 这14个朔日表示编号为0月,1月,...12月0月的各月终止日期,但要注意实际终止日是新月初一,不属本月
    * 这14个朔日同样表示编号为1月,2月...的开始日期
    * 设某月编号为n,那么开始日期为C[n-1],结束日期为C[n],如果每月都含中气,该月所含的中气为A[n]
    * 注:为了全总计算出13个月的大小月情况,须算出14个朔日。 3.闰年判断:含有13个月的年份是闰年 当第13月(月编号12月)终止日期大于冬至日,
    * 即C[12]〉A[12], 那么该月是新年,本年没月12月,本年共12个月
    * 当第13月(月编号12月)终止日期小等于冬至日,即C[12]≤A[12],那么该月是本年的有效月份,本年共13个月 4.闰年中处理闰月:
    * 13个月中至少1个月份无中气,首个无中气的月置闰,在n=1...12月中找到闰月,即C[n]≤A[n]
    * 从农历年首的定义知道,0月一定含有中气冬至,所以不可能是闰月。 首月有时很贪心,除冬至外还可能再吃掉本年或前年的另一个中气
    * 定出闰月后,该月及以后的月编号减1 5.以上所述的月编号不是日常生活中说的"正月","二月"等月名称:
    * 如果"建子",0月为首月,如果"建寅",2月的月名"正月",3月是"二月",其余类推
    *****/
    '''
    
    # 农历排月序计算,可定出农历
    def paiYue(self, y): 
        J2000 = self._J2000;
        yueMing = [ "正", "二", "三", "四", "五", "六",
                    "七", "八", "九", "十", "十一", "十二" ];
        jqB = [ #节气表
        "春分","清明","谷雨","立夏","小满","芒种","夏至","小暑","大暑","立秋","处暑","白露",
        "秋分","寒露","霜降","立冬","小雪","大雪","冬至","小寒","大寒","立春","雨水","惊蛰"];
        #中气
        zq = [0]*20;
        #节气
        jq = [0]*20;
        #全朔表
        hs = [0]*20;

        # var zq=new Array(),jq=new Array(), hs=new Array(); #中气表,节气表,日月合朔表
        # 从冬至开始,连续计算14个中气时刻
        t1 = 365.2422 * (y - 2000) - 50; # 农历年首始于前一年的冬至,为了节气中气一起算,取前年大雪之前
        for i in range(14): # 计算节气(从冬至开始),注意:返回的是力学时
            zq[i] = self.jiaoCal(t1 + i * 30.4, i * 30 - 90, 0); # 中气计算,冬至的太阳黄经是270度(或-90度)
            jq[i] = self.jiaoCal(t1 + i * 30.4, i * 30 - 105, 0); # 顺便计算节气,它不是农历定朔计算所必需的

        # 在冬至过后,连续计算14个日月合朔时刻
        dongZhiJia1 = zq[0] + 1 - self.Dint_dec(zq[0], 8, False); # 冬至过后的第一天0点的儒略日数
        hs[0] = self.jiaoCal(dongZhiJia1, 0, 1); # 首月结束的日月合朔时刻
        for i in range(1, 14):
            hs[i] = self.jiaoCal(hs[i - 1] + 25, 0, 1);
        # 算出中气及合朔时刻的日数(不含小数的日数计数,以便计算日期之间的差值)
        A = [0]*20;
        B = [0]*20;
        C = [0]*20;

        # var A=new Array(), B=new Array(), C=new Array();
        for i in range(14):# 取当地UTC日数的整数部分
            A[i] = self.Dint_dec(zq[i], 8, True);
            B[i] = self.Dint_dec(jq[i], 8, True);
            C[i] = self.Dint_dec(hs[i], 8, True);

        # 闰月及大小月分析
        tot = 12;
        nun = -1;
        yn = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0 ]; # 月编号
        if (C[12] <= A[12]): # 闰月分析  合朔小于中气
            #print(C[12], A[12]);
            
            yn[12] = 12;
            tot = 13; # 编号为12的月是本年的有效月份,本年总月数13个
            for i in range(1, 13):
                if (C[i] <= A[i]):
                    #print(i);
                    break;
            nun = i-1;
            for j in range(nun, 13):
                yn[j] = j; # 注意yn中不含农历首月(所以取i-1),在公历中农历首月总是去年的所以不多做计算
        #print(nun); #打印闰月的月份
        #print(yn); #打印月序阵列
        
        syn= ['0']*20;
        for i in range(tot): # 转为建寅月名,并做大小月分析
            syn[i] = yueMing[(yn[i] + 10)%12]; # 转建寅月名
            if (i == nun):
                syn[i] += "闰";
            else:
                syn[i] += "月"; # 标记是否闰月
            if (C[i + 1] - C[i] > 29):
                syn[i] += "大";
            else:
                syn[i] += "小"; # 标记大小月

        # 显示
        out = '{0:^3}{1:^19}{2:^3}{3:^19}{4:^4}{5:^20}'.format('节气', '手表时', '中气', '手表时', '农历月', '朔的手表时');
        print(out);
        out = '';
        for i in range(tot):
            zm = (i * 2 + 18)%24;
            jm = (i * 2 + 17)%24; # 中气名节气名
            self.setFromJD(jq[i] + J2000 + 8 / 24, True);
            out += jqB[jm] + ":" + self.toStr() + " "; # 显示节气
            self.setFromJD(zq[i] + J2000 + 8 / 24, True);
            out += jqB[zm] + ":" + self.toStr() + " "; # 显示中气
            self.setFromJD(hs[i] + J2000 + 8 / 24, True);
            out += syn[i] + ":" + self.toStr() + "\r\n"; # 显示日月合朔

        print(out);

    # 农历排月序计算,可定出农历
    # 返回当年的各节各气，各月的一个将所有时间排序后的格式化数组
    def paiYueCalc(self, y): 
        J2000 = self._J2000;
        yueMing = [ "正", "二", "三", "四", "五", "六",
                    "七", "八", "九", "十", "十一", "十二" ];
        jqB = [ #节气表
        "春分","清明","谷雨","立夏","小满","芒种","夏至","小暑","大暑","立秋","处暑","白露",
        "秋分","寒露","霜降","立冬","小雪","大雪","冬至","小寒","大寒","立春","雨水","惊蛰"];
        #中气
        zq = [0]*20;
        #节气
        jq = [0]*20;
        #全朔表
        hs = [0]*20;

        # var zq=new Array(),jq=new Array(), hs=new Array(); #中气表,节气表,日月合朔表
        # 从冬至开始,连续计算14个中气时刻
        t1 = 365.2422 * (y - 2000) - 50; # 农历年首始于前一年的冬至,为了节气中气一起算,取前年大雪之前
        for i in range(14): # 计算节气(从冬至开始),注意:返回的是力学时
            zq[i] = self.jiaoCal(t1 + i * 30.4, i * 30 - 90, 0); # 中气计算,冬至的太阳黄经是270度(或-90度)
            jq[i] = self.jiaoCal(t1 + i * 30.4, i * 30 - 105, 0); # 顺便计算节气,它不是农历定朔计算所必需的

        # 在冬至过后,连续计算14个日月合朔时刻
        dongZhiJia1 = zq[0] + 1 - self.Dint_dec(zq[0], 8, False); # 冬至过后的第一天0点的儒略日数
        hs[0] = self.jiaoCal(dongZhiJia1, 0, 1); # 首月结束的日月合朔时刻
        for i in range(1, 14):
            hs[i] = self.jiaoCal(hs[i - 1] + 25, 0, 1);
        # 算出中气及合朔时刻的日数(不含小数的日数计数,以便计算日期之间的差值)
        A = [0]*20;
        B = [0]*20;
        C = [0]*20;

        # var A=new Array(), B=new Array(), C=new Array();
        for i in range(14):# 取当地UTC日数的整数部分
            A[i] = self.Dint_dec(zq[i], 8, True);
            B[i] = self.Dint_dec(jq[i], 8, True);
            C[i] = self.Dint_dec(hs[i], 8, True);

        # 闰月及大小月分析
        tot = 12;
        nun = -1;
        yn = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0 ]; # 月编号
        if (C[12] <= A[12]): # 闰月分析  合朔小于中气
            #print(C[12], A[12]);
            
            yn[12] = 12;
            tot = 13; # 编号为12的月是本年的有效月份,本年总月数13个
            for i in range(1, 13):
                if (C[i] <= A[i]):
                    #print(i);
                    break;
            nun = i-1;
            for j in range(nun, 13):
                yn[j] = j; # 注意yn中不含农历首月(所以取i-1),在公历中农历首月总是去年的所以不多做计算
        #print(nun); #打印闰月的月份
        #print(yn); #打印月序阵列
        
        syn= ['0']*20;
        for i in range(tot): # 转为建寅月名,并做大小月分析
            syn[i] = yueMing[(yn[i] + 10)%12]; # 转建寅月名
            if (i == nun):
                syn[i] += "闰";
            else:
                syn[i] += "月"; # 标记是否闰月
            if (C[i + 1] - C[i] > 29):
                syn[i] += "大";
            else:
                syn[i] += "小"; # 标记大小月

        result = [];
        
        for i in range(tot):
            zm = (i * 2 + 18)%24;
            jm = (i * 2 + 17)%24; # 中气名节气名
            self.setFromJD(jq[i] + J2000 + 8 / 24, True);
            a = self.toArray();
            result.append([jqB[jm], a]);

            self.setFromJD(zq[i] + J2000 + 8 / 24, True);
            a = self.toArray();
            result.append([jqB[zm], a]);

            self.setFromJD(hs[i] + J2000 + 8 / 24, True);
            a = self.toArray();
            result.append([syn[i], a]);

        result = sorted(result, key=lambda a:a[1]);
            
        return result;
        '''
        # 显示
        out = '{0:^3}{1:^19}{2:^3}{3:^19}{4:^4}{5:^20}'.format('节气', '手表时', '中气', '手表时', '农历月', '朔的手表时');
        print(out);
        out = '';
        for i in range(tot):
            zm = (i * 2 + 18)%24;
            jm = (i * 2 + 17)%24; # 中气名节气名
            self.setFromJD(jq[i] + J2000 + 8 / 24, True);
            out += jqB[jm] + ":" + self.toStr() + " "; # 显示节气
            self.setFromJD(zq[i] + J2000 + 8 / 24, True);
            out += jqB[zm] + ":" + self.toStr() + " "; # 显示中气
            self.setFromJD(hs[i] + J2000 + 8 / 24, True);
            out += syn[i] + ":" + self.toStr() + "\r\n"; # 显示日月合朔

        print(out);
        '''
    

    def print(self):
        self.paiYue(-999);



###
# @usage   计算某日的相关信息，包括农历和四柱，未来或加入五行
# @author  mw
# @date    2016年05月31日  星期二  08:23:35 
# @param
# @return
#
###
class Calendar(SolarTerm):      
    #天干
    def heavenStem(self):
        return ['甲', '乙', '丙', '丁', '戊','己','庚','辛','壬','癸'];

    #地支
    def earthStem(self):
        return ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];

    #五行相克顺序
    def fiveRunnerRestriction(self):
        return ['金', '木', '土', '水', '火'];

    #五行相生顺序
    def fiveRunnerInterpromotion(self):
        return ['木', '火', '土', '金', '水'];
    
    #十二生肖
    def zodiacSign(self):
        return ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];

    #六十甲子, 此为计算
    def sixtyYearCycle(self):
        heaven_ = self.heavenStem();
        earth_ = self.earthStem();

        heavenSize = len(heaven_);
        earthSize = len(earth_);

        cycle = [];
        
        for i in range(60):
            s = heaven_[i%heavenSize]+earth_[i%earthSize];
            cycle.append(s);
        '''
        a = self.sixtyYearCycle();
        for i in range(len(a)):
            print('\''+a[i]+'\',', end = '');
            if i%10==9:
                print('');
        '''
        return cycle;
    
    #六十甲子，此为直接调用
    def sixtyYear(self):
        terms = [
            '甲子','乙丑','丙寅','丁卯','戊辰','己巳','庚午','辛未','壬申','癸酉',
            '甲戌','乙亥','丙子','丁丑','戊寅','己卯','庚辰','辛巳','壬午','癸未',
            '甲申','乙酉','丙戌','丁亥','戊子','己丑','庚寅','辛卯','壬辰','癸巳',
            '甲午','乙未','丙申','丁酉','戊戌','己亥','庚子','辛丑','壬寅','癸卯',
            '甲辰','乙巳','丙午','丁未','戊申','己酉','庚戌','辛亥','壬子','癸丑',
            '甲寅','乙卯','丙辰','丁巳','戊午','己未','庚申','辛酉','壬戌','癸亥'
        ];

        return terms;

    
    #纳音，其作用是将六十甲子和五行进行转化
    def reduceTone(self):
        sequence = ['金', '火', '木', '土',
                    '金', '火', '水', '土',
                    '金', '木', '水', '土',
                    '火', '木', '水']; #'金'

        #纳音的量
        terms = [
            '海中金', '海中金', '炉中火', '炉中火', '大林木', 
            '大林木', '路旁土', '路旁土', '剑锋金', '剑锋金', 
            '山头火', '山头火', '涧下水', '涧下水', '城头土', 
            '城头土', '白蜡金', '白蜡金', '杨柳木', '杨柳木', 
            '泉中水', '泉中水', '屋上土', '屋上土', '霹雳火', 
            '霹雳火', '松柏木', '松柏木', '长流水', '长流水', 
            '砂石金', '砂石金', '山下火', '山下火', '平地木', 
            '平地木', '壁上土', '壁上土', '金薄金', '金薄金', 
            '覆灯火', '覆灯火', '天河水', '天河水', '大驿土', 
            '大驿土', '钗环金', '钗环金', '桑柘木', '桑柘木', 
            '大溪水', '大溪水', '沙中土', '沙中土', '天上火', 
            '天上火', '石榴木', '石榴木', '大海水', '大海水'];
        
        return terms;

    #二十四节气
    def solarTerms(self):
        terms = [
            '立春','雨水','惊蛰','春分','清明','谷雨',
            '立夏','小满','芒种','夏至','小暑','大暑',
            '立秋','处暑','白露','秋分','寒露','霜降',
            '立冬','小雪','大雪','冬至','小寒','大寒'];
        
        return terms;

    #农历月份
    def lunarMonthTerms(self):
        #朔望月的长度为29.5306日
        terms = [
            '正月', '二月', '三月', '四月', '五月', '六月',
            '七月', '八月', '九月', '十月', '冬月', '腊月'
        ];

        return terms;

    #公历月份
    def gregorianMonthTerms(self):
        terms = [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ];

        return terms;

    #星期
    def weekdayNames(self):
        #terms = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; #0-6 从'Sun' -> 'Sat'
        terms = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        return terms;
    

    #数字的中文表示，用于写农历日期
    def numberInChinese(self):
        terms = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',
                 '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '廿十',
                 '廿十一', '廿十二', '廿十三', '廿十四', '廿十五', '廿十六', '廿十七', '廿十八', '廿十九',
                 '三十', '三十一'];
        return terms;

    #基准时间
    def fiducialDayInfo(self):
        #2016年3月20日 12:30:16，农历 2016年二月十二 星期日
        #丙申 辛卯 辛丑 甲午
        info = [#时为24小时制
            #公历 -- 格里高历
            ['Y', 2016], ['M', 3], ['D', 20],
            ['h', 12], ['m', 30], ['s', 16],
            #星期值 0为星期日
            ['W', 0],
            #农历
            ['LY', 2016], ['LM', 2], ['LD', 12], ['JQ', '春分'],
            #四柱
            ['YZ', '丙申'], ['MZ', '辛卯'], ['DZ', '辛丑'], ['HZ', '甲午']];

        return info;

    #建立一个空白的日期，用于填写日期的各项数值
    def newDay(self):
        info = [#时为24小时制
            #公历 -- 格里高历
            ['Y', 0], ['M', 0], ['D', 0],
            ['h', 0], ['m', 0], ['s', 0],
            #星期值 0为星期日
            ['W', 0],
            #农历
            ['LY', 0], ['LM', 0], ['LD', 0], ['JQ', ''],
            #四柱
            ['YZ', ''], ['MZ', ''], ['DZ', ''], ['HZ', '']];

        return info;

    #四柱序号
    #比如给定'甲子', 返回0，给定'乙丑', 返回1，也就是返回六十甲子的序号
    def polarIndex(self, s):
        array = self.sixtyYear();

        for i in range(len(array)):
            if (s == array[i]):
                return i;

        return 0;
            
    #由六十甲子的序转名
    #比如指定1, 返回'乙丑'
    def polarName(self, index):
        array = self.sixtyYear();
        return array[index%60];


    #判断两个日期的前后。
    #输入的是两个格式为[Y, M, D, h, m, s]的时间阵列。
    #日期2 在 日期1 后时返回正值，否则返回负值
    def compareDate(self, array1, array2):
        return self.arrayToJD(array2) - self.arrayToJD(array1);
        
        

    #十九年七闰法计算两个日期间的农历月差
    #十九年235个朔望月总日数为：235×29.5306=6939.6910日
    #十九个回归年总日数为：365.2422×19=6939.6018日
    #比较这两个总日数，相差仅为0.0892日
    #5700年也相差不了一个月，现在只需计算月的差数，应该够用
    #注：这个函数目前并未用到，因为四柱排月不依据农历朔望月而是依据节气
    #   但或许有时会要求知道两个时间之间的朔望月数量，所以保留在此
    def lunarMonthDiffCalc(self, arrayBaseDay, arrayObjectDay):
        #[2015, 12, 7, 18, 53, 19] 和 [2034, 12, 22, 3, 33, 43]的儒略日值分别是
        #
        A = 2457364.287818084; #self.arrayToJD([2015, 12, 7, 18, 53, 19]);
        B = 2464318.6494044648; #self.arrayToJD([2034, 12, 22, 3, 33, 43]);
        C = 6939.6910; #十九年235个朔望月总日数
        D = 235; #235个朔望月
        E = 19; #19年

        jdBaseDay = self.arrayToJD(arrayBaseDay);
        jdObjectDay = self.arrayToJD(arrayObjectDay);

        swaped = False;
        #确保jdObjectDay的时间是在jdBaseDay后面，否则交换一下顺序，
        if (jdBaseDay > jdObjectDay):
            tmp_ = jdBaseDay;
            jdBaseDay = jdObjectDay;
            jdObjectDay = tmp_;
            swaped = True;

        gap1 = gap2 = 0;

        #这段处理是要确保jdBaseDay落在A->B区段内，并且和jdObjectDay的大小关系保持不变
        #而jdObjectDay最多只能比fdBaseDay多一个区间长度，也就是19年范围内
        if (jdBaseDay < A):
            gap1 = math.ceil(abs(A-jdBaseDay)/C);
            jdBaseDay += gap1*C;
        elif (jdBaseDay > B):
            gap1 = math.ceil(abs(B-jdBaseDay)/C);
            jdBaseDay -= gap1*C;

        if (jdObjectDay < jdBaseDay):
            gap2 = math.floor(abs(jdBaseDay-jdObjectDay)/C+0.5);
            jdObjectDay += gap2*C;
        elif (jdObjectDay >= jdBaseDay ):
            if (jdObjectDay > jdBaseDay + C):
                gap2 = -math.floor(abs(jdObjectDay-jdBaseDay)/C+0.5);
                jdObjectDay += gap2*C;
                
                if (jdObjectDay < jdBaseDay):
                    jdObjectDay += C;
                    gap2 += 1;

        

        #与ShuoWangTable(朔望表中的数据进行匹配)
        len_ = len(ShuoWangTable);

        baseYearIndex = objectYearIndex = 0; #以过了正月为年序
        baseMonthIndex = objectMonthIndex = 0; #分别查看月序

        for i in range(len_):
            jd = self.arrayToJD(ShuoWangTable[i][1]);

            if (jdBaseDay > jd):
                if (ShuoWangTable[i][0][-2] == '月'):
                    baseMonthIndex+=1;
                    if (ShuoWangTable[i][0][0] == '正'):
                        baseYearIndex+=1;
            else:
                break;

        for i in range(len_):
            jd = self.arrayToJD(ShuoWangTable[i][1]);

            if (jdObjectDay > jd):
                if (ShuoWangTable[i][0][-2] == '月'):
                    objectMonthIndex+=1;
                    if (ShuoWangTable[i][0][0] == '正'):
                        objectYearIndex+=1;
            else:
                break;

        
        yearGap = -(gap2-gap1)*E+(objectYearIndex-baseYearIndex);
        monthGap = -(gap2-gap1)*D + (objectMonthIndex-baseMonthIndex);

        
        if (swaped == True):
            yearGap = -abs(yearGap);
            monthGap = -(abs(monthGap));
            
        if (0):
            print(gap1, gap2);
            print(yearGap, monthGap);
            print(baseMonthIndex, objectMonthIndex, baseYearIndex, objectYearIndex);        

        #两个日期之间隔的农历年，农历月数
        return [yearGap, monthGap];
    

    #两个日期数组之间相差的日数，
    def dayDiff(self, array1, array2):
        array_1 = [array1[0], array1[1], array1[2], 0, 0, 0];
        array_2 = [array2[0], array2[1], array2[2], 0, 0, 0];
        return math.ceil(self.arrayToJD(array_2) - self.arrayToJD(array_1));
        

    #取得一个日期的所有信息, 这个是主要的显示函数，所有信息都由它处理显示
    #输入日期的字符串格式：'20120303 120000'，代表2012年3月3日，12点0分0秒，小时为24小时制
    def dayInfo(self, day1):
        if (len(day1) <= 8): #可以只给出日期，默认正午时间
            day1 += ' 120000';

        
        
        #基准日期
        #2016年3月20日 12:30:16，农历 2016年二月十二 星期日
        #丙申 辛卯 辛丑 甲午
        day0 = '20160320 123016';

        if (len(day1) != len(day0)): #输入格式不正确，直接返回
            return '';


            
        #取出基准时间信息中的星期与四柱方面的数据
        info0 = [#时为24小时制
            #公历 -- 格里高历
            ['Y', 2016], ['M', 3], ['D', 20],
            ['h', 12], ['m', 30], ['s', 16],
            #星期值 0为星期日
            ['W', 0],
            #农历
            ['LY', 2016], ['LM', 2], ['LD', 12], ['JQ', '春分'],
            #四柱
            ['YZ', '丙申'], ['MZ', '辛卯'], ['DZ', '辛丑'], ['HZ', '甲午']];
        
        for i in range(len(info0)):
            if (info0[i][0] == 'W'):
                W0 = info0[i][1];
            elif (info0[i][0] == 'YZ'): #年柱
                YZ0 = info0[i][1];
            elif (info0[i][0] == 'MZ'): #月柱
                MZ0 = info0[i][1];
            elif (info0[i][0] == 'DZ'): #日柱
                DZ0 = info0[i][1];
            elif (info0[i][0] == 'HZ'): #时柱
                HZ0 = info0[i][1];           

        #设置基准日期
        self.setFromStr(day0);
        #基准日期时间阵列，备用
        array0 = self.toArray();
        print('基准日期阵列：', array0);
        #基准日期儒略日
        jd0 = self.toJD(True);
        print('基准日期儒略日：', jd0);

        #设置目标日期
        self.setFromStr(day1);
        #目标日期时间阵列，备用
        array1 = self.toArray();
        print('目标日期阵列：', array1);
        #目标日期儒略日
        jd1 = self.toJD(True);
        print('目标日期儒略日：', jd1);

        #儒略日差异
        deltaDay = jd1-jd0;
        deltaHour = deltaDay*24;
        print('目标日期与基准日期(2016年3月20日 12:30:16，农历 2016年二月十二 星期日)之间\n儒略日差：', deltaDay, ', 小时差：', deltaHour);


        #目标年的年节气和农历月表
        paiYueTable = self.paiYueCalc(array1[0]);
        print('');
        self.paiYue(array1[0]);
        #print(paiYueTable);

        #节气与农历值
        jieqiValue = '';
        jieqiIndex = 0;
        newYearStart = 0; #规定从'立春'起算，遍历遇到立春设置start = 1，后续节气才可递加
        #年值，不到正月初一算0, 过了正月初一算1
        nianValue = 0;
        #月值
        yueValue = '';
        
        #日值，算农历月中的日数
        riValue = 0;
        #农历某个月的起始时刻暂存处
        yueArray = [];


        #四柱，下面的参数暂时未用到
        #年柱，四柱的年以交立春节气起算，这点和农历算法有差
        nianValue_2 = 0;
        #月柱
        yueValue_2 = 0;        
        

        #遍历当年的节气交节表求信息
        for i in range(len(paiYueTable)):
            jd = self.arrayToJD(paiYueTable[i][1]);

            if (jd1 > jd):
                if (paiYueTable[i][0][-2] == '月'):
                    yueArray = paiYueTable[i][1];
                    yueValue = paiYueTable[i][0];
                    if (paiYueTable[i][0][0] == '正'):
                        nianValue+=1; #如果没到正月，会减去一年的。有时虽然公历新年了，但农历还是旧年的。

                else:
                    if (paiYueTable[i][0] == '立春'):
                        newYearStart = 1;
                    if (newYearStart == 1):
                        jieqiIndex += 1; #立春 = 1, 雨水 = 2，此后类推，用于计算月柱
                    jieqiValue = paiYueTable[i][0]; #把节气取出来
            else:
                break;

        
        #年柱和月柱的差值        
        if (jd1 > jd0): #目标日期在基准日期后， 可以说是未来的时间
            if (newYearStart == 1): #新年了                        
                YZDiff = array1[0]- array0[0];
            else:
                YZDiff = array1[0]- array0[0] - 1;
            MZDiff = (jieqiIndex)//2+12*YZDiff;
            MZDiff -= 2; #基准日的'春分'是第二个月
        else: #目标日期在基准日期前，也就是过去的时间
            if (newYearStart == 1): #新年了                        
                YZDiff = array1[0]- array0[0];
            else:
                YZDiff = array1[0]- array0[0] - 1;
            MZDiff = MZDiff = (jieqiIndex)//2+12*YZDiff;
            MZDiff -= 2; #基准日的'春分'是第二个月
            
            
        print('目标日期与基准日期(2016年3月20日 12:30:16，农历 2016年二月十二 星期日)之间\n相差 {0} 年， 精确到月(节气月）是 {1} 月。'
              .format(YZDiff, MZDiff));
        
        #日柱和时柱的差值
        DZDiff, HZDiff = math.floor(deltaDay+0.5), math.floor(deltaHour/2+0.5);        

        #下面是目标日的信息
        #时间，这是输入的公历部分
        Y_1, M_1, D_1, h_1, m_1, s_1 = array1[0], array1[1], array1[2], array1[3], array1[4], array1[5];

        #星期
        W_1 = (W0+DZDiff)%7;

        #四柱
        YZ_1 = self.polarName((self.polarIndex(YZ0)+YZDiff%60)%60);
        MZ_1 = self.polarName((self.polarIndex(MZ0)+MZDiff%60)%60);
        DZ_1 = self.polarName((self.polarIndex(DZ0)+DZDiff%60)%60);
        HZ_1 = self.polarName((self.polarIndex(HZ0)+HZDiff%60)%60);

        #农历年，月， 日，节气
        lunarY_1 = array1[0]-1+nianValue;
        lunarM_1 = yueValue;
        lunarD_1 = self.dayDiff(yueArray, array1);
        lunarJieqi_1 = jieqiValue;

        #把信息写全
        info_1 = self.newDay();
        for i in range(len(info_1)):
            if (info_1[i][0] == 'Y'):
                info_1[i][1] = Y_1;
            elif (info_1[i][0] == 'M'):
                info_1[i][1] = M_1;            
            elif (info_1[i][0] == 'D'):
                info_1[i][1] = D_1;
            elif (info_1[i][0] == 'h'):
                info_1[i][1] = h_1;
            elif (info_1[i][0] == 'm'):
                info_1[i][1] = m_1;
            elif (info_1[i][0] == 's'):
                info_1[i][1] = s_1;
            elif (info_1[i][0] == 'W'):
                info_1[i][1] = W_1;
            elif (info_1[i][0] == 'LY'):
                info_1[i][1] = lunarY_1;
            elif (info_1[i][0] == 'LM'):
                info_1[i][1] = lunarM_1;
            elif (info_1[i][0] == 'LD'):
                info_1[i][1] = lunarD_1;
            elif (info_1[i][0] == 'JQ'):
                info_1[i][1] = lunarJieqi_1;
            elif (info_1[i][0] == 'YZ'):
                info_1[i][1] = YZ_1;
            elif (info_1[i][0] == 'MZ'):
                info_1[i][1] = MZ_1;
            elif (info_1[i][0] == 'DZ'):
                info_1[i][1] = DZ_1;
            elif (info_1[i][0] == 'HZ'):
                info_1[i][1] = HZ_1;

        #print(info_1);

        #或许需要一种更容易看懂的信息显示方式
        infoOfDay = '';
        print('');
        for i in range(len(info_1)):
            if (info_1[i][0] == 'Y'):
                infoOfDay += '星历'+str(info_1[i][1])+'年';
            elif (info_1[i][0] == 'M'):
                infoOfDay += ('0'+str(info_1[i][1]))[-2:]+'月';            
            elif (info_1[i][0] == 'D'):
                infoOfDay += ('0'+str(info_1[i][1]))[-2:]+'日 ';
            elif (info_1[i][0] == 'h'):
                infoOfDay += ('0'+str(info_1[i][1]))[-2:]+':';
            elif (info_1[i][0] == 'm'):
                infoOfDay += ('0'+str(info_1[i][1]))[-2:]+':';
            elif (info_1[i][0] == 's'):
                infoOfDay += ('0'+str(info_1[i][1]))[-2:]+'， ';
            elif (info_1[i][0] == 'W'):
                terms = self.weekdayNames();
                infoOfDay += terms[info_1[i][1]]+'，\n';
            elif (info_1[i][0] == 'LY'):
                infoOfDay += '农历' + str(info_1[i][1])+'年';
            elif (info_1[i][0] == 'LM'):
                infoOfDay += info_1[i][1]+ '，';
            elif (info_1[i][0] == 'LD'):
                terms = self.numberInChinese();
                infoOfDay += '第'+terms[info_1[i][1]]+'日， ';
            elif (info_1[i][0] == 'JQ'):
                infoOfDay += '节气：'+info_1[i][1]+ '\n';
            elif (info_1[i][0] == 'YZ'):
                infoOfDay += '四柱是：' + info_1[i][1]+' ';
            elif (info_1[i][0] == 'MZ'):
                infoOfDay += info_1[i][1]+' ';
            elif (info_1[i][0] == 'DZ'):
                infoOfDay += info_1[i][1]+' ';
            elif (info_1[i][0] == 'HZ'):
                infoOfDay += info_1[i][1];
        
        print(infoOfDay);

        return info_1; #信息阵列
        
    
    #写一个十九年轮回的朔望排盘
    def printTest_1(self):
        print('写文件开始。>>>');
        N = 2016;

        fout = open('input.txt', 'w');

        for i in range(N, N+38):
            result = self.paiYueCalc(i);

            for j in range(len(result)):
                fout.write(str(result[j]));
                fout.write(',\n');

        fout.close();
        print('写文件结束。');

        

    def printTest(self):
        a = [2001, 5, 20, 10, 0, 0];
        b = [1985, 12, 10, 20, 0, 5];
        
        #d = self.dayInfo('20140223 083700')
        #d = self.dayInfo('20441223 083700')
        #d = self.dayInfo('19441223 083700')
        #d = self.dayInfo('20930223 083700')
        #d = self.dayInfo('18020610 103700')
        # d = self.dayInfo('20180209 155050') # 传入时间  time.strftime("%Y%m%d %H%M%S", time.localtime()) 
        d = self.dayInfo(time.strftime("%Y%m%d %H%M%S", time.localtime())) 


def tmp():
    cal = Calendar();
    cal.printTest();

    
if __name__ == '__main__':
    tmp();      