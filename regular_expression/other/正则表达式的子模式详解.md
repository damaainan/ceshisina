## 正则表达式的子模式详解

来源：[http://www.cnblogs.com/hongfei/archive/2012/06/23/2559210.html](http://www.cnblogs.com/hongfei/archive/2012/06/23/2559210.html)

2012-06-23 11:28

首先，我们先看一段PHP代码：


```php
<?php
    $time = date ("Y-m-d H:i:s");
    $pattern = "/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/i"; 
    if(preg_match($pattern,$time,$arr)){
    print_r($arr);        
    }
?>
```



显示结果：


```
Array
(
    [0] => 2012-06-23 03:08:45
)
```



有没有注意到，显示的结果只有一条数据，即符合匹配模式的时间格式，那如果只有一条记录的话，为什么还要用数组保存呢？直接使用字符串保存不是更好？

带着这个问题，我们来看下正则表达式中的子模式。

在正则表达式中，可以使用“(”和“)”将模式中的子字符串括起来，以形成一个子模式。将子模式视为一个整体时，那么它就相当于一个单个字符。

比如，我们将以上的代码稍微修改下，改成如下：

 


```php
<?php
    $time = date ("Y-m-d H:i:s");
    $pattern = "/(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/i"; 
    if(preg_match($pattern,$time,$arr)){
    print_r($arr);        
    }
?>
```



注意：我只修改了$pattern，在匹配模式中，使用了括号()

执行结果：


```
Array
(
    [0] => 2012-06-23 03:19:23
    [1] => 2012
    [2] => 06
    [3] => 23
    [4] => 03
    [5] => 19
    [6] => 23
)
```



```
总结：我们可以使用小括号给整个匹配模式进行分组，默认情况下，每个分组会自动拥有一个组号，规则是，从左到右，以分组的左括号为标志，第一个出现的分组为组号1，第二个为组号2，以此类推。其中，分组0对应整个正则表达式。对整个正则匹配模式进行了分组以后，就可以进一步使用“向后引用”来重复搜索前面的某个分组匹配的文本。例如：\1代表分组1匹配的文本，\2代表分组2匹配的文本等等我们可以进一步修改下代码，如下所示：
```


```php
<?php
    $time = date ("Y-m-d H:i:s");
    $pattern = "/(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/i";
    $replacement = "\$time格式为：$0<BR>替换后的格式为：\\1年\\2月\\3日 \\4时\\5分\\6秒";
    print preg_replace($pattern, $replacement, $time);
    if(preg_match($pattern,$time,$arr)){
        print_r($arr);        
    }
?>
```



 

注意：


* 因为是在双引号中，所以使用分组的时候应该使用两个反斜杠，如:\\1，而如果在单引号中，则使用一个反斜杠就可以了，如：\1
* \\1用于捕获分组一种的内容：2012，\\6用于捕获分组6中的内容　　　　　　　　　　


执行结果：


```
$time格式为：2012-06-23 03:30:31
替换后的格式为：2012年06月23日 03时30分31秒
Array
(
    [0] => 2012-06-23 03:30:31
    [1] => 2012
    [2] => 06
    [3] => 23
    [4] => 03
    [5] => 30
    [6] => 31
)
```
