# 正则表达式详解

创建时间:2016-10-04 09:41

 字数:4,610  

1. [本文目标][2]
1. [简介及语法][3]
    1. [正则表达式是什么][4]
    1. [常用元字符][5]
    1. [字符转义][6]
    1. [重复][7]
    1. [字符类][8]
    1. [分支条件][9]
    1. [分组][10]
    1. [反义][11]
    1. [后向引用][12]
    1. [零宽断言][13]
    1. [负向零宽断言][14]
    1. [注释][15]
    1. [贪婪与懒惰][16]
    1. [其他元字符][17]

1. [正则表达式常用实例][18]
    1. [账号/密码][19]
    1. [字符串校验][20]
    1. [手机号][21]
    1. [IP地址][22]
    1. [EMAIL地址][23]
    1. [域名][24]
    1. [身份证][25]
    1. [数字类校验][26]

## 本文目标

> 本文旨在更加简洁清晰的展现正则表达式，  第一部分  是对正则表达式语法的简洁介绍，  第二部分  则是常用正则表达式的示例。

## 简介及语法

### 正则表达式是什么

> 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

> 正则表达式语言由两种基本字符类型组成：原义（正常） 文本字符 和 元字符 。元字符使正则表达式具有处理能力。

### 常用元字符

元字符 | 做什么用 
-|-
`.` | 匹配除换行符以外的任意字符 
`\w` | 匹配字母或数字或下划线或汉字 
`\s` | 匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等） 
`\d` | 匹配数字 
`\b` | 匹配单词的开始或结束 
`^` | 匹配字符串的开始 
`$` | 匹配字符串的结束 

### 字符转义

> 如果你想查找元字符本身的话，比如你查找 `.` ,或者 `*` ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 `\` 来取消这些字符的特殊意义。因此，你应该使用 `\.` 和 `\*` 。当然，要查找 `\` 本身，你也得用 `\\` .  
例如： `deerchao\.net` 匹配 **`deerchao.net`**，`C:\\Windows` 匹配 **`C:\Windows`** 。

### 重复

> 你已经看过了前面的 `*` , `+` , `{2}` , `{5,12}` 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)

元字符 | 做什么用 
-|-
`*` | 重复零次或更多次 
`+` | 重复一次或更多次 
`?` | 重复零次或一次 
`{n}` | 重复n次 
`{n,}` | 重复n次或更多次 
`{n,m}` | 重复n到m次 

> 下面是一些重复的示例：  `Windows\d+` 匹配Windows后面跟1个或更多数字  `^\w+` 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)

### 字符类

> 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？  

> 很简单，你只需要在方括号里列出它们就行了，像 `[aeiou]` 就匹配任何一个英文元音字母， `[.?!]` 匹配标点符号(.或?或!)。  
我们也可以轻松地指定一个字符范围，像 `[0-9]` 代表的含意与 `\d` 就是完全一致的：一位数字；同理`[a-z0-9A-Z_]`也完全等同于 `\w` （如果只考虑英文的话）。  

> 下面是一个更复杂的表达式： `\(?0\d{2}[) -]?\d{8}` 。  
> 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。

### 分支条件

> 正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。  
> 示例： `0\d{2}-\d{8}|0\d{3}-\d{7}`  
> 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。  
> 示例： `\d{5}-\d{4}|\d{5}`  
> 这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：** 使用分枝条件时，要注意各个条件的顺序** 。如果你把它改成 `\d{5}|\d{5}-\d{4}`  的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

### 分组

> 重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 **子表达式**(也叫作**分组**)。  
`(\d{1,3}\.){3}\d{1,3}` 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： `\d{1,3}` 匹配1到3位的数字， `(\d{1,3}\.){3}` 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 `(\d{1,3})` 。  
> 不幸的是，它也将匹配 _256.300.888.999_ 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 **正确的IP地址：**`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

### 反义

> 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：

元字符 | 做什么用 
-|-
`\W` |  匹配任意不是字母，数字，下划线，汉字的字符 
`\S` |  匹配任意不是空白符的字符 
`\D` |  匹配任意非数字的字符 
`\B` |  匹配不是单词开头或结束的位置 
`[^x]` |  匹配除了x以外的任意字符 
`[^aeiou]` |  匹配除了aeiou这几个字母以外的任意字符 

> 示例： `\S+` 匹配不包含空白符的字符串。 `<a[^>]+>` 匹配用尖括号括起来的以a开头的字符串。

### 后向引用

> 使用小括号指定一个子表达式后，**匹配这个子表达式** 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 **组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。  
**后向引用** 用于重复搜索前面某个分组匹配的文本。  
> 示例： `\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 `\b(\w+)\b` ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符`\s+`，最后是分组1中捕获的内容（也就是前面匹配的那个单词） `\1` 。  
> 你也可以自己指定子表达式的 **组名**.要指定一个子表达式的组名，请使用这样的语法： `(?<Word>\w+)` (或者把尖括号换成 `'` 也行： `(?'Word'\w+))`,这样就把`\w+`的组名指定为 **Word** 了。要反向引用这个分组捕获的内容，你可以使用 `\k<Word>` ,所以上一个示例也可以写成这样： `\b(?<Word>\w+)\b\s+\k<Word>\b` 。

### 零宽断言

> 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 **零宽断言**。  
`(?=exp)` 也叫 **零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 _`I’m singing while you’re dancing._` 时，它会匹配 sing 和 danc 。  
`(?<=exp)` 也叫 **零宽度正回顾后发断言** ，它断言自身出现的位置的前面能匹配表达式exp。比如 `(?<=\bre)\w+\b` 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 _`reading a book_` 时，它匹配ading。  
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： `((?<=\d)\d{3})+\b` ，用它对1234567890进行查找时结果是234567890。  
下面这个示例同时使用了这两种断言： `(?<=\s)\d+(?=\s)` 匹配以空白符间隔的数字( **再次强调，不包括这些空白符** )。

### 负向零宽断言

> 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：  
`\b\w*q[^u]\w*\b` 匹配 _`包含后面不是字母u的字母q的单词_` 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 `\w*\b` 将会匹配下一个单词，于是 `\b\w*q[^u]\w*\b` 就能匹配整个Iraq fighting。**负向零宽断言** 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： `\b\w*q(?!u)\w*\b` 。  
**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。例如： `\d{3}(?!\d)` 匹配三位数字，而且这三位数字的后面不能是数字； `\b((?!abc)\w)+\b` 匹配不包含连续字符串abc的单词。  
> 同理，我们可以用`(?<!exp)`,**零宽度负回顾后发断言来断言** 此位置的前面不能匹配表达式exp：`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。  
> 一个更复杂的示例：`(?<=<(\w+)>).*(?=<\/\1>)` 匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)` 指定了这样的 **前缀**：被尖括号括起来的单词(比如可能是**)，然后是. `*` (任意的字符串),最后是一个 **后缀** `(?=<\/\1>)`。注意后缀里的 \/ ，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的 `(\w+)` 匹配的内容，这样如果前缀实际上是**的话，后缀就是**了。整个表达式匹配的是**和**之间的内容(再次提醒，不包括前缀和后缀本身)。**

### 注释

> 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。  
> 要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：  
`(?<=` # 断言要匹配的文本的前缀  
`<(\w+)>` # 查找尖括号括起来的字母或数字(即HTML/XML标签)  
`)` # 前缀结束  
`.*` # 匹配任意文本  
`(?=` # 断言要匹配的文本的后缀  
`<\/\1>` # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签  
`)` # 后缀结束

### 贪婪与懒惰

> 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 **尽可能多** 的字符。以这个表达式为例： `a.*b` ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 **贪婪匹配**。  
> 有时，我们更需要 **懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 `.*?` 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。  
> 示例： `a.*?b` 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

语法 | 做什么用 
-|-
`*?` |  重复任意次，但尽可能少重复 
`+?` |  重复1次或更多次，但尽可能少重复 
`??` |  重复0次或1次，但尽可能少重复 
`{n,m}?` |  重复n到m次，但尽可能少重复 
`{n,}?` |  重复n次以上，但尽可能少重复 

### 其他元字符

元字符 | 做什么用 
-|-
`\a` | 报警字符(打印它的效果是电脑嘀一声) 
`\b` | 通常是单词分界位置，但如果在字符类里使用代表退格 
`\t` | 制表符，Tab 
`\r` | 回车 
`\v` | 竖向制表符 
`\f` | 换页符 
`\n` | 换行符 
`\e` | Escape 
`\0nn` | ASCII代码中八进制代码为nn的字符 
`\xnn` | ASCII代码中十六进制代码为nn的字符 
`\unnnn` | Unicode代码中十六进制代码为nnnn的字符 
`\cN` | ASCII控制字符。比如\cC代表Ctrl+C 
`\A` | 字符串开头(类似^，但不受处理多行选项的影响) 
`\Z` | 字符串结尾或行尾(不受处理多行选项的影响) 
`\z` | 字符串结尾(类似$，但不受处理多行选项的影响) 
`\G` | 当前搜索的开头 
`\p{name}` | Unicode中命名为name的字符类，例如\p{IsGreek} 
`(?>exp)` | 贪婪子表达式 
`(?<x>-<y>exp)` | 平衡组 
`(?im-nsx:exp)` | 在子表达式exp中改变处理选项 
`(?im-nsx)` | 为表达式后面的部分改变处理选项 
`[1]` | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no 
`(?(exp)yes)` | 同上，只是使用空表达式作为no 
`[2]` | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no 
`(?(name)yes)` | 同上，只是使用空表达式作为no 

> `[1]`:`(?(exp)yes|no)`  
> `[2]`:`(?(name)yes|no)`

## 正则表达式常用实例

### 账号/密码

    帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = "^[a-zA-Z][a-zA-Z0-9_]{4,15}$"
    密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = "^[a-zA-Z]\w{5,17}$"
    强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = "^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$"
    

### 字符串校验

    汉字 = "^[\u4e00-\u9fa5]{0,}$";
    英文和数字 = "^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$";
    长度为3-20的所有字符 = "^.{3,20}$"；
    由26个英文字母组成的字符串 = "^[A-Za-z]+$"；
    由26个大写英文字母组成的字符串 = "^[A-Z]+$"；
    由26个小写英文字母组成的字符串 = "^[a-z]+$"；
    由数字和26个英文字母组成的字符串 = "^[A-Za-z0-9]+$"；
    由数字、26个英文字母或者下划线组成的字符串 = "^\w+$ 或 ^\w{3,20}$"；
    中文、英文、数字包括下划线 = "^[\u4E00-\u9FA5A-Za-z0-9_]+$"；
    中文、英文、数字但不包括下划线等符号 = "^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$"；
    禁止输入含有~的字符 = "[^~\x22]+"；
    

### 手机号

    /**
     * 手机号码
     * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188
     * 联通：130,131,132,145,152,155,156,1709,171,176,185,186
     * 电信：133,134,153,1700,177,180,181,189
     */
    String MOBILE = "^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\d{8}$";
    /**
     * 中国移动：China Mobile
     * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188
     */
    String CM = "^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\d{8}$";
    /**
     * 中国联通：China Unicom
     * 130,131,132,145,152,155,156,1709,171,176,185,186
     */
    String CU = "^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\d{8}$";
    /**
     * 中国电信：China Telecom
     * 133,134,153,1700,177,180,181,189
     */
    String CT = "^1(3[34]|53|77|700|8[019])\\d{8}$";
    

### IP地址

    String IPREGEXP = "((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)";
    

### EMAIL地址

    Email地址 = "^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$";
    

### 域名

    域名 = "[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?";
    InternetURL = "[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$"
    

### 身份证

    身份证号(15位、18位数字) = "^\d{15}|\d{18}$"
    短身份证号码(数字、字母x结尾) = "^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$"
    

### 数字类校验

    数字 = "^[0-9]*$";
    n位的数字 = "^\d{n}$";
    至少n位的数字 = "^\d{n,}$";
    m-n位的数字 = "^\d{m,n}$";
    零和非零开头的数字 = "^(0|[1-9][0-9]*)$";
    非零开头的最多带两位小数的数字 = "^([1-9][0-9]*)+(.[0-9]{1,2})?$";
    带1-2位小数的正数或负数 = "^(\-)?\d+(\.\d{1,2})?$";
    正数、负数、和小数 = "^(\-|\+)?\d+(\.\d+)?$";
    有两位小数的正实数 = "^[0-9]+(.[0-9]{2})?$";
    有1~3位小数的正实数 = "^[0-9]+(.[0-9]{1,3})?$";
    非零的正整数 = "^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$";
    非零的负整数 = "^\-[1-9][]0-9"*$" 或 "^-[1-9]\d*$";

