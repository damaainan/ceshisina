## 对递归和迭代的效率的思考和分析

来源：[https://segmentfault.com/a/1190000013768219](https://segmentfault.com/a/1190000013768219)


## 问题

斐波那契数列的计算：有如下一个数列：1，1, 2, 3, 5, 8, 13, 21，....... 其规则是：前两个已知（即1和2），从第3个开始，其值为其左边两个值的和（此数列称为斐波那契数列）。定义一个函数，该函数可以求出该数列的任意第n个数的值。
## 递归思想来解决：



* 递归的本质：函数在其内部调用自身

* 解决问题时可以将其分拆成若干个小步骤，大问题的解决方法与小步骤方法一致，定义求问题的函数，在需要的位置调用函数即可。


```php
function fibonacci($n){
  //找出口：什么时候结束递归的调用
  if($n==! || $n==2) return 1;
  
  //计算其他项
  //找入口：什么时候开始递归调用
  return fibonacci($n-1)+fibonacci($n-2);
  
  /**思考
  *return是否可以使用echo替换
  *不可以，因为return  结束函数的调用
  *需要返会给下次递归调用使用
  **/
}
$start=microtime(true);//开始计时
echo fibonacci(35);
$end=microtime(true);//函数调用结束在计时
echo '计算耗时'.($end-$start).'秒';//4.9秒
//递归每次调用时，没有立即结束函数的调用，内存没有释放，等到后面计算出结果，才从后面开始释放内存
```

思考问题：
1.递归：



* 找入口：

* 找出口：


2.return是否可以使用echo替换



* 不可以   return结束函数的调用

* 需要返回给下次递归调用使用


## 迭代思想来解决

```php
function fibonacci($n){
  
  if($n==1 ||$n==2) return 1;
  
  //其他项
  //第三项-->
  //假设求第七项，从第三项考试逐个计算
  //本次计算作为下次计算的条件使用
  
  //定义初始条件
  //前两项作为基本条件
  $first=1;
  $secont=2;
  
  for($i=3;$i<=$n;$i++){
    //之间两项之和
    $res=$first+$second;
    //为后续计算做准备
    //下次计算的第一项来自本次计算计算的第二项
    $first=$second;
    //下次计算的第二项来自本次计算的结果
    $second=$res;
  }
  //循环结束   得到结果
  return $res;
}
$start=microtime(true);
echo fibonacci(135);
$end=microtime(true);
echo '计算耗时：'.($end-$start);//4.315秒，比递归效率高几千万倍
```

结论：迭代的运行效率比递归高很多，能用迭代解决就别用递归，也就是说先考虑迭代再考虑递归。
