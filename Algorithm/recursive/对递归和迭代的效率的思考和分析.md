## 对递归和迭代的效率的思考和分析

来源：[https://segmentfault.com/a/1190000013768219](https://segmentfault.com/a/1190000013768219)


## 问题

斐波那契数列的计算：有如下一个数列：1，1, 2, 3, 5, 8, 13, 21，....... 其规则是：前两个已知（即1和2），从第3个开始，其值为其左边两个值的和（此数列称为斐波那契数列）。定义一个函数，该函数可以求出该数列的任意第n个数的值。
## 递归思想来解决：



* 递归的本质：函数在其内部调用自身

* 解决问题时可以将其分拆成若干个小步骤，大问题的解决方法与小步骤方法一致，定义求问题的函数，在需要的位置调用函数即可。


```php
    function fibonacci($n){
      //找出口：什么时候结束递归的调用
      if($n==! || $n==2) return 1;
      
      //计算其他项
      //找入口：什么时候开始递归调用
      return fibonacci($n-1)+fibonacci($n-2);
      
      /**思考
      *return是否可以使用echo替换
      *不可以，因为return  结束函数的调用
      *需要返会给下次递归调用使用
      **/
    }
    $start=microtime(true);//开始计时
    echo fibonacci(35);
    $end=microtime(true);//函数调用结束在计时
    echo '计算耗时'.($end-$start).'秒';//4.9秒
    //递归每次调用时，没有立即结束函数的调用，内存没有释放，等到后面计算出结果，才从后面开始释放内存
```

思考问题：
1.递归：



* 找入口：

* 找出口：


2.return是否可以使用echo替换



* 不可以   return结束函数的调用

* 需要返回给下次递归调用使用


## 迭代思想来解决

```php
    function fibonacci($n){
      
      if($n==1 ||$n==2) return 1;
      
      //其他项
      //第三项-->
      //假设求第七项，从第三项考试逐个计算
      //本次计算作为下次计算的条件使用
      
      //定义初始条件
      //前两项作为基本条件
      $first=1;
      $secont=2;
      
      for($i=3;$i<=$n;$i++){
        //之间两项之和
        $res=$first+$second;
        //为后续计算做准备
        //下次计算的第一项来自本次计算计算的第二项
        $first=$second;
        //下次计算的第二项来自本次计算的结果
        $second=$res;
      }
      //循环结束   得到结果
      return $res;
    }
$start=microtime(true);
echo fibonacci(135);
$end=microtime(true);
echo '计算耗时：'.($end-$start);//4.315秒，比递归效率高几千万倍
```

结论：迭代的运行效率比递归高很多，能用迭代解决就别用递归，也就是说先考虑迭代再考虑递归。
