<?php

/**

问题描述
这个问题是在实在瞎逛的时候碰到的，具体哪里记不太清了。

1   1   1   1
0   1   0   1
0   1   0   1
0   1   1   1

上面是一个迷宫，左上角是入口，右下角是出口，小萌(对，你没看错，是长了草的小明)从入口进入，从出口逃出(1个小时逃不出会被X怪物吃掉)，其中1表示可以通行，0表示不能通行，只能向右和向下两个方向走，求出所有的小萌可能逃生的路线。
这个问题看似挺简单，一下就可以看到答案，但是将思想翻译为代码却不知道从何入手了。

如何解决

解决这个问题的一种方案就是回溯法，先一起看看回溯法(百度百科)的定义：
回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

我的思路：

1. 对上面的迷宫进行坐标化，左上角是(0,0)，右下角是(3,3)，其他点分散在坐标系中
2. 从(0,0)开始
3. 从给定的坐标点开始，先向右搜索，是1的话继续，是0的话向下搜索，搜索前记录当前已经搜索过的坐标
4. 当坐标等于(3,3)的时候就是一个回溯点了，这个时候也返回
5. 只要不越界，重复第三步骤

 */

$nums = [
    [1, 1, 1, 1, 1, 1],
    [0, 1, 0, 1, 0, 1],
    [0, 1, 0, 1, 0, 1],
    [0, 1, 1, 1, 1, 1],
];
function getRet($data, $x, $y, &$result = [], $record)
{
    $snapshort = [];
    $xL        = count($data) - 1;
    $yL        = count($data[0]) - 1;
    if ($x > $xL || $y > $yL) {
        //跑到迷宫不存在的空间了，这种事情绝对不能发生
        return;
    }
    if ($data[$x][$y] == "0") {
        //是0的话停止继续前进，退回上一状态
        return;
    } elseif ($data[$x][$y] == "1") {
        //是1的话，记录最新的坐标到当前已找到的路径中，继续向前搜索
        //如果到达出口，记录答案并回溯
        $snapshort = array_merge($record, [[$x, $y]]); // 
        if ($x == $xL && $y == $yL) { //
            $result[] = array_merge($record, [[$x, $y]]);
            return;
        }
    } else {
        return;
    }
    //向右搜索
    //这里的$snapshort保存当前搜索位置的状态，等到下次回溯到这里的时候会用到
    getRet($data, $x, ++$y, $result, $snapshort);
    //向下搜索
    getRet($data, ++$x, --$y, $result, $snapshort);
}
//看个例子
$result = [];
getRet($nums, 0, 0, $result, []);
foreach ($result as $pos) {
    foreach ($pos as $xy) {
        echo "({$xy[0]},{$xy[1]}) => ";
    }
    echo "end\n";
}
