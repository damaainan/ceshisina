## 排序算法

<font face=黑体>

所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。

算法复杂度分为时间复杂度和空间复杂度。**其作用：时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间**。

## 时间频度

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且每个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

## 时间复杂度

在时间频度中，**n**称为问题的规模，当 **n**不断变化时，时间频度 **T(n)**也会不断变化。但有时我们想知道它变化时呈现什么规律，为此，我们引入时间复杂度概念。一般情况下，算法中基本操作重复执行的次数是问题规模 **n**的某个函数，用 **T(n)**表示，若有某个辅助函数 **f(n)**，使得当 **n**趋近于无穷大时，**T(n) / f(n)**的极限值为不等于零的常数，则称**f(n)**是**T(n)**的同数量级函数。记作**T(n) = O( f(n) )**，称**O( f(n) )**为算法的渐进时间复杂度，简称时间复杂度。

在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 **T(n)**的同数量级（它的同数量级有以下：1，log<sub>2</sub>n, n, nlog<sub>2</sub>n, n<sup>2</sup>，n<sup>3</sup>，2n，n!），找出后，**f(n)** = 该数量级，若 **T(n) / f(n)**求极限可得到一常数**c**，则时间复杂度**T(n) = O( f(n) )**。

**计算方法：**

【1】如果算法的执行时间不随着问题规模 **n**的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是 **O(1)**。

    $x = 91;
    $y = 100;
    while( $y > 0 )
    {
        if( $x > 100 ) {
            $x = $x - 10;
        $y = $y - 1;
        } else {
            $x ++;
        }
    }

这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到**n**没有？没，这个程序的运行是和**n**无关的。就算它再循环一万年，我们也不管他，只是一个常数阶的函数。

【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层频度**f(n)**决定的。

    $x = 1;
    for($i = 1; $i <= $n; $i ++)
    {
        for($j = 1; $j <= $i; $j ++)
        {
        for($k = 1; $k <= $j; $k ++)
        {
                $x ++; // 语句(5)
        }
        }
    }

该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模 **n**没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数；则该程序段的时间复杂度为 **T(n) = O(n3 / 6 + 低次项) = O(n3)**。

## 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分：

a )、固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

b )、可变空间。这部分空间主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用 **f(n)**表示。**S(n) = O( f(n) )** 其中 **n**为问题的规模，**S(n)** 表示空间复杂度。

## 分类

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：

![20170122083248_9.png][0]

## 文章目录

<font face=楷体>

[冒泡排序][1][http://www.yduba.com/biancheng-3962519476.html][1]

[选择排序][2][http://www.yduba.com/biancheng-4732577282.html][2]

[插入排序][3][http://www.yduba.com/biancheng-2892530909.html][3]

[希尔排序][4][http://www.yduba.com/biancheng-5472542087.html][4]

[归并排序][5][http://www.yduba.com/biancheng-9902519493.html][5]

[快速排序][6][http://www.yduba.com/biancheng-0362533007.html][6]

[堆排序][7][http://www.yduba.com/biancheng-4622548289.html][7]

[计算排序][8][http://www.yduba.com/biancheng-1362548964.html][8]

[桶排序][9][http://www.yduba.com/biancheng-7382573665.html][9]

[基数排序][10][http://www.yduba.com/biancheng-6212544194.html][10]

</font>
</font>

[0]: ./img/1485350382367553.png
[1]: http://www.yduba.com/biancheng-3962519476.html
[2]: http://www.yduba.com/biancheng-4732577282.html
[3]: http://www.yduba.com/biancheng-2892530909.html
[4]: http://www.yduba.com/biancheng-5472542087.html
[5]: http://www.yduba.com/biancheng-9902519493.html
[6]: http://www.yduba.com/biancheng-0362533007.html
[7]: http://www.yduba.com/biancheng-4622548289.html
[8]: http://www.yduba.com/biancheng-1362548964.html
[9]: http://www.yduba.com/biancheng-7382573665.html
[10]: http://www.yduba.com/biancheng-6212544194.html