## 十大经典排序算法PHP实现教程（选择排序）
<font face=微软雅黑>


选择排序是一种简单直接的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移动到其最终位置上，因此对 **n**个元素进行排序总共进行至多 **n-1**次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于好的一种。

## 算法步骤

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

## 效率分析

在选择排序中，共需要进行 **n-1**次选择和交换，每次选择需要进行 **n-i** 次比较(**1 <= i <= n-1**)，而每次交换最多需要3次移动，因此，总的比较次数 **C = n (n - 1) / 2**。

交换次数为 **O(n)**，最好情况是，已经有序，交换 **0**次；最坏情况是，逆序，交换 **n-1**次。交换次数比冒泡排序较少，由于交换所需CPU时间比冒泡排序所需的CPU时间多，**n**值较小时，选择排序比冒泡排序快。

原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

## 算法稳定性

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

## 动图演示

![20170122083403_805.gif][0]

## 代码实现

```php
<?php

function selectSort(array $numbers = array())
{
    $count = count($numbers);
    if ($count <= 1) {
        return $numbers;
    }
    for ($i = 0; $i < $count - 1; $i++) {
        $min = $i;
        for ($j = $i + 1; $j < $count; $j++) {
            if ($numbers[$min] > $numbers[$j]) {
                $min = $j;
            }
        }

        if ($min != $i) {
            $temp          = $numbers[$min];
            $numbers[$min] = $numbers[$i];
            $numbers[$i]   = $temp;
        }
    }
    return $numbers;
}
```

</font>

[0]: ./img/1485352342887396.gif