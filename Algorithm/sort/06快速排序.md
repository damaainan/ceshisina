## 十大经典排序算法PHP实现教程（快速排序）
<font face=微软雅黑>

快速排序，又称划分交换排序，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 **n**个项目要 **O(n log n)**次比较。在最坏状况下则需要 **O(n<sup>2</sup>)**次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 **O(n log n)**算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

## 算法步骤

快速排序使用分治法策略来把一个序列分为两个子序列，步骤：

1. 从数列中挑出一个元素，称为"基准"。

2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。

3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代中，它至少会把一个元素摆到它最后的位置去。

## 效率分析

从一开始快速排序平均需要花费 **O(n log n)**时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用 **O(n)**的时间。在使用结合的版本中，这项运算也是 **O(n)**。

在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作 **log n**次嵌套的调用。这个意思就是调用树的深度是 **O(log n)**。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要 **O(n)**的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有 **O(n)**个调用，这些被归纳在 **O(n)**系数中）。结果是这个算法仅需使用 **O(n log n)**时间。

另外一个方法是为 **T(n)**设立一个递归关系式，也就是需要排序大小为n的数列所需要的时间。在最好的情况下，因为一个单独的快速排序调用牵涉了 **O(n)**的工作，加上对 **n/2**大小之数列的两个递归调用，这个关系式可以是：

**T(n) = O(n) + 2T(n/2)**

解决这种关系式类型的标准数学归纳法技巧告诉我们 **T(n) = O(n log n)**。

事实上，并不需要把数列如此精确地分区；即使如果每个基准值将元素分开为99%在一边和1%在另一边，调用的深度仍然限制在 **100logn**，所以全部运行时间依然是 **O(n log n)**。

然而，在最坏的情况是，两子数列拥有大各为 **1**和n-1，且调用树变成为一个 **n**个嵌套调用的线性连串。第 **i**次调用作了 **O(n-i)**的工作量，且 **∑ i = 0n(n - i) = O(n2)**递归关系式为：

**T(n) = O(n) + T(1) + T(n - 1) = O(n) + T(n - 1)**

这与插入排序和选择排序有相同的关系式，以及它被解为 **T(n) = O(n2)**。

 这一段来自 [维基百度][0] ，读起来有点难懂，不过没有关系，直接看例子就好了。

## 算法稳定性

快速排序有两个方向，左边的i下标一直往右走，当 `a[i] <= a[center_index]`，其中`center_index`是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当`a[j] > a[center_index]`。如果i和j都走不动了，`i <= j`, 交换`a[i]`和`a[j]`,重复上面的过程，直到`i>j`。 交换`a[j]`和`a[center_index]`，完成一趟快速排序。在`中枢元素`和`a[j]`交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在`中枢元素`和`a[j]` 交换的时刻。

## 动图演示

![Sorting_shellsort_anim.gif][1]

## 代码实现

```php
<?php
    function quickSort(array $numbers=array()) 
    {
        $count = count( $numbers );
        if( $count <= 1 ) return $numbers;
    
        $left = $right = array();
        $mid_value = $numbers[0];
    
        for ($i = 1; $i < $count; $i++)
        {
            if ($numbers[$i] < $mid_value)
                $left[]  = $numbers[$i];
            else
                $right[] = $numbers[$i];
        }
        return array_merge(quickSort($left), (array)$mid_value, quickSort($right));
    }
```

</font>

[0]: https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F
[1]: ./img/1485355982996769.gif