# [经典算法题每日演练——第五题 字符串相似度][0]

这篇我们看看最长公共子序列的另一个版本，求字符串相似度(编辑距离)，我也说过了，这是一个非常实用的算法，在DNA对比，网

页聚类等方面都有用武之地。

一：概念

对于两个字符串A和B，通过基本的增删改将字符串A改成B，或者将B改成A，在改变的过程中我们使用的最少步骤称之为“编辑距离”。

比如如下的字符串：我们通过种种操作，痉挛之后编辑距离为3，不知道你看出来了没有？

![][1]

二：解析

可能大家觉得有点复杂，不好理解，我们试着把这个大问题拆分掉，将"字符串 vs 字符串“，分解成”字符 vs 字符串“，再分解

成”字符 vs 字符“。

<1> ”字符“vs”字符“

这种情况是最简单的了，比如”A“与”B“的编辑距离很显然是1。

<2> ”字符”vs"字符串"

”A“改成”AB“的编辑距离为1，“A”与“ABA”的编辑距离为2。

<3>“字符串”vs“字符串”

“ABA”和“BBA”的编辑距离为1，仔细发现我们可以得出如下结论，”ABA“是由23个子序列与”BBA“字符串求的的编辑距离集

合中取出的最小编辑距离，也就是说在这种情况下我们出现了重复计算的问题，我在求子序列”AB“和”BBA"的编辑距离时，我是由

子序列”A“和”BBA“与”B“和”BBA“之间的编辑距离中选出一个最小值，然而序列A和序列B早之前我已经计算过了，这种重复计算

的问题有点像”斐波那契”，正好满足“动态规划”中的最优子结构和重叠子问题，所以我们决定采用动态规划来解决。

三：公式

跟“最长公共子序列”一样，我们采用一个二维数组来保存字符串X和Y当前的位置的最小编辑距离。

现有两个序列X={x1,x2,x3，...xi}，Y={y1,y2,y3，....，yi}，

设一个C[i,j]: 保存Xi与Yj的当前最小的LD。

①： 当 Xi = Yi 时，则C[i,j]=C[i-1,j-1]；

②：当 Xi != Yi 时， 则C[i,j]=Min{C[i-1,j-1],C[i-1,j],C[i,j-1]}；

最终我们的C[i,j]一直保存着最小的LD。

四：代码


```csharp
using System;

namespace ConsoleApplication2
{
    public class Program
    {
        static int[,] martix;

        static string str1 = string.Empty;

        static string str2 = string.Empty;

        static void Main(string[] args)
        {
            while (true)
            {
                str1 = Console.ReadLine();

                str2 = Console.ReadLine();

                martix = new int[str1.Length + 1, str2.Length + 1];

                Console.WriteLine("字符串 {0} 和 {1} 的编辑距离为:{2}\n", str1, str2, LD());
            }
        }

        /// <summary>
        /// 计算字符串的编辑距离
        /// </summary>
        /// <returns></returns>
        public static int LD()
        {
            //初始化边界值(忽略计算时的边界情况)
            for (int i = 0; i <= str1.Length; i++)
            {
                martix[i, 0] = i;
            }

            for (int j = 0; j <= str2.Length; j++)
            {
                martix[0, j] = j;
            }

            //矩阵的 X 坐标
            for (int i = 1; i <= str1.Length; i++)
            {
                //矩阵的 Y 坐标
                for (int j = 1; j <= str2.Length; j++)
                {
                    //相等情况
                    if (str1[i - 1] == str2[j - 1])
                    {
                        martix[i, j] = martix[i - 1, j - 1];
                    }
                    else
                    {
                        //取“左前方”，“上方”，“左方“的最小值
                        var temp1 = Math.Min(martix[i - 1, j], martix[i, j - 1]);

                        //获取最小值
                        var min = Math.Min(temp1, martix[i - 1, j - 1]);

                        martix[i, j] = min + 1;
                    }
                }
            }

            //返回字符串的编辑距离
            return martix[str1.Length, str2.Length];
        }
    }
}
```

![][2]

![][3]

[0]: http://www.cnblogs.com/huangxincheng/archive/2012/11/11/2765633.html
[1]: ./img/2012111122013292.png
[2]: ./img/2012111123291224.png
[3]: ./img/2012111123401124.png