# [经典算法题每日演练——第四题 最长公共子序列][0]

一： 作用

最长公共子序列的问题常用于解决字符串的相似度，是一个非常实用的算法，作为码农，此算法是我们的必备基本功。

二：概念

举个例子， cn blogs 这个字符串中子序列有多少个呢？很显然有27个，比如其中的cb,cgs等等都是其子序列，我们可以看出

子序列不见得一定是连续的，连续的那是子串。

我想大家已经了解了子序列的概念，那现在可以延伸到两个字符串了，那么大家能够看出：cnblogs和belong的公共子序列吗？

在你找出的公共子序列中，你能找出最长的公共子序列吗？

![][1]

从图中我们看到了最长公共子序列为blog，仔细想想我们可以发现其实最长公共子序列的个数不是唯一的，可能会有两个以上，

但是长度一定是唯一的，比如这里的最长公共子序列的长度为4。

三：解决方案

<1> 枚举法

这种方法是最简单，也是最容易想到的，当然时间复杂度也是龟速的，我们可以分析一下，刚才也说过了cnblogs的子序列

个数有27个 ，延伸一下：一个长度为N的字符串，其子序列有2N个，每个子序列要在第二个长度为N的字符串中去匹配，匹配一次

需要O(N)的时间，总共也就是O(N*2N)，可以看出，时间复杂度为指数级，恐怖的令人窒息。

<2> 动态规划

既然是经典的题目肯定是有优化空间的，并且解题方式是有固定流程的，这里我们采用的是矩阵实现，也就是二维数组。

第一步：先计算最长公共子序列的长度。

第二步：根据长度，然后通过回溯求出最长公共子序列。

现有两个序列X={x1,x2,x3，...xi}，Y={y1,y2,y3，....，yi}，

设一个C[i,j]: 保存Xi与Yj的LCS的长度。

递推方程为：

![][2]

不知道大家看懂了没？动态规划的一个重要性质特点就是解决“子问题重叠”的场景，可以有效的避免重复计算，根据上面的

公式其实可以发现C[i,j]一直保存着当前(Xi,Yi)的最大子序列长度。

 


     1 using System;
     2 namespace ConsoleApplication2
     3 {
     4     public class Program
     5     {
     6         static int[,] martix;
     7 
     8         static string str1 = "cnblogs";
     9         static string str2 = "belong";
    10 
    11         static void Main(string[] args)
    12         {
    13             martix = new int[str1.Length + 1, str2.Length + 1];
    14 
    15             LCS(str1, str2);
    16 
    17             //只要拿出矩阵最后一个位置的数字即可
    18             Console.WriteLine("当前最大公共子序列的长度为:{0}", martix[str1.Length, str2.Length]);
    19 
    20             Console.Read();
    21         }
    22 
    23         static void LCS(string str1, string str2)
    24         {
    25             //初始化边界，过滤掉0的情况
    26             for (int i = 0; i <= str1.Length; i++)
    27                 martix[i, 0] = 0;
    28 
    29             for (int j = 0; j <= str2.Length; j++)
    30                 martix[0, j] = 0;
    31 
    32             //填充矩阵
    33             for (int i = 1; i <= str1.Length; i++)
    34             {
    35                 for (int j = 1; j <= str2.Length; j++)
    36                 {
    37                     //相等的情况
    38                     if (str1[i - 1] == str2[j - 1])
    39                     {
    40                         martix[i, j] = martix[i - 1, j - 1] + 1;
    41                     }
    42                     else
    43                     {
    44                         //比较“左边”和“上边“，根据其max来填充
    45                         if (martix[i - 1, j] >= martix[i, j - 1])
    46                             martix[i, j] = martix[i - 1, j];
    47                         else
    48                             martix[i, j] = martix[i, j - 1];
    49                     }
    50                 }
    51             }
    52         }
    53     }
    54 }


![][3]

图大家可以自己画一画，代码完全是根据上面的公式照搬过来的，长度的问题我们已经解决了，这次要解决输出最长子序列的问题，

我们采用一个标记函数Flag[i,j]，当

①：C[i,j]=C[i-1,j-1]+1 时 标记Flag[i,j]="left_up"; （左上方箭头）

②：C[i-1,j]>=C[i,j-1] 时 标记Flag[i,j]="left"; （左箭头）

③: C[i-1,j]<C[i,j-1] 时 标记Flag[i,j]="up"; （上箭头）

例如：我输入两个序列X=acgbfhk，Y=cegefkh。

 


     1 using System;
     2 
     3 namespace ConsoleApplication2
     4 {
     5     public class Program
     6     {
     7         static int[,] martix;
     8 
     9         static string[,] flag;
    10 
    11         static string str1 = "acgbfhk";
    12 
    13         static string str2 = "cegefkh";
    14 
    15         static void Main(string[] args)
    16         {
    17             martix = new int[str1.Length + 1, str2.Length + 1];
    18 
    19             flag = new string[str1.Length + 1, str2.Length + 1];
    20 
    21             LCS(str1, str2);
    22 
    23             //打印子序列
    24             SubSequence(str1.Length, str2.Length);
    25 
    26             Console.Read();
    27         }
    28 
    29         static void LCS(string str1, string str2)
    30         {
    31             //初始化边界，过滤掉0的情况
    32             for (int i = 0; i <= str1.Length; i++)
    33                 martix[i, 0] = 0;
    34 
    35             for (int j = 0; j <= str2.Length; j++)
    36                 martix[0, j] = 0;
    37 
    38             //填充矩阵
    39             for (int i = 1; i <= str1.Length; i++)
    40             {
    41                 for (int j = 1; j <= str2.Length; j++)
    42                 {
    43                     //相等的情况
    44                     if (str1[i - 1] == str2[j - 1])
    45                     {
    46                         martix[i, j] = martix[i - 1, j - 1] + 1;
    47                         flag[i, j] = "left_up";
    48                     }
    49                     else
    50                     {
    51                         //比较“左边”和“上边“，根据其max来填充
    52                         if (martix[i - 1, j] >= martix[i, j - 1])
    53                         {
    54                             martix[i, j] = martix[i - 1, j];
    55                             flag[i, j] = "left";
    56                         }
    57                         else
    58                         {
    59                             martix[i, j] = martix[i, j - 1];
    60                             flag[i, j] = "up";
    61                         }
    62                     }
    63                 }
    64             }
    65         }
    66 
    67         static void SubSequence(int i, int j)
    68         {
    69             if (i == 0 || j == 0)
    70                 return;
    71 
    72             if (flag[i, j] == "left_up")
    73             {
    74                 Console.WriteLine("{0}: 当前坐标:（{1},{2}）", str2[j - 1], i - 1, j - 1);
    75 
    76                 //左前方
    77                 SubSequence(i - 1, j - 1);
    78             }
    79             else
    80             {
    81                 if (flag[i, j] == "up")
    82                 {
    83                     SubSequence(i, j - 1);
    84                 }
    85                 else
    86                 {
    87                     SubSequence(i - 1, j);
    88                 }
    89             }
    90         }
    91     }
    92 }


![][4]

由于直接绘图很麻烦，嘿嘿，我就用手机拍了张：

![][5]

好，我们再输入两个字符串：

    1         static string str1 = "abcbdab";
    2 
    3         static string str2 = "bdcaba";

![][6]

![][7]

通过上面的两张图，我们来分析下它的时间复杂度和空间复杂度。

时间复杂度：构建矩阵我们花费了O(MN)的时间，回溯时我们花费了O（M+N)的时间，两者相加最终我们花费了O(MN)的时间。

空间复杂度：构建矩阵我们花费了O(MN)的空间，标记函数也花费了O(MN)的空间，两者相加最终我们花费了O(MN)的空间。

[0]: http://www.cnblogs.com/huangxincheng/archive/2012/11/11/2764625.html
[1]: http://pic002.cnblogs.com/images/2012/214741/2012111101005887.png
[2]: http://pic002.cnblogs.com/images/2012/214741/2012111100085930.png
[3]: http://pic002.cnblogs.com/images/2012/214741/2012111100213372.png
[4]: http://pic002.cnblogs.com/images/2012/214741/2012111101163982.png
[5]: http://pic002.cnblogs.com/images/2012/214741/2012111100372491.png
[6]: http://pic002.cnblogs.com/images/2012/214741/2012111101120989.png
[7]: http://pic002.cnblogs.com/images/2012/214741/2012111100405760.png