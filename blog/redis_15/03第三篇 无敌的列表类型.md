# [15天玩转redis —— 第三篇 无敌的列表类型][0] 


据说60%的人使用redis看重的是redis中的list类型，那这个list有什么用呢？？？不用我说大家都明白，做队列使用呗，为什么用它呢，很简单呗，

因为有了它我就不需要专门的MQ产品啦，比如说RabbitMQ，ActiveMQ等等。。。对吧。

一：实战

先我们还是看一下List列表给我们提供的方法。

![][1]

这些方法还是稀里糊涂的有一些的，没关系，做队列使用的话，常用的也就四个：LPOP，LPUSH，RPOP，RPUSH，从这四个单词上面，你应该就明白这

有点像数据结构中的“双端队列”，对吧，既然我可以在左边Pop或者Push，又可以在右边Pop或者Push，那这样的话，我又可以把List做成队列或者堆栈，

哈哈，是不是很有意思，下面我举个例子： 我向List的左边顺序的塞入10，20，30，40，50，然后从队列的另一头依次输出10，20，30，40，50。

![][2]

对了，我就说一下在我们目前的项目中使用list的一些场景吧。

1. 由于项目中使用了大量的wcf，导致配置过多，维护和更新异常繁琐，基于这种情况，我们把wcf可以异步处理的所有请求都丢到了redis的List中去，

这样 下来之后，web站点的config配置清爽的不要不要的。

2. 还有一个业务就是我们做的淘宝订单催付，付款提醒，签收提醒，收货提醒 等等都是采用轮询List的方式，大大降低了代码复杂量。

好了，这个大概就是list的使用场景，既然这么牛逼的不要不要的，你肯定会好奇，这吊毛是怎么实现的？？？ 下面我简单的扯一扯。。。

二：探索原理

结合上面说的那么多，你可能会觉得这个List也许就是C#中的那个List实现吧。。。如果你这样想，那就说明你看问题比较付肤浅了哦，其实list的

源代码是在adlist.c中，如下所示。

![][3]

是不是简单的一吊，如果你学过数据结构中的链表，我想你一看便懂：

<1> listNode 

很明显这是一个node节点，可以看出它有一个prev指针和一个next指针，分别指向节点的前驱和后继，然后还有一个void* 这个类型的value，

它存放的就是上一篇我们所说的SDS类型的枚举。

<2> list

这个list蛮有意思的一点就是，里面有一个head和tail节点， 可想而知，tail存放的是list的尾节点，有了这个节点就说明什么呢？说明你删除尾节点的复杂度是O(1),同样有了这个head，你删除头节点同样也是O(1)。这就有了刚才说的LPush,LPop,RPush,RPop ，是的吧，同时list里面还有一个len属性，是记录当前list的元素个数，这样的话，你统计list的个数也是O(1)的，对吧。还记得上一篇所说的RedisObject吧，里面有一个ptr指针，它指向的就是本篇的list，好了，根据种种总结，我应该可以画出如下的图：

![][4]

大概就是这样的了，洗洗睡啦，么么哒~~~

[0]: http://www.cnblogs.com/huangxincheng/p/4970231.html
[1]: ./img/214741-20151116210731827-1383855163.png
[2]: ./img/214741-20151116221926655-1151466633.png
[3]: ./img/214741-20151116214457405-583316699.png
[4]: ./img/214741-20151116215644593-1009012256.png