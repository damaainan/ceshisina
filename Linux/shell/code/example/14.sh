#!/bin/bash

echo "No code, just some comments."





#   ### 通配符
#   *         代表任意（0个或多个）字符
#   ?         代表任意1个字符
#   [abc]     匹配括号中任意一个字符
#   [!abc]    不匹配括号中任意一个字符，等价于[^abc]
#   [a-z]     匹配括号中字符范围内的任意一个字符
#   {a,b,c}   生成序列，以逗号分隔，且不能有空格
#   {a..z}    生成指定范围的序列



#   ### 参数变量
#   $0   当前shell脚本的名称
#   $n   当前shell脚本的第n个参数,$1是第一个参数，$2是第二个参数，${10}是第十个参数
#   $*   当前shell脚本的所有参数(不包括脚本本身),将所有参数当作一个字符串整体
#   $@   当前shell脚本的所有参数(不包括脚本本身),循环遍历所有参数  
#   $#   当前shell脚本的参数个数(不包括脚本本身)
#   $$   当前shell脚本的PID
#   $?   最后一个指令的返回值(退出状态)；0表示没有错误，非0表示有错误



#   ### 特殊符号
#   #      注释；“#!”作为shell脚本行首，指定解释器
#   $      引用变量；普通用户的命令提示符
#   ${}    正规引用变量的方式，能够区分变量的边界，可在字符串中表示变量
#   =      赋值，等号两侧没有空格
#   /      根目录；路径分隔符；运算符的除法
#   \      屏蔽别名；转义字符；放在一行命令的末端，表示换行
#          
#   ''     单引号，无法变量置换，所见即所得
#   ""     双引号，可以变量置换，解析变量输出和特殊符号；字符串内出现双引号本身，需要转义
#   ``     反引号，引用命令的结果，等价于$()
#          
#   |      管道，使用形式“命令1|命令2”和“|xargs”
#   &      后台执行
#        
#   {}     代码块，代码在当前shell执行，不产生subshell，代码块中的变量在代码块之后仍能访问；用于函数定义
#   ()     命令组，命令以“；”分割，所有命令都在子shell中执行，其中所定义的变量，仅作用于命令组本身，使用$获取()的值；初始化数组   
#   (())   整数扩展,执行里面的整数表达式，使用$获取(())的值
#   []     测试在[]内的表达式
#   [[]]   测试在[[]]内的表达式,可以使用“&&,||,<,>”等逻辑操作符
#   $[]    整数扩展，执行里面的整数表达式，并返回表达式的值
#   
#   ：     空命令，只是返回值0；作为while死循环的条件；在if分支中作为占位符（即某一分支什么也不做）
#   ;      分隔多个命令，依次执行
#   ;;     case语句中选项的终结符
#   ,      运算中的"区隔"



#   ### 目录操作
#   ~   “cd ~”进入当前用户的家目录
#   -   “cd -”进入用户上一次所在的目录，由环境变量$OLDPWD控制；“su -”切换用户并重新加载环境变量；选项的前缀
#   ..  上一级目录
#   .   当前目录；隐藏文件的文件名开头；正则表达式中表示任意一个字符



#   ### 逻辑操作
#   !    “非”；vi/vim中的强制退出；命令行下调用历史命令，“!<string>”、“!!”、“!<number>”等
#   &&   “与”；当前一个指令执行成功时，执行后一个指令
#   ||   “或”；当前一个指令执行失败时，执行后一个指令



#   ### 字符串比较
#   =   等于，等价于“==”
#   !=  不等于



#   ### 运算符
#   +   加法
#   -   减法
#   *   乘法
#   /   除法
#   **  求幂
#   %   求模（除法的余数）