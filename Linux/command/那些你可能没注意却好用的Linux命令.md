这篇文章仅讨论 Linux 环境下的东西，很显然对 MacOS 也适用。其实很多东西虽然有 Windows 也可以找的到但配置比较麻烦，这里不再仔细讲。很多东西像 Linux 老鸟看起来会觉得哈哈哈实在是太基础。但是像 cd, ls, mkdir 这些太基础的写在这里又显得太业余，所以很多十分常用的命令这边我也跳过了。像 git 这种重量级的工具，和 sed, awk 这些能单独出书的东西我觉得我也讲不清楚，所以这边都是功能简单的小东西。不过这些小问题就算了吧...

## 如果你时间比较充裕

...那么不如看看这本书吧: [<<The Linux Command Line\>>][0]。书的内容就跟标题一样，深入浅出的介绍了所谓 "Linux 命令行" 的方方面面，本文很多内容也是从书里看到的。网站上有 PDF 合法免费下载，书写的很好可以很随意的看不会觉得压力太大。最主要的，如果你是刚刚接触 Linux 那么这个说不定是最好的上手教程，我十分后悔原来不知道这么书。这么说起来另外一本 Linux 入门大师级教程应该是[鸟哥私房菜][1]，这个实在是太出名以至于我觉得没什么可以说的。

## 如果你没什么空的话

那下面就以随机的顺序列出一些我觉得非常棒的命令行工具。这里不详细介绍各种参数，你应该做的是用 man xxx 来查看文档。如果这些程序在你的发行版里没有安装，那么请手动搜一下。Mac 用户的话在 [homebrew][2] 里可以应该都能找到。

### tmux

虽然说顺序很随机但这一条一定得排在第一个。很多人用 Linux 的状态都是自己的机器是 Windows，用 putty 连到一个哪里的 Linux 服务器进行工作。这样的话每次断开的时候你运行的程序都是会被杀掉的。你可能会希望退出的时候能把打开的程序保持在那里，下次用连接的时候又能自动到之前的工作状态。tmux 就是这个问题的终极解决方案。它们一方面的功能是能在一个 Terminal 里创建多个“窗口”，另一方面如果你关闭连接或者意外掉线，它们默认也不会关掉，下次连上去可以用 tmux attach 来恢复你之前的工作状态。

如果你没听说过这个或者类似的 screen 的话，那你应该给我一点现金。

### tree

ls 可能是你最常用的命令之一。tree 可以递归的列出目录下所有的文件，并以树状形式展现：

    $ tree
    .
    ├── b
    ├── c
    │   └── d
    └── what

对应的也有 pstree 可以以这样的方式来显示进程树。

### ack

我记得我曾经在面试的时候被问到过“请写如何调用 grep 来列出当前目录下所有文件里，含有某个字符串的行”。这个问题我的回答是 “用 ack 就可以了”。ack 的官网域名就叫 [_betterthangrep.com_][3]。由于在当前目录下载所有文件里查找某个字串符是如此常见的一个操作，执行 ack foo 就可以在当前目录所有文件里查找 foo。ack 默认会跳过很多没用的目录和文件，让查找更快，输出结果更准确。另外像默认开启的彩色显示也让人用起来很舒畅。

ack 目前大部分发行版中没有，如果你使用的是 Ubuntu 的话其包裹名字是 ack-grep，执行文件的名字也一样。具体可以在[这里][4]查看文档。

### rsync

比如说你本地有一台电脑，远程有一台服务器。你想把你的一个文件夹全部拷贝到另外一边的某个地方去。你这个文件夹经常也要更新，希望通过某种方式把更新的部分能迅速同步过去。这应该怎么做？不知道 rsync 的话你可能会想用 git，搭建一个 ftp，或者用 scp 或者别的。但事实上 rsync 才是真正的为精确的解决这个问题而生的软件。rsync 最棒的地方就是差量更新，也就是只把另外一边缺少的东西传过去，而且你_不需要任何额外配置_，速度快的飞起。一个例子：

    rsync -arvuzp --chmod=g+rx ./built/ me@example.com:/var/www/site

### aspell

作为一个程序员你总有一天会要写英文文档。我等母语不是英文的出现拼写错误实在是太正常了。如果你用 Word 的话会有下划线提示你，但如果你是在代码里写注释或者再 Linux 下写 markdown 的话好像就没什么办法。事实上这也是一个已经被解决的问题，aspell 正是来做这个的。aspell 可以对任何纯文本进行拼写检查，作为面向程序员的工具它可以侦测文件类型，比如对 C++ 程序它就只检查注释里的单词。

### tee

有时候某些命令运行的结果会很长，你可能会用 less 来上下看。再或者你可能会用 > 来重定向到文件里。但某些时候程序有可能需要你输入 y 来确认，或者某些程序运行的时间很长，仅仅重定向的话又不太确定是不是它在正常运行。tee 就能做到又输出到屏幕上，又同时重定向到文件。一个简单的例子：

    $ echo waht | tee out.txt

waht 会被输出到屏幕上，同时也会被写到 out.txt 文件里。另外 tee 的意思其实是 T，把输入输出中间拉了又多扯出了一条，可谓是相当形象。

值得一提的是 vim 也可以用在 pipe 里，例子如下：

    $ echo waht | vim -

### <ctrl+r\>

你肯定知道用键盘上下方向键可以来回找你的历史，那么比如有一个很久之前打过的命令你可能需要猛按上才能找到。其实这时候只要输入一部分然后按 <ctrl+r\> bash 就会帮你往回搜索。连续按 <ctrl+r\> 可以按顺序往前搜。(或者直接按 <ctrl+r\> 再进行输入)。接着上面一个的例子，输入 echo 后按 <ctrl+r\> 效果如下：

    (reverse-i-search)`echo': echo waht | vim -

有往前搜索那么一般就有往后搜索。可惜的是往后搜索的快捷键是 <ctrl+s\>，如果你试着按一下的就会发现...好像机器没反应了。这个是因为 <ctrl+s\> 大部分情况下默认是 [XOFF][5]，代表暂停接收输入。按 <ctrl+q\> 就能恢复。当然你可以把向前搜索绑定到别的键上，请自行搜索。

### cloc

虽说代码行数不能说明任何问题，但有时候不知为什就是想知道。cloc 能精确的计算代码行数，把注释和空格都区分开。如果你是一名传说中的项目经理的话，从今天起开始用 cloc 给你手下的码农算工资吧！下附截屏：

    $ cloc /usr/include/
        9628 text files.
        9308 unique files.
         434 files ignored.
    
    T=39.0 s (227.6 files/s, 39948.2 lines/s)
    -------------------------------------------------
    Language        files    blank  comment      code
    -------------------------------------------------
    C/C++ Header     8875   217366   287013   1053368
    Teamcenter def      1       48        0       186
    -------------------------------------------------
    SUM:             8876   217414   287013   1053554
    -------------------------------------------------

### printenv

用 set 可以查看所有的 Shell 变量还包括 Shell 函数，但是其中有一些是仅仅在当前 shell 里其作用的。而往往你需要找的是通过 export 来定义的环境变量。printenv 就是用来做这个的。

### set -o vi

bash 或者可能绝大多数常见 shell 其实都是支持用 vi 的方式进行命令行编辑的，比如设置了 set -o vi 后你就可以用熟悉的 hjkl 来移动，用 w, b 来跳过单词等等。

同样的如果你设置了 EDITOR 环境变量的话，输入 fc 就可以把之前输入的命令行放到编辑器里来编辑，只要保存了的话就会执行。相反的放弃保存就等于是放弃。

### find

我把上面说到的[那本书][0]仔细看过以后，最大的收获之一就是终于学会了用 find。这个现在变成了我几乎每天都在用的一个命令。比如说我要把目录下所有的 png 文件加入到这次的 git commit 里面，我可以用:

    find . -name '*.png' -exec git add {} ';'

如果你熟悉 find 的话你会知道最后的 ; 可以换为 + 会更好，但用它就是有目的的。这个命令虽然看起来很简单，但里面的单引号省略或者换成双引号命令都是会失败的。这些牵涉到 "shell variable expansion" 和引号的 escape 规则，虽然感觉很恼火但其实这些只有几个简单的规则，而且一致性非常好。所以只要你肯花点时间把相关东西弄清楚，这种简单的问题就可以轻松搞定。

### type

如果 foo 是一个命令行里可以直接运行的程序的话，你应该知道用 which foo 可以找到 foo 的可执行文件路径在那里。但在命令行里可以执行的命令并不一定都对应到某个可执行的文件，它可以是 alias, shell 自带的函数和用户自己的函数等等。所以有时候用 which 找到不到东西的时候会让人很疑惑。其实你可以用 type foo 看看 foo 到底是什么类型的。

### help

上面提到了 "builtin command" 也就是内置命令，就是由 shell 提供的一些基本的或者无法由外部程序做到的命令。平常你可以用 man 来查看文档，但是对于内置命令 man 会跳到 shell 自己的 manpage，在某些系统里那就是巨大的一页你要再里面找到你想看的东西，有些系统里干脆就没有相关的信息。这种时候用 help 这个内置命令就可以解决这个问题：比如要查看 set 的接受的选项，可以用 help set 来轻松找到。

### env

你应该知道在 #! (shebang) 在脚本第一行的作用是指定其 'runtime'。比如说你想要写一个 Python 的脚本，但其实不太在意其版本，或者不确定其可执行文件在不同的机器上到底在哪里。那么 env 在这里就可以派上用场了。可以写成 #!/usr/bin/env python，这样执行的时候就会用当前 PATH 中找到的 python。另一方面这个也是一个给你一个在不修改代码的情况下，重新选择 'runtime' 的机会。

### file

如果你想知道某个路径上的文件到底是什么类型的，那么用 file 是再合适不过的了。它能对任何东西都给出一个有意义的解释，对于二进制文件还会列出很多相关的重要信息。

### strings

“我把我的秘密，放在了这个用 C++ 编写的程序里面。运行它输入正确的密码才能看到”。其实万一遇到这种情况你只要跑 strings program-written-in-cxx 十有八九你就能看到了。它能比较准确的列出二进制文件里包含的 C 风格的字符串。看起来没什么意义但是其实作用完全要靠你发挥，比如要知道某个程序是哪个版本 GCC 编译出来的用 strings 可能有结果。

### od

全程应该是 "object dump"，可以将文件按八进制，十六进制或者其他方式显示出来。我觉得大部分情况下这大家都在用 od -c，将文件按 ASCII 码 dump 出来。一个用例是用来看文件的 line ending 到底是怎样的。比如执行 od -c foo.txt 显示如下结果：

    $ od -c foo.txt
    0000000   h   e   l   l   o  \t   w   o   r   l   d  \r  \n   y   e   a
    0000020   h
    0000021

可以清楚的看到 \t 是 tab 字符， \r\n 是 Windows 风格的换行符。

[0]: http://linuxcommand.org/tlcl.php
[1]: http://linux.vbird.org/
[2]: http://brew.sh/
[3]: http://betterthangrep.com/
[4]: http://beyondgrep.com/install/
[5]: http://en.wikipedia.org/wiki/Software_flow_control