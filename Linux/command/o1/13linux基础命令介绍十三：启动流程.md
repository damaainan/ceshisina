## linux基础命令介绍十三：启动流程

来源：[https://segmentfault.com/a/1190000007878452](https://segmentfault.com/a/1190000007878452)

`固件`(firmware)是指设备最底层的，让设备得以运行的程序代码。简单理解就是：固定在硬件上的软件。计算机中的许多设备都拥有固件(如硬盘、鼠标、光驱、U盘等)，在计算机启动过程中，最先读取的就是位于主板上的`固件`，这个固件当前有两种类型：传统的`BIOS`和新的通用性更强的`UEFI`。

在上一篇中，我们提到另一种磁盘分区格式`GTP`也是`UEFI`标准的一部分。于是，当前计算机启动中，出现了两种不同的方式：`BIOS/MBR`和`UEFI/GTP`。

在linux操作系统的世界中，同样在经历着变革，系统初始化软件`sysvinit`正逐渐被`systemd`取代。
本文将主要讲述传统的`BIOS/MBR-->sysvinit`启动方式，同时，作为补充，也将简述`UEFI/GTP-->systemd`的启动方式。
## BIOS/MBR-->sysvinit
### 1、BIOS阶段

系统加电后会立即读取BIOS中内容并执行，BIOS中程序的执行包括两个步骤：

1）加电自检 **``POST``** (power-on self test)，主要负责检测系统外围设备(如CPU、内存、显卡、键盘鼠标等)是否正常。如果硬件出现问题，主板会发出不同含义的蜂鸣声，启动终止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

2）自检完成后，BIOS会执行一段程序来枚举本地设备(如光盘、U盘、硬盘、网络等，可以在BIOS中设置枚举顺序)寻找下一阶段的启动程序所在位置。BIOS会将控制权交给启动顺序(Boot Sequence)中排在第一位的设备，此时，计算机读取该设备中的最前面的512个字节，如果这512个字节的最后两个字节是0x55和0xAA(`Magic Number`)，表明这个设备可以用于启动；如果不是，表明该设备不能用于启动，控制权于是转交给启动顺序中的下一个设备。如上一篇所述，硬盘中的最前面的512字节即为`主引导记录 MBR`。
### 2、MBR阶段

前一篇中我们描述过MBR的结构，其中包括446字节的`Bootloader`，64字节的`DPT`和2字节的`Magic Number`。
`Bootloader`(引导加载程序)中较常用的一种是`grub`，`grub`引导分为两个阶段(有些grub还定义了1.5阶段)：

1）BIOS将stage1载入内存中的指定位置(0x7C00)并跳转执行，stage1的内容即为MBR中起始的446字节；此阶段执行作用主要是将硬盘0磁头0磁道2扇区的内容载入到内存0x8000处并跳转执行。

1.5）由于stage2的代码(较大)存放在文件系统下的/boot分区中(或者/boot没有单独分区的/etc/)，因此识别stage2文件需要文件系统环境(此时还只能直接读取硬盘指定位置的内容，并不能识别文件系统)。stage1.5的作用就是为stage2提供文件系统环境，使系统能够找到位于文件系统中的stage2文件。

2）stage2被载入内存并执行，它首先会解析grub的配置文件`menu.lst`即`/boot/grub/grub.conf`，该文件中指定了系统内核文件所处的位置，如果没有找到该文件，就会执行一个shell，等待用户手动指定内核文件的位置。此阶段的最终状态就是执行boot命令，将内核和initrd镜像载入内存，进而将控制权交给内核。
`grub.conf`内容(版本：GNU GRUB 0.97)：

```sh
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda3
#          initrd /initrd-version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.18-407.el5)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-407.el5 ro root=LABEL=/ rhgb quiet
        initrd /initrd-2.6.18-407.el5.img
title CentOS (2.6.18-398.el5)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-398.el5 ro root=LABEL=/ rhgb quiet
        initrd /initrd-2.6.18-398.el5.img
```

文件中#开头的行是注释行，最重要的部分是两个`title`下面指定的内核位置及具体文件(`kernel`和`initrd`项)
### 3、内核阶段

grub的stage2将initrd文件加载到内存中，内核于是开始执行initrd中的`init`文件，此文件是一个脚本，主要作用是加载各种存储介质相关的设备驱动程序。当所需的驱动程序加载完成后，会创建一个根设备，然后将根文件系统(`rootfs`)以只读的方式挂载。这一步结束后，释放未使用的内存，转换到真正的根文件系统中运行程序`/sbin/init`，启动系统PID为1的进程。此后系统的控制权就交给/sbin/init进程了。
### 4、init阶段

当`init`进程接管了系统的控制权之后，它首先会读取`/etc/inittab`文件，此文件描述了在特定的`运行级别`(runlevel)下，init进程该如何初始化系统。

```sh
linux中定义了7种运行级别：
0 表示关机
1 表示单用户模式
2 表示无网络的多用户模式
3 表示多用户模式
4 未使用
5 表示图形界面模式
6 表示重启
```
`inittab`文件中指定了系统的默认运行级别，如`id:3:initdefault:`表示默认运行级别为3(多用户模式)。
`init`进程根据`inittab`文件，运行一系列指定的初始化脚本：
1）`/etc/rc.d/rc.sysinit`系统初始化脚本，它的作用包括设置主机名和默认网关、决定是否启用SELinux、加载用户自定义模块、根据文件`/etc/sysctl.conf`设置内核参数、设置raid及LVM等硬盘功能、重新以读写方式挂载根文件系统等等

2）执行`/etc/rc.d/rc`文件，该文件确认由inittab指定的运行级别N，并启动相应级别下的服务(通过执行/etc/rc.d/rcN.d中的文件)，例如运行级别为3时，则先执行/etc/rc.d/rc3.d下以`K`开头的文件，然后执行以`S`开头的文件。这些文件都是指向/etc/init.d下的符号链接。以`K`开头的文件表示此运行级别下需要关闭的服务，以`S`开头的文件表示此运行级别下需要开启的服务。

3）在运行级别2、3、4、5中最后一个执行的文件均指向文件`/etc/rc.local`,用户可以在此文件中自定义启动内容。

4）之后根据inittab中设置，运行6个终端，以便用户登录系统，如果是运行级别5，则还会执行`/etc/X11/prefdm -nodaemon`启动相应的桌面环境。

5）然后执行`/bin/login`程序用于接收和验证来自mingetty的用户名和密码。

至此整个系统即启动完毕了
## UEFI/GTP-->systemd
`UEFI`的出现是为了代替`BIOS`，同样，`GTP`和`systemd`也是为了弥补`MBR`和`sysvinit`的不足。和`BIOS`只负责POST和找到MBR不同，`UEFI`将贯穿系统加电到关机的整个过程。粗略划分，UEFI系统启动分为4个阶段：
### 1、UEFI初始化阶段

1）`SEC`(安全验证)：接收并处理系统启动和重启信号，初始化临时存储区域，传递系统参数给下一阶段(即PEI)。

2）`PEI`(EFI前期初始化)：为DXE准备执行环境，将需要传递到DXE的信息组成HOB(Handoff Block)列表，最终将控制权转交到DXE手中。

3）`DXE`(驱动执行环境)：根据HOB列表初始化系统服务，然后遍历固件中的所有Driver，当驱动的依赖资源满足时，调度Dirver到执行队列执行，直到所有满足条件的Dirver都被加载。
### 2、操作系统加载器作为UEFI应用程序运行阶段

1）`BDS`(启动设备选择)：初始化控制台设备，加载必要的设备驱动，根据系统设置加载和执行启动项，用户选中某个启动项（或系统进入默认的启动项）后，OS Loader启动，系统进入TSL阶段。
`UEFI`中程序能够识别存储介质上的分区信息和文件系统(如：fat32)，此时会将`/EFI/boot/grub2.efi`(位于GTP格式硬盘的一个分区ESP，安装时自动生成)作为UEFI应用程序运行。

2）`TSL`(临时系统加载)：操作系统加载器(`OS Loader`也位于ESP分区)执行的第一阶段，在这一阶段OS Loader作为一个UEFI应用程序运行，系统资源仍然由UEFI内核控制。当启动服务的ExitBootServices()服务被调用后，系统进入`RT`(Run Time)阶段。
### 3、操作系统运行阶段
`RT`(运行时)：系统的控制权从UEFI内核转交到OS Loader手中，UEFI占用的各种资源被回收到OS Loader，仅有UEFI运行时服务保留给OS Loader和OS使用。随着OS Loader的执行，OS最终取得对系统的控制权。
在`init`作为系统初始化程序时，服务是通过`/etc/rc.d/init.d`中的脚本来管理并且是顺序执行的，当使用`systemd`作为系统初始化程序后，这些脚本被`服务单元`替换，并尽可能的并行启动进程。

在`systemd`中，一个单元配置文件可以描述如下内容之一：

```sh
系统服务(.service)
挂载点(.mount)
套接字(.sockets)
系统设备(.device)
交换分区(.swap)
文件路径(.path)
启动目标(.target)
由systemd管理的计时器(.timer)
....
```
`systemd`为保持向下兼容性还保留了一些`init`命令和概念，但所对应的文件都是指向`systemd`对应命令或文件的符号链接：

```sh
[root@centos7 temp]# ls -l /sbin/init 
lrwxrwxrwx. 1 root root 22 1月  15 2016 /sbin/init -> ../lib/systemd/systemd
[root@centos7 temp]# ls -l /usr/lib/systemd/system/runlevel*.target
lrwxrwxrwx. 1 root root 15 1月  15 2016 /usr/lib/systemd/system/runlevel0.target -> poweroff.target
lrwxrwxrwx. 1 root root 13 1月  15 2016 /usr/lib/systemd/system/runlevel1.target -> rescue.target
lrwxrwxrwx. 1 root root 17 1月  15 2016 /usr/lib/systemd/system/runlevel2.target -> multi-user.target
lrwxrwxrwx. 1 root root 17 1月  15 2016 /usr/lib/systemd/system/runlevel3.target -> multi-user.target
lrwxrwxrwx. 1 root root 17 1月  15 2016 /usr/lib/systemd/system/runlevel4.target -> multi-user.target
lrwxrwxrwx. 1 root root 16 1月  15 2016 /usr/lib/systemd/system/runlevel5.target -> graphical.target
lrwxrwxrwx. 1 root root 13 1月  15 2016 /usr/lib/systemd/system/runlevel6.target -> reboot.target
```
`systemd`启动后执行的第一个目标是`default.target`，但实际上default.target是指向graphical.target的符号链接。

```sh
[root@centos7 temp]# ls -l /usr/lib/systemd/system/default.target
lrwxrwxrwx. 1 root root 16 1月  15 2016 /usr/lib/systemd/system/default.target -> graphical.target
[root@centos7 temp]# cat /usr/lib/systemd/system/graphical.target
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target
Wants=display-manager.service
Conflicts=rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
AllowIsolate=yes
```

其中`Requires`行指明了本单元的依赖关系(其他各项意义可以通过命令`man systemd.unit`查看)，顺着此文件，可以找到需要执行的单元：`multi-user.target`、`basic.target`、`sysinit.target`、`local-fs.target swap.target`、`local-fs-pre.target`。
### 4、关机阶段
`AL`(After-life)：当系统硬件或操作系统出现严重错误不能继续正常运行时，固件会尝试修复错误，这时系统进入AL期。UEFI标准并没有定义此阶段的行为和规范。系统供应商可以自行定义。
## 相关命令
### init

**`1、`init``** 
`init`除了在系统初始化时起的重要作用外，还可以用来执行关机、重启、切换运行级别的作用：

```sh
#关机
init 0
#重启
init 6
#切换到单用户模式
init 1
```

**`2、`runlevel``**  显示运行级别

```sh
[root@centos7 temp]# runlevel 
N 3
[root@centos7 temp]# 
```

输出中`N`表示当前运行级别，如果系统启动后切换过运行级别，则输出类似于`3 5`表示之前运行级别为3，现在的运行级别为5。
 **`3、`halt``reboot``poweroff``shutdown``** 
这几个命令的作用就是关机或重启系统，通常只使用`shutdown`就可以了：

```sh
#立即关机
shutdown -h now
#在11:50分执行关机
shutdown -h 11:50
#如果要取消指定时间的关机，则在另一个终端中执行：
shutdown -c
#过30分钟之后重启系统，并且重启时不进行磁盘检测
shutdown -fr +30
```

**`4、`chkconfig``**  更新或查询服务的运行级别信息

```sh
#列出服务(还会列出xinetd管理的服务)
chkconfig --list
#增加一个服务
chkconfig --add httpd
#使服务在运行级别2、3、5时自启动
chkconfig --level 235 httpd on
```

**`5、`service``**  运行服务脚本(服务脚本位于/etc/init.d内，service本身也是脚本，位于/sbin内)

```sh
#列出所有服务状态
service --status-all
#列出单个服务状态
service nginx status
#启动服务
service nginx start
#停止服务
service nginx stop
#重启服务
service nginx restart
#重新加载配置文件
service nginx reload
```
### systemd
`systemd`并不是一个命令，而是一组命令，涉及到系统管理的方方面面。

**`1、`systemctl``**  控制systemd系统和管理服务

```sh
systemctl [OPTIONS...] COMMAND [NAME...]
```

如切换运行级别或开关机：

```sh
#重启(将执行reboot.target)
systemctl reboot
#暂停(将执行suspend.target)
systemctl suspend
#休眠(将执行hibernate.target)
systemctl hibernate
#切换至救援模式(单用户，将执行rescue.target)
systemctl rescue
#列出运行级别
systemctl get-default
#切换到运行级别5，即图形模式
systemctl isolate graphical.target
```

系统服务单元相关：

```sh
#列出正在运行的 Unit
systemctl list-units
#列出所有的 Unit
systemctl list-units --all
#列出所有加载失败的 Unit
systemctl list-units --failed
#列出Unit时指定类型
systemctl list-units --type=socket
```

系统和服务管理：

```sh
#系统状态
systemctl status
#服务状态(.service可以省略)
systemctl status nginx.service
#启动服务
systemctl start nginx
#停止服务
systemctl stop nginx
#重启服务
systemctl restart nginx
#重新加载配置文件
systemctl reload nginx
#设置服务开机启动
systemctl enable nginx
#列出所有安装的服务
systemctl list-unit-files
#指定类型
systemctl list-unit-files --type=target
```

还有许多其他选项，这里就不一一列举了。

**`2、`systemd-analyze``**  查看启动用时

```sh
[root@centos7 ~]# systemd-analyze 
Startup finished in 730ms (kernel) + 1.904s (initrd) + 9.909s (userspace) = 12.544s
```

输出显示了系统启动过程中各部分耗时

```sh
#各服务初始化用时
[root@centos7 ~]# systemd-analyze blame
          5.424s NetworkManager-wait-online.service
          1.830s dev-mapper-centos\x2droot.device
          1.055s firewalld.service
           980ms kdump.service
           549ms network.service
           ....
#输出各服务用时细节并写入文件(该文件可以用浏览器或图片查看器打开)
[root@centos7 ~]# systemd-analyze plot > file.svg
#序列化输出各服务详细完整的状态信息(输出内容很多，略)
[root@centos7 ~]# systemd-analyze dump
```

**`3、`systemd-cgls``**  递归显示控制组(`Cgroups`)信息
linux内核从版本2.6.24开始，引入了一个叫做`控制组`(control groups)的特性，是用于限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。关于Cgroups的内容本文不再展开。

```sh
[root@centos7 ~]# systemd-cgls 
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
├─user.slice
│ └─user-0.slice
│   ├─session-182.scope
│   │ ├─5165 sshd: root@pts/1    
│   │ ├─5167 -bash
│   │ ├─5409 systemd-cgls
....
....
```

**`4、`systemd-cgtop``**  显示各控制组的使用量(CPU,内存,IO)
显示效果类似命令`top`

```sh
[root@centos7 ~]# systemd-cgtop
Path                                                Tasks   %CPU   Memory  Input/s Output/s

/                                                   161    0.2   400.5M        -        -
/system.slice/NetworkManager.service                  1      -        -        -        -
/system.slice/auditd.service                          1      -        -        -        -
/system.slice/crond.service                           1      -        -        -        -
/system.slice/dbus.service                            1      -        -        -        -
/system.slice/firewalld.service                       1      -        -        -        -
....
```

**`5、`systemd-loginctl``**  控制systemd登录管理
此命令是命令`loginctl`的符号链接

```sh
#列出当前会话
[root@centos7 ~]# systemd-loginctl list-sessions
   SESSION        UID USER             SEAT            
       182          0 root                             
       154          0 root                             

2 sessions listed.
#列出当前登录用户
[root@centos7 ~]# loginctl list-users
       UID USER            
         0 root            

1 users listed.
#列出显示指定用户的信息
[root@centos7 ~]# loginctl show-user root
UID=0
GID=0
Name=root
Timestamp=三 2016-12-21 08:38:54 CST
TimestampMonotonic=77015538361
RuntimePath=/run/user/0
Slice=user-0.slice
Display=154
State=active
Sessions=182 154
IdleHint=no
IdleSinceHint=0
IdleSinceHintMonotonic=0
Linger=no
[root@centos7 ~]#
```

**`6、`timedatectl``**  系统时间和日期控制

```sh
[root@centos7 ~]# timedatectl 
      Local time: 三 2016-12-21 13:47:31 CST
  Universal time: 三 2016-12-21 05:47:31 UTC
        RTC time: 三 2016-12-21 05:47:31
       Time zone: Asia/Shanghai (CST, +0800)
     NTP enabled: n/a
NTP synchronized: no
 RTC in local TZ: no
      DST active: n/a
#设置时间
[root@centos7 ~]# timedatectl set-time "2012-10-30 18:17:16"
#列出时区
[root@centos7 ~]# timedatectl list-timezones
Africa/Abidjan
Africa/Accra
Africa/Addis_Ababa
Africa/Algiers
Africa/Asmara
....
#设置时区
[root@centos7 ~]# timedatectl set-timezone America/New_York
```

**`7、`hostnamectl``**  系统主机名控制

```sh
#状态
[root@centos7 ~]# hostnamectl status
   Static hostname: centos7
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 956ab824a02d489d85b079cb442d5442
           Boot ID: 9016d7627d8148ecb7fb77afaa89aeab
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-327.el7.x86_64
      Architecture: x86-64
#设置主机名(内核参数/proc/sys/kernel/hostname和文件/etc/hostname中都立即更新)
[root@centos7 ~]# hostnamectl set-hostname MYHOST
#重新登录后主机名即变为myhost(静态主机名)
[root@centos7 ~]# hostnamectl
   Static hostname: myhost
   Pretty hostname: MYHOST
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 956ab824a02d489d85b079cb442d5442
           Boot ID: 9016d7627d8148ecb7fb77afaa89aeab
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-327.el7.x86_64
      Architecture: x86-64
```

以上systemd相关所有命令(除systemd-cgls和systemd-cgtop外)，都可以使用选项`-H`指定远程基于systemd的主机(使用ssh协议)：

```sh
[root@centos7 ~]# hostnamectl -H 10.0.1.252
   Static hostname: idc-v-71252
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 956ab824a02d489d85b079cb442d5442
           Boot ID: 9016d7627d8148ecb7fb77afaa89aeab
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 4.4.4-1.el7.elrepo.x86_64
      Architecture: x86-64
```
`systemd`功能强大，使用方便，但也比较复杂，体系庞大。本文只介绍一点相关命令，更多内容就不在此展开了。

本文简述了传统的`BIOS`和新的`UEFI`启动流程，介绍了`init`和`systemd`部分相关命令。
