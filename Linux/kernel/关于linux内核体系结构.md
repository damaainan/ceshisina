**关于linux内核体系结构**

说到操作系统，我们都会知道windows操作系统，linux操作系统，苹果的ios操作系统，以前很火的塞班操作系统，还有最近消费类电子很火的android操作系统。一个完整的操作系统分为4个部分。

![][0]

可以把这个理解为我们用的手机。其中的硬件系统就是我们看到的整个手机了，cpu啊，内存啊，这些不拆开来看不到的，和触摸屏啊，按键之类看以看到的。操作系统内核就是我们说的android了，不过他包括了linux的内核了。操作系统服务就是android的一套结构了，给我们直观的就是那个有点炫的界面了。我们可以通过点击来实现我们想要的功能。用户应用就是我们常玩的QQ啊，导航啊，当然少不了各种好玩的游戏了，愤怒的小鸟，涂鸦跳，水果忍者，是不是又想玩一把？唉，还是好好学习吧，虽然手机就在旁边。

对于linux内核的单内核模式的系统，有可以把他分为如下：

![][1]

Linux内核又可分为5个大的模块。

其关系和主要功能可以见下图：

![][2]

**![][3]**

**关于linux内存**

物理内存可以分为下图所示：

内核占用内存开始部分；接下来是共硬盘，软盘使用的高速缓冲区部分，其中扣除显存和bios的640k到1m；然后是虚拟盘；最后一部分是为所有程序可以使用的主内存区。

![][4]

Linux内存管理中，段变换：将一个由段选择符和段内偏移构成的逻辑地址转换为一个线性地址。页变换：将线性地址转换为对应的物理地址。具体可见下图所示：

![][5]

虚拟地址：指的是由程序产生的由段选择符和段内偏移地址两个部分组成的地址。为什么叫它是虚拟的地址呢？因为这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换机构处理或映射后才会对应到相应的物理内存地址。

段描述符：向CPU提供了将逻辑地址映射为线性地址所必要的信息。描述符是由程序编译器、链接器、加载器或者操作系统创建的。

描述符表：保存描述符在描述符表中的，有两类

1、 全局描述符表（Global descriptor table---GDT）

2、 局部描述符表（Local descriptor table---LDT）

描述符表是由8字节构成的描述符项的内存中的一个数组。处理器是通过使用GDT和LDTR寄存器来定位GDT表和当前的LDT表。最多可以含有8192（2^13）个描述符。

选择符：逻辑地址的选择部分，用于指定一描述符的，它是通过指定一描述符表并且索引其中的一个描述符项完成的。

段寄存器：处理器将描述符中的信息保存在段寄存器中，因而可以避免在每次访问内存时查询描述符表。

![][6]

![][7]

线性地址：通过指定一个页表、页表中的某一页以及页中的偏移值，从而间接地指向对应的物理地址。

页表：一个简单的32位页指示器的数组。页表本身也是一页内存，因此它含有4K字节的内存，可容纳1K个32位的项。

![][8]

Offset = 2^12=4K， table =2^10, directory = 2^10，所以线性地址空间为2^10*2^10*4k=4G。

由于0.11内核把每个进程的最大可用的虚拟内存空间定义为64M，因此每个进程的逻辑地址可以用任务号*64M，就可以转换到线性空间的地址。

![][9]

**关于linux进程**

进程可以在内核态或者用户态运行，当资源可用就被唤醒，进入就绪态；当进程处于可中断睡眠状态，收到信号可被唤醒；当处于不可中断睡眠状态，只能被使用wakeup等的唤醒；当进程处于暂停状态，可发送信号使其进入就绪态；当僵死状态，当已经停止运行，父进程还没有调用wait查询状态，一旦父进程调用完wait取得子进程信息后，这个进程任务数据结构就会被释放掉。

**![][10]**

![][11]

**关于linux文件系统和源码目录**

![][12]

![][13]

![][14]

![][15]

**![][16]**

![][17]

![][18]

![][19]

![][20]

![][21]

**![][22]**

![][23]

**![][24]****![][25]****![][26]****![][27]**

**关于linux内核makefile**

Linux makefile文件是编译辅助工具软件make的参数配置文件。Make工具软件的主要用途是通过识别哪些文件已经被修改过，从而自动地决定在一个含有多个源程序文件的程序系统中哪些文件需要被重新编译。

![][28]

这里的makefile主要作用是指示make程序最终使用独立编译连接成的tools/目录中的build执行程序将所有内核编译代码连接和合并成一个可运行的内核映像文件image。具体是对boot/目录中的bootsect.s、setup.s使用8086汇编器进行编译，分别生成各自的执行模块。再对源代码中的其他所有程序使用GNU的编译器gcc/gas进行编译，并连接成模块system。再用build工具将这三块组合成一个内核映像文件image。

[0]: ../IMG/v2-2842eff8607351dfa1e0b83ee0074642_hd.jpg
[1]: ../IMG/v2-ba3c6fbbff54e4ce77c325b6568de356_hd.jpg
[2]: ../IMG/v2-d826d3d532947aa1e5374d32ed086528_hd.jpg
[3]: ../IMG/v2-5cbdc33a9e2db058beddd157b511f9d1_hd.jpg
[4]: ../IMG/v2-dd88cbd09ebe11a06a0e2c4998c757c9_hd.jpg
[5]: ../IMG/v2-6911e2b2158fa6f05278d5d017cfd77d_hd.jpg
[6]: ../IMG/v2-bd8fc217dea8bc7805dd141affb2cd42_hd.jpg
[7]: ../IMG/v2-82dbccd319efddd1615406a65b7283a0_hd.jpg
[8]: ../IMG/v2-e4e9f6155c63e2da0cb6d78051f463c6_hd.jpg
[9]: ../IMG/v2-0313c8dd0da017bb7678b81d92a024b7_hd.jpg
[10]: ../IMG/v2-af380589b37c798781d02f84a652b3b0_hd.jpg
[11]: ../IMG/v2-f98010a07f87baa04dc9b0a31525eb58_hd.jpg
[12]: ../IMG/v2-66eb25703c64074648c6617807291ed2_hd.jpg
[13]: ../IMG/v2-94c1de8112f9f61a327461cf4e317282_hd.jpg
[14]: ../IMG/v2-7b23f1cf82a0409c257dcb5812117bb3_hd.jpg
[15]: ../IMG/v2-72e67c933bc832690be8f76b4f737b1a_hd.jpg
[16]: ../IMG/v2-afa401a4f711df6fdf7d8af21d66837f_hd.jpg
[17]: ../IMG/v2-49308ee98bb4c25e6bab408cbcb70837_hd.jpg
[18]: ../IMG/v2-1d3f2167aa8a0da35175205bb5129fb8_hd.jpg
[19]: ../IMG/v2-10ef47901a34ce28164363e3709cfbe8_hd.jpg
[20]: ../IMG/v2-ec21caed26a2656771d575b1e06fca6d_hd.jpg
[21]: ../IMG/v2-c7ef1431ac176012565533ec41194039_hd.jpg
[22]: ../IMG/v2-a3774a2e2dc54abd63ef0fa3c7ec27f1_hd.jpg
[23]: ../IMG/v2-61e6a8bec816c546df57233b241a1311_hd.jpg
[24]: ../IMG/v2-7faa8cf89822a1e2818e39e753a02cc9_hd.jpg
[25]: ../IMG/v2-32776f61025e1242f0acc38f038b72ae_hd.jpg
[26]: ../IMG/v2-2277f6cd6439b997ade2be40eeb7acb4_hd.jpg
[27]: ../IMG/v2-ce617de7df0f27611abde1b4c02fb1a6_hd.jpg
[28]: ../IMG/v2-e0edea7c5d76d993b49e6dbc29fdc8cd_hd.jpg